<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LocallyWeightedProjectionRegressionLibrary: lwpr.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_298f87db2c1cba43efabc3c5f4fa9ff0.html">Volumes</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_55c01fe2c4e33086155b7af166379d0d.html">duerer</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_e649ffe43dddcd8c18e8978de920ceca.html">clmc</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a11192148bba0ec087a757509aa6dd8a.html">prog</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_c8e2b4fb39d7204bab6a7c3e4b6e0c2f.html">lwpr</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_c554f24c1e963371c0bdc51ac62c3bc2.html">src</a>
  </div>
</div>
<div class="contents">
<h1>lwpr.c</h1><a href="lwpr_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00016"></a>00016 <span class="comment">// general UNIX headers</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include "stdio.h"</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "math.h"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "string.h"</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">// my utilities library </span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "utility.h"</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">// the lwpr header file </span>
<a name="l00026"></a>00026 <span class="preprocessor">#include "<a class="code" href="lwpr_8h.html">lwpr.h</a>"</span>
<a name="l00027"></a>00027 
<a name="l00029"></a><a class="code" href="lwpr_8c.html#959b3abf0f46a44251fd75b173360097">00029</a> <span class="preprocessor">#define SPHERING FALSE</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00032"></a><a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f">00032</a> <span class="preprocessor">#define LAMBDA(l,w) (1.+w*(l-1.))</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="comment">// all the LWPR models which can be handled by this program</span>
<a name="l00036"></a><a class="code" href="lwpr_8h.html#0184f497f582f75bda77d822a1272f3f">00036</a> LWPR  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[<a class="code" href="lwpr_8h.html#c378fe6d9192236b65019aec93d430d4">MAX_LWPRS</a>+1];
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="comment">// this flag turns on a large amount of print-outs</span>
<a name="l00039"></a>00039 <span class="keyword">static</span> <span class="keywordtype">int</span>  DEBUG_FLAG = FALSE;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">// needed for weight normalization</span>
<a name="l00042"></a>00042 <span class="keyword">static</span> <span class="keywordtype">double</span>  sum_activation=0;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// local functions</span>
<a name="l00045"></a>00045 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00046"></a>00046 addRF(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> n_proj, <span class="keywordtype">int</span> n_proj_2nd, <span class="keywordtype">int</span> n_nn);
<a name="l00047"></a>00047 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00048"></a>00048 initRF(<span class="keywordtype">int</span>      ID, 
<a name="l00049"></a>00049        <span class="keywordtype">int</span>      rfID,
<a name="l00050"></a>00050        Vector   c,
<a name="l00051"></a>00051        Matrix   M);
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00053"></a>00053 myExp(<span class="keywordtype">double</span> value, <span class="keywordtype">int</span> lookup);
<a name="l00054"></a>00054 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00055"></a>00055 calculateWeight(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x);
<a name="l00056"></a>00056 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00057"></a>00057 calculateMahal(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x);
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00059"></a>00059 calculateWeightp(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x);
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00061"></a>00061 calculateMahalp(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x);
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00063"></a>00063 updateMeanVar(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_w, Vector x, Vector xmz);
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00065"></a>00065 updateRegMeanVar(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector y, Vector ymz);
<a name="l00066"></a>00066 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00067"></a>00067 checkAddDim(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID);
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00069"></a>00069 addDimension(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID);
<a name="l00070"></a>00070 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00071"></a>00071 calculateRegression(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_mz, Vector y_mz);
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00073"></a>00073 updateAdmVars(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID);
<a name="l00074"></a>00074 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00075"></a>00075 updateDistanceMetric(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *x_mz);
<a name="l00076"></a>00076 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00077"></a>00077 createFakeTarget(<span class="keywordtype">int</span> ID,<span class="keywordtype">int</span> i, Vector xmz, Vector err,<span class="keywordtype">int</span> flag, Vector yfake);
<a name="l00078"></a>00078 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00079"></a>00079 checkNeighborhood(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID1, <span class="keywordtype">int</span> rfID2);
<a name="l00080"></a>00080 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00081"></a>00081 deleteNNFromRF(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> del_rfID);
<a name="l00082"></a>00082 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00083"></a>00083 addNNToRF(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> add_rfID, <span class="keywordtype">double</span> w);
<a name="l00084"></a>00084 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00085"></a>00085 swapNNID(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> old_rfID, <span class="keywordtype">int</span> new_rfID);
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l00087"></a>00087 calculateDWDM(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_w, <span class="keywordtype">double</span> penalty, Matrix dwDM, Matrix dpdM,
<a name="l00088"></a>00088               Matrix dppdMdM, Matrix dwwdMdM, <span class="keywordtype">double</span> *max_M);
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00090"></a>00090 calculateRegression2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_mz, Vector y_mz);
<a name="l00091"></a>00091 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00092"></a>00092 updateRegMeanVar2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector y, Vector ymz);
<a name="l00093"></a>00093 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00094"></a>00094 createFakeTarget2nd(<span class="keywordtype">int</span> ID,<span class="keywordtype">int</span> rfID, Vector xmz, Vector err,<span class="keywordtype">int</span> flag, 
<a name="l00095"></a>00095                     Vector yfake);
<a name="l00096"></a>00096 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00097"></a>00097 updateMeanVar2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x, Vector xmz);
<a name="l00098"></a>00098 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00099"></a>00099 updateAdmVars2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID);
<a name="l00100"></a>00100 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00101"></a>00101 addDimension2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID);
<a name="l00102"></a>00102 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00103"></a>00103 checkAddDim2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">/*!*****************************************************************************</span>
<a name="l00107"></a>00107 <span class="comment"> *******************************************************************************</span>
<a name="l00108"></a>00108 <span class="comment"> \note  initLWPR</span>
<a name="l00109"></a>00109 <span class="comment"> \date  November, 1994</span>
<a name="l00110"></a>00110 <span class="comment"> </span>
<a name="l00111"></a>00111 <span class="comment"> \remarks </span>
<a name="l00112"></a>00112 <span class="comment"> </span>
<a name="l00113"></a>00113 <span class="comment"> Initiates a lwpr model with all mandatory values and default</span>
<a name="l00114"></a>00114 <span class="comment"> values otherwise. The default values can be changed by dedicated functions.</span>
<a name="l00115"></a>00115 <span class="comment"> </span>
<a name="l00116"></a>00116 <span class="comment"> *******************************************************************************</span>
<a name="l00117"></a>00117 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l00118"></a>00118 <span class="comment"> </span>
<a name="l00119"></a>00119 <span class="comment"> \param[in]     n_in_w          : number of input dimensions for weights</span>
<a name="l00120"></a>00120 <span class="comment"> \param[in]     n_in_reg        : number of input dimensions for regression</span>
<a name="l00121"></a>00121 <span class="comment"> \param[in]     n_in_reg_2nd    : number of input dimensions for 2nd regression </span>
<a name="l00122"></a>00122 <span class="comment">                      (0=no 2nd model)</span>
<a name="l00123"></a>00123 <span class="comment"> \param[in]     n_out           : number of output dimensions for regression</span>
<a name="l00124"></a>00124 <span class="comment"> \param[in]     n_out_2nd       : number of output dimensions for 2nd regression</span>
<a name="l00125"></a>00125 <span class="comment"> \param[in]     diag_only       : TRUE/FALSE to update only the diagonal distance metric</span>
<a name="l00126"></a>00126 <span class="comment"> \param[in]     meta            : TRUE/FALSE to allow the use of a meta learning parameter</span>
<a name="l00127"></a>00127 <span class="comment"> \param[in]     meta_rate       : the meta learning rate</span>
<a name="l00128"></a>00128 <span class="comment"> \param[in]     penalty         : a smoothness bias, usually a pretty small number (1.e-4)</span>
<a name="l00129"></a>00129 <span class="comment"> \param[in]     init_alpha      : the initial learning rates</span>
<a name="l00130"></a>00130 <span class="comment"> \param[in]     norm_in_w       : the normalization of the inputs for weights</span>
<a name="l00131"></a>00131 <span class="comment"> \param[in]     norm_in_reg     : the normalization of the inputs for regression</span>
<a name="l00132"></a>00132 <span class="comment"> \param[in]     norm_in_reg_2nd : the normalization of the inputs for 2nd regression</span>
<a name="l00133"></a>00133 <span class="comment"> \param[in]     norm_out        : the normalization of the outputs for regression</span>
<a name="l00134"></a>00134 <span class="comment"> \param[in]     norm_out_2nd    : the normalization of the outputs for 2nd regression</span>
<a name="l00135"></a>00135 <span class="comment"> \param[in]     name            : a name for the model</span>
<a name="l00136"></a>00136 <span class="comment"> \param[in]     ID              : the id to be assigned to this LWPR model</span>
<a name="l00137"></a>00137 <span class="comment"> \param[in]     ini             : an LWPR structure to initialize the scalar values</span>
<a name="l00138"></a>00138 <span class="comment">                      (pass NULL for default initialization)</span>
<a name="l00139"></a>00139 <span class="comment"> </span>
<a name="l00140"></a>00140 <span class="comment"> ******************************************************************************/</span>
<a name="l00141"></a>00141 <span class="keywordtype">int</span> 
<a name="l00142"></a><a class="code" href="lwpr_8h.html#8237eacf87c2818130f870ca92fa219a">00142</a> <a class="code" href="lwpr_8c.html#8237eacf87c2818130f870ca92fa219a">initLWPR</a>(<span class="keywordtype">int</span>      n_in_w,
<a name="l00143"></a>00143          <span class="keywordtype">int</span>      n_in_reg,
<a name="l00144"></a>00144          <span class="keywordtype">int</span>      n_in_reg_2nd,
<a name="l00145"></a>00145          <span class="keywordtype">int</span>      n_out, 
<a name="l00146"></a>00146          <span class="keywordtype">int</span>      n_out_2nd, 
<a name="l00147"></a>00147          <span class="keywordtype">int</span>      diag_only, 
<a name="l00148"></a>00148          <span class="keywordtype">int</span>      meta, 
<a name="l00149"></a>00149          <span class="keywordtype">double</span>   meta_rate, 
<a name="l00150"></a>00150          <span class="keywordtype">double</span>   penalty, 
<a name="l00151"></a>00151          <span class="keywordtype">double</span>   init_alpha, 
<a name="l00152"></a>00152          Vector   norm_in_w,
<a name="l00153"></a>00153          Vector   norm_in_reg,
<a name="l00154"></a>00154          Vector   norm_in_reg_2nd,
<a name="l00155"></a>00155          Vector   norm_out,
<a name="l00156"></a>00156          Vector   norm_out_2nd,
<a name="l00157"></a>00157          <span class="keywordtype">char</span>    *name, 
<a name="l00158"></a>00158          <span class="keywordtype">int</span>      ID,
<a name="l00159"></a>00159          LWPR    *ini)
<a name="l00160"></a>00160      
<a name="l00161"></a>00161 {
<a name="l00162"></a>00162   <span class="keywordtype">int</span>     i,j;
<a name="l00163"></a>00163   <span class="keywordtype">int</span>     rc = TRUE;
<a name="l00164"></a>00164   <span class="keywordtype">double</span>  aux;
<a name="l00165"></a>00165   <span class="keywordtype">double</span> *temp;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (ID &gt; <a class="code" href="lwpr_8h.html#c378fe6d9192236b65019aec93d430d4">MAX_LWPRS</a> || ID &lt; 0) {
<a name="l00168"></a>00168     printf(<span class="stringliteral">"LWPR ID=%d must be in the range of %d until %d --  change ID\n"</span>,
<a name="l00169"></a>00169            ID,0,<a class="code" href="lwpr_8h.html#c378fe6d9192236b65019aec93d430d4">MAX_LWPRS</a>);
<a name="l00170"></a>00170     <span class="keywordflow">return</span> FALSE;
<a name="l00171"></a>00171   }
<a name="l00172"></a>00172   
<a name="l00173"></a>00173   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used) {
<a name="l00174"></a>00174     printf(<span class="stringliteral">"LWPR ID=%d is already used -- change ID\n"</span>,ID);
<a name="l00175"></a>00175     <span class="keywordflow">return</span> FALSE;
<a name="l00176"></a>00176   }
<a name="l00177"></a>00177   
<a name="l00178"></a>00178   <span class="keywordflow">if</span> (ini != NULL) {
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID] = *ini;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   } <span class="keywordflow">else</span> {
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <span class="comment">/* otherwise just assign the few variables to the appropriate structures */</span>
<a name="l00185"></a>00185     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg            = n_in_reg;
<a name="l00186"></a>00186     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd        = n_in_reg_2nd;
<a name="l00187"></a>00187     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w              = n_in_w;
<a name="l00188"></a>00188     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out               = n_out;
<a name="l00189"></a>00189     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd           = n_out_2nd;
<a name="l00190"></a>00190     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_data              = 0;
<a name="l00191"></a>00191     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_data_2nd          = 0;
<a name="l00192"></a>00192     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].w_gen               = <a class="code" href="lwpr_8h.html#a2ba6d756a7b513b4fc90e14a44117c4">DEF_W_GEN</a>;
<a name="l00193"></a>00193     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].w_prune             = DEF_W_PRUNE;
<a name="l00194"></a>00194     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].factor_prune        = DEF_FACTOR_PRUNE;
<a name="l00195"></a>00195     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf                = 0;
<a name="l00196"></a>00196     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf_allocated      = 0;
<a name="l00197"></a>00197     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used           = TRUE;
<a name="l00198"></a>00198     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets         = TRUE;
<a name="l00199"></a>00199     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets_2nd     = TRUE;
<a name="l00200"></a>00200     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].final_lambda        = DEF_FINAL_LAMBDA;
<a name="l00201"></a>00201     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].tau_lambda          = DEF_TAU_LAMBDA;
<a name="l00202"></a>00202     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_S2             = <a class="code" href="lwpr_8h.html#fbad64b06ae2064445bcbae190ca0b88">DEF_INIT_S2</a>;
<a name="l00203"></a>00203     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only           = diag_only;
<a name="l00204"></a>00204     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].penalty             = penalty;
<a name="l00205"></a>00205     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning = meta;
<a name="l00206"></a>00206     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].meta_learning_rate  = meta_rate;
<a name="l00207"></a>00207     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_pruned_overlap    = 0;
<a name="l00208"></a>00208     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_pruned_error      = 0;
<a name="l00209"></a>00209     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].add_threshold       = DEF_ADD_THRESHOLD;
<a name="l00210"></a>00210     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].max_rfs             = <a class="code" href="lwpr_8h.html#a907b387a19ba94b1312b7a62967527c">MAX_RFS</a>;
<a name="l00211"></a>00211     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].d_noise             = DEF_D_NOISE;
<a name="l00212"></a>00212     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].c_noise             = DEF_C_NOISE;
<a name="l00213"></a>00213     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_d_update      = TRUE;
<a name="l00214"></a>00214     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_addDim        = TRUE;
<a name="l00215"></a>00215     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_add_rfs       = TRUE;
<a name="l00216"></a>00216     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].write_rfs           = TRUE;
<a name="l00217"></a>00217     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_n_proj         = 0.0;
<a name="l00218"></a>00218     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_n_proj_2nd     = 0.0;
<a name="l00219"></a>00219     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].contrib_n_rf        = 0.0;
<a name="l00220"></a>00220     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_nn              = FALSE;
<a name="l00221"></a>00221     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].max_nn_comp         = 1000000000;
<a name="l00222"></a>00222     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function     = <a class="code" href="lwpr_8h.html#d751f1b6909c0124a4ca151036b28a0e">GAUSSIAN</a>;
<a name="l00223"></a>00223     strcpy(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_name,name);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     <span class="comment">// check whether second regression model should be initialized </span>
<a name="l00226"></a>00226     <span class="keywordflow">if</span> (n_in_reg_2nd == 0)
<a name="l00227"></a>00227 
<a name="l00228"></a>00228       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd = FALSE;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <span class="keywordflow">else</span> {
<a name="l00231"></a>00231 
<a name="l00232"></a>00232       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd = TRUE;
<a name="l00233"></a>00233       <span class="keywordflow">if</span> (n_in_reg_2nd &gt; DEF_DIM) {
<a name="l00234"></a>00234         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj_2nd = DEF_DIM + 1;
<a name="l00235"></a>00235       } <span class="keywordflow">else</span> {
<a name="l00236"></a>00236         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj_2nd = n_in_reg_2nd;
<a name="l00237"></a>00237       }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <span class="keywordflow">if</span> (n_in_reg &gt; DEF_DIM) {
<a name="l00242"></a>00242       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj = DEF_DIM + 1;
<a name="l00243"></a>00243     } <span class="keywordflow">else</span> {
<a name="l00244"></a>00244       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj = n_in_reg;
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246     
<a name="l00247"></a>00247     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_alpha       = init_alpha;
<a name="l00248"></a>00248  
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">// the matrices in this structure</span>
<a name="l00252"></a>00252   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D           = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00253"></a>00253   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M           = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00254"></a>00254   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_x_w         = my_vector(1,n_in_w);
<a name="l00255"></a>00255   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].var_x_w          = my_vector(1,n_in_w);
<a name="l00256"></a>00256   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_x_reg       = my_vector(1,n_in_reg);
<a name="l00257"></a>00257   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].var_x_reg        = my_vector(1,n_in_reg);
<a name="l00258"></a>00258   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_w        = my_vector(1,n_in_w);
<a name="l00259"></a>00259   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg      = my_vector(1,n_in_reg);
<a name="l00260"></a>00260   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_out         = my_vector(1,n_out);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00263"></a>00263     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg_2nd = my_vector(1,n_in_reg_2nd);
<a name="l00264"></a>00264     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_out_2nd    = my_vector(1,n_out_2nd);
<a name="l00265"></a>00265   }
<a name="l00266"></a>00266   
<a name="l00267"></a>00267   <span class="comment">/* some initialization */</span>
<a name="l00268"></a>00268   vec_zero(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_x_reg);
<a name="l00269"></a>00269   vec_zero(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].var_x_reg);
<a name="l00270"></a>00270   vec_zero(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_x_w);
<a name="l00271"></a>00271   vec_zero(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].var_x_w);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <span class="comment">/* the normalization factors */</span>
<a name="l00274"></a>00274   vec_equal(norm_in_w,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_w);
<a name="l00275"></a>00275   vec_equal(norm_in_reg,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg);
<a name="l00276"></a>00276   vec_equal(norm_out,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_out);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00279"></a>00279     vec_equal(norm_in_reg_2nd,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg_2nd);
<a name="l00280"></a>00280     vec_equal(norm_out_2nd,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_out_2nd);
<a name="l00281"></a>00281   }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="comment">/* the distance metric */</span>
<a name="l00284"></a>00284   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l00285"></a>00285     <span class="keywordflow">for</span> (j=i; j&lt;=n_in_w; ++j) {
<a name="l00286"></a>00286       <span class="keywordflow">if</span> (i==j) {
<a name="l00287"></a>00287         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] = DEF_DIAG_D;
<a name="l00288"></a>00288       } <span class="keywordflow">else</span> {
<a name="l00289"></a>00289         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] = DEF_OFFDIAG_D;
<a name="l00290"></a>00290         <span class="keywordflow">if</span> (diag_only) 
<a name="l00291"></a>00291           <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] = 0.0;
<a name="l00292"></a>00292       }
<a name="l00293"></a>00293       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[j][i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j];
<a name="l00294"></a>00294       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[j][i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j];
<a name="l00295"></a>00295       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j];
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="comment">/* get the init_M by cholesky decomposition */</span>
<a name="l00300"></a>00300   temp = my_vector(1,n_in_w);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   <span class="keywordflow">if</span> (!my_choldc(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M,n_in_w,temp)) {
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     printf(<span class="stringliteral">"ERROR: Matrix is not positive definite\n"</span>);
<a name="l00305"></a>00305     <span class="keywordflow">return</span> FALSE;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   } <span class="keywordflow">else</span> {
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     <span class="comment">/* since choldc returns the M matrix as lower triangular matrix</span>
<a name="l00310"></a>00310 <span class="comment">       in init_M, and the diagonal elements in temp, I have</span>
<a name="l00311"></a>00311 <span class="comment">       to fix this nonsense */</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l00314"></a>00314       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_w; ++j) {
<a name="l00315"></a>00315         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[j][i];
<a name="l00316"></a>00316         <span class="keywordflow">if</span> (i==j) {
<a name="l00317"></a>00317           <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = temp[i];
<a name="l00318"></a>00318         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i&gt;j) {
<a name="l00319"></a>00319           <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = 0.0;
<a name="l00320"></a>00320         }
<a name="l00321"></a>00321       }
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   my_free_vector(temp,1,n_in_w);
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="comment">/* init the exp table by doing one lookup */</span>
<a name="l00329"></a>00329   aux = myExp(-.01,USE_EXP_LOOKUP);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <span class="comment">/* allocate working memory for this LWPR */</span>
<a name="l00332"></a>00332   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x                = my_vector(1,n_in_reg);
<a name="l00333"></a>00333   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_w              = my_vector(1,n_in_w);
<a name="l00334"></a>00334   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y                = my_vector(1,n_out);
<a name="l00335"></a>00335   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xp               = my_vector(1,n_in_reg);
<a name="l00336"></a>00336   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xp_w             = my_vector(1,n_in_w);
<a name="l00337"></a>00337   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mz             = my_vector(1,n_in_reg);
<a name="l00338"></a>00338   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mzp            = my_vector(1,n_in_reg);
<a name="l00339"></a>00339   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_mz             = my_vector(1,n_out);
<a name="l00340"></a>00340   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].delta            = my_vector(1,n_in_w);
<a name="l00341"></a>00341   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].delta2           = my_vector(1,n_in_w);
<a name="l00342"></a>00342   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xres             = my_vector(1,n_in_reg);
<a name="l00343"></a>00343   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].yres             = my_vector(1,n_out);
<a name="l00344"></a>00344   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].ypred            = my_vector(1,n_out);
<a name="l00345"></a>00345   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].cr               = my_vector(1,n_in_reg);
<a name="l00346"></a>00346   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp           = my_vector(1,n_in_reg);
<a name="l00347"></a>00347   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp_w         = my_vector(1,n_in_w);
<a name="l00348"></a>00348   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_tempp          = my_vector(1,n_in_reg);
<a name="l00349"></a>00349   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].D_temp           = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00350"></a>00350   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv         = my_matrix(1,n_in_reg,1,n_out);
<a name="l00351"></a>00351   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error            = my_matrix(1,n_in_reg,1,n_out);
<a name="l00352"></a>00352   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dwdM             = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00353"></a>00353   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dpdM             = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00354"></a>00354   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dwwdMdM          = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00355"></a>00355   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dppdMdM          = my_matrix(1,n_in_w,1,n_in_w);
<a name="l00356"></a>00356   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted  = my_vector(1,n_out);
<a name="l00357"></a>00357   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].derivatives_ok   = my_ivector(1,n_in_reg);
<a name="l00358"></a>00358   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_mean_predicted = my_vector(1,n_out);
<a name="l00359"></a>00359   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted2 = my_vector(1,n_out);
<a name="l00360"></a>00360   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_conf       = my_vector(1,n_out);
<a name="l00361"></a>00361   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted      = my_vector(1,n_out);
<a name="l00362"></a>00362   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted2     = my_vector(1,n_out);
<a name="l00363"></a>00363   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_conf           = my_vector(1,n_out);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00366"></a>00366     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted_2nd  = my_vector(1,n_out_2nd);
<a name="l00367"></a>00367     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_conf_2nd       = my_vector(1,n_out_2nd);
<a name="l00368"></a>00368     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_2nd                = my_vector(1,n_in_reg_2nd);
<a name="l00369"></a>00369     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_2nd                = my_vector(1,n_out_2nd);
<a name="l00370"></a>00370     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted2_2nd = my_vector(1,n_out_2nd);
<a name="l00371"></a>00371     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_mz_2nd             = my_vector(1,n_out_2nd);
<a name="l00372"></a>00372     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mz_2nd             = my_vector(1,n_in_reg_2nd);
<a name="l00373"></a>00373     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mzp_2nd            = my_vector(1,n_in_reg_2nd);
<a name="l00374"></a>00374     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].ypred_2nd            = my_vector(1,n_out_2nd);
<a name="l00375"></a>00375     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp_2nd           = my_vector(1,n_in_reg_2nd);
<a name="l00376"></a>00376     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_tempp_2nd          = my_vector(1,n_in_reg_2nd);
<a name="l00377"></a>00377     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xres_2nd             = my_vector(1,n_in_reg_2nd);
<a name="l00378"></a>00378     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv_2nd         = my_matrix(1,n_in_reg_2nd,1,n_out_2nd);
<a name="l00379"></a>00379     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].yres_2nd             = my_vector(1,n_out_2nd);
<a name="l00380"></a>00380     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].cr_2nd               = my_vector(1,n_in_reg_2nd);
<a name="l00381"></a>00381     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_2nd            = my_matrix(1,n_in_reg_2nd,1,n_out_2nd);
<a name="l00382"></a>00382     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xp_2nd               = my_vector(1,n_in_reg_2nd);
<a name="l00383"></a>00383     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_conf_2nd           = my_vector(1,n_out_2nd);
<a name="l00384"></a>00384     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted_2nd      = my_vector(1,n_out_2nd);
<a name="l00385"></a>00385     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted2_2nd     = my_vector(1,n_out_2nd);
<a name="l00386"></a>00386   }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">/* zero some matrices */</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   <span class="keywordflow">return</span> rc;
<a name="l00391"></a>00391   
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="comment">/*!*****************************************************************************</span>
<a name="l00395"></a>00395 <span class="comment"> *******************************************************************************</span>
<a name="l00396"></a>00396 <span class="comment"> \note  deleteLWPR</span>
<a name="l00397"></a>00397 <span class="comment"> \date  November, 1994</span>
<a name="l00398"></a>00398 <span class="comment"> </span>
<a name="l00399"></a>00399 <span class="comment"> \remarks </span>
<a name="l00400"></a>00400 <span class="comment"> </span>
<a name="l00401"></a>00401 <span class="comment"> erases a LWPR from memory</span>
<a name="l00402"></a>00402 <span class="comment"> </span>
<a name="l00403"></a>00403 <span class="comment"> *******************************************************************************</span>
<a name="l00404"></a>00404 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l00405"></a>00405 <span class="comment"> </span>
<a name="l00406"></a>00406 <span class="comment"> \param[in]     ID        : ID of lwpr</span>
<a name="l00407"></a>00407 <span class="comment"></span>
<a name="l00408"></a>00408 <span class="comment"> ******************************************************************************/</span>
<a name="l00409"></a>00409 <span class="keywordtype">int</span>
<a name="l00410"></a><a class="code" href="lwpr_8h.html#dfec35a9647725adc85265ec00c6700a">00410</a> <a class="code" href="lwpr_8c.html#dfec35a9647725adc85265ec00c6700a">deleteLWPR</a>(<span class="keywordtype">int</span> ID)
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 {
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <span class="keywordtype">int</span> i;
<a name="l00415"></a>00415   <span class="keywordtype">int</span> n_in_w,n_in_reg,n_out,n_out_2nd,n_in_reg_2nd;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">if</span> (!<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used) {
<a name="l00418"></a>00418     printf(<span class="stringliteral">"No #LWPR=%d existent!\n"</span>,ID);
<a name="l00419"></a>00419     <span class="keywordflow">return</span> FALSE;
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   n_in_reg      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l00423"></a>00423   n_in_reg_2nd  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l00424"></a>00424   n_in_w        = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l00425"></a>00425   n_out         = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l00426"></a>00426   n_out_2nd     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   <span class="comment">/* delete all rfs */</span>
<a name="l00429"></a>00429   <span class="keywordflow">while</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf &gt; 0)
<a name="l00430"></a>00430     <a class="code" href="lwpr_8c.html#1a9c86129044ef0a65a68684926c456a">deleteRF</a>(ID,1);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="comment">/* free LWPR memory */</span>
<a name="l00433"></a>00433   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf_allocated &gt; 0)
<a name="l00434"></a>00434     free(&amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[1]);
<a name="l00435"></a>00435   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D,1,n_in_w,1,n_in_w);
<a name="l00436"></a>00436   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M,1,n_in_w,1,n_in_w);
<a name="l00437"></a>00437   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_x_reg,1,n_in_reg);
<a name="l00438"></a>00438   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].var_x_reg,1,n_in_reg);
<a name="l00439"></a>00439   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_x_w,1,n_in_w);
<a name="l00440"></a>00440   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].var_x_w,1,n_in_w);
<a name="l00441"></a>00441   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_w,1,n_in_w);
<a name="l00442"></a>00442   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg,1,n_in_reg);
<a name="l00443"></a>00443   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_out,1,n_out);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x,1,n_in_reg);
<a name="l00446"></a>00446   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_w,1,n_in_w);
<a name="l00447"></a>00447   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xp,1,n_in_reg);
<a name="l00448"></a>00448   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xp_w,1,n_in_w);
<a name="l00449"></a>00449   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mz,1,n_in_reg);
<a name="l00450"></a>00450   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mzp,1,n_in_reg);
<a name="l00451"></a>00451   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_mz,1,n_out);
<a name="l00452"></a>00452   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].delta,1,n_in_w);
<a name="l00453"></a>00453   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].delta2,1,n_in_w);
<a name="l00454"></a>00454   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xres,1,n_in_reg);
<a name="l00455"></a>00455   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].yres,1,n_out);
<a name="l00456"></a>00456   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].ypred,1,n_out);
<a name="l00457"></a>00457   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].cr,1,n_in_reg);
<a name="l00458"></a>00458   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp,1,n_in_reg);
<a name="l00459"></a>00459   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp_w,1,n_in_w);
<a name="l00460"></a>00460   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_tempp,1,n_in_reg);
<a name="l00461"></a>00461   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].D_temp,1,n_in_w,1,n_in_w);
<a name="l00462"></a>00462   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv,1,n_in_reg,1,n_out);
<a name="l00463"></a>00463   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error,1,n_in_reg,1,n_out);
<a name="l00464"></a>00464   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dwdM,1,n_in_w,1,n_in_w);
<a name="l00465"></a>00465   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dpdM,1,n_in_w,1,n_in_w);
<a name="l00466"></a>00466   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dwwdMdM,1,n_in_w,1,n_in_w);
<a name="l00467"></a>00467   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dppdMdM,1,n_in_w,1,n_in_w);
<a name="l00468"></a>00468   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted,1,n_out);
<a name="l00469"></a>00469   my_free_ivector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].derivatives_ok,1,n_in_reg);
<a name="l00470"></a>00470   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_mean_predicted,1,n_out);
<a name="l00471"></a>00471   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted2,1,n_out);
<a name="l00472"></a>00472   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_conf,1,n_out);
<a name="l00473"></a>00473   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted,1,n_out);
<a name="l00474"></a>00474   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted2,1,n_out);
<a name="l00475"></a>00475   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_conf,1,n_out);
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00478"></a>00478      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg_2nd,1,n_in_reg_2nd);
<a name="l00479"></a>00479      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_out_2nd,1,n_out_2nd);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted_2nd,1,n_out_2nd);
<a name="l00482"></a>00482      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_conf_2nd,1,n_out_2nd);
<a name="l00483"></a>00483      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_2nd,1,n_in_reg_2nd);
<a name="l00484"></a>00484      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_2nd,1,n_out_2nd);
<a name="l00485"></a>00485      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted2_2nd,1,n_out_2nd);
<a name="l00486"></a>00486      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_mz_2nd,1,n_out_2nd);
<a name="l00487"></a>00487      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mz_2nd,1,n_in_reg_2nd);
<a name="l00488"></a>00488      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_mzp_2nd,1,n_in_reg_2nd);
<a name="l00489"></a>00489      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].ypred_2nd,1,n_out_2nd);
<a name="l00490"></a>00490      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp_2nd,1,n_in_reg_2nd);
<a name="l00491"></a>00491      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_tempp_2nd,1,n_in_reg_2nd);
<a name="l00492"></a>00492      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xres_2nd,1,n_in_reg_2nd);
<a name="l00493"></a>00493      my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv_2nd,1,n_in_reg_2nd,1,n_out_2nd);
<a name="l00494"></a>00494      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].yres_2nd,1,n_out_2nd);
<a name="l00495"></a>00495      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].cr_2nd,1,n_in_reg_2nd);
<a name="l00496"></a>00496      my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_2nd,1,n_in_reg_2nd,1,n_out_2nd);
<a name="l00497"></a>00497      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xp_2nd,1,n_in_reg_2nd);
<a name="l00498"></a>00498      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_conf_2nd,1,n_out_2nd);
<a name="l00499"></a>00499      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted_2nd,1,n_out_2nd);
<a name="l00500"></a>00500      my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_predicted2_2nd,1,n_out_2nd);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used = FALSE;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keywordflow">return</span> TRUE;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="comment">/*!*****************************************************************************</span>
<a name="l00511"></a>00511 <span class="comment"> *******************************************************************************</span>
<a name="l00512"></a>00512 <span class="comment"> \note  addRF </span>
<a name="l00513"></a>00513 <span class="comment"> \date  January, 1994</span>
<a name="l00514"></a>00514 <span class="comment"> </span>
<a name="l00515"></a>00515 <span class="comment"> \remarks </span>
<a name="l00516"></a>00516 <span class="comment"> </span>
<a name="l00517"></a>00517 <span class="comment"> adds a receptive field to the given LWPR and returns the receptive field ID.</span>
<a name="l00518"></a>00518 <span class="comment"> </span>
<a name="l00519"></a>00519 <span class="comment"> *******************************************************************************</span>
<a name="l00520"></a>00520 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l00521"></a>00521 <span class="comment"> </span>
<a name="l00522"></a>00522 <span class="comment"> \param[in]     ID         : the ID of the LWPR</span>
<a name="l00523"></a>00523 <span class="comment"> \param[in]     n_proj     : the number of projections of the regression model</span>
<a name="l00524"></a>00524 <span class="comment"> \param[in]     n_proj_2nd : the number of projections of the 2nd regression model</span>
<a name="l00525"></a>00525 <span class="comment"> \param[in]     n_nn       : the number of nearest neighbors to be allocated</span>
<a name="l00526"></a>00526 <span class="comment"> </span>
<a name="l00527"></a>00527 <span class="comment"> ******************************************************************************/</span>
<a name="l00528"></a><a class="code" href="lwpr_8c.html#dbac8ec16702def0e3ed734c0e4f40ff">00528</a> <span class="preprocessor">#define RF_CHUNK 50  </span>
<a name="l00529"></a>00529 <span class="preprocessor">static int </span>
<a name="l00530"></a>00530 <span class="preprocessor"></span>addRF(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> n_proj, <span class="keywordtype">int</span> n_proj_2nd, <span class="keywordtype">int</span> n_nn)
<a name="l00531"></a>00531      
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   <span class="keywordtype">int</span>      i,j,k;
<a name="l00535"></a>00535   <span class="keywordtype">size_t</span>   number,length;
<a name="l00536"></a>00536   RF      *nptr;
<a name="l00537"></a>00537   RF      *optr;
<a name="l00538"></a>00538   <span class="keywordtype">int</span>      rfID;
<a name="l00539"></a>00539   <span class="keywordtype">int</span>      n_in_reg,n_in_w,n_out;
<a name="l00540"></a>00540   
<a name="l00541"></a>00541   n_in_reg      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l00542"></a>00542   n_in_w        = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l00543"></a>00543   n_out         = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf_allocated &lt;= <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf) {
<a name="l00546"></a>00546   
<a name="l00547"></a>00547     <span class="comment">// this means the vector for the rf must be increased</span>
<a name="l00548"></a>00548     length = <span class="keyword">sizeof</span>(RF);
<a name="l00549"></a>00549     number = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf_allocated + <a class="code" href="lwpr_8c.html#dbac8ec16702def0e3ed734c0e4f40ff">RF_CHUNK</a>;
<a name="l00550"></a>00550     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf_allocated == 0) {
<a name="l00551"></a>00551       nptr   = (RF *) calloc(number,length);
<a name="l00552"></a>00552     } <span class="keywordflow">else</span> {
<a name="l00553"></a>00553       optr   = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs + 1;
<a name="l00554"></a>00554       nptr   = (RF *) realloc(optr,length*number);
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556     <span class="keywordflow">if</span> (nptr == NULL) {
<a name="l00557"></a>00557       printf(<span class="stringliteral">"Memory Alloc. Error in &gt;add_rf&lt; -- increase available memory\n"</span>);
<a name="l00558"></a>00558       getchar();
<a name="l00559"></a>00559       <span class="keywordflow">return</span> FALSE;
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561     
<a name="l00562"></a>00562     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf_allocated += <a class="code" href="lwpr_8c.html#dbac8ec16702def0e3ed734c0e4f40ff">RF_CHUNK</a>;
<a name="l00563"></a>00563     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs = nptr-1;
<a name="l00564"></a>00564   
<a name="l00565"></a>00565   }
<a name="l00566"></a>00566   
<a name="l00567"></a>00567   <span class="comment">/* allocate the memory for the rf */</span>
<a name="l00568"></a>00568   rfID = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf + 1;
<a name="l00569"></a>00569   
<a name="l00570"></a>00570   <span class="comment">/* note that some matrices are allocated as symmetric matrices to save </span>
<a name="l00571"></a>00571 <span class="comment">     memory */</span>
<a name="l00572"></a>00572   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].B  = my_matrix(1,n_proj,1,n_out);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only) {
<a name="l00575"></a>00575     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].D = my_matrix_diag(1,n_in_w,1,n_in_w);
<a name="l00576"></a>00576     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].M = my_matrix_diag(1,n_in_w,1,n_in_w);
<a name="l00577"></a>00577     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].alpha = my_matrix_diag(1,n_in_w,1,n_in_w);
<a name="l00578"></a>00578   } <span class="keywordflow">else</span> {
<a name="l00579"></a>00579     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].D = my_matrix_symm(1,n_in_w,1,n_in_w);
<a name="l00580"></a>00580     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].M = my_matrix_symm(1,n_in_w,1,n_in_w);
<a name="l00581"></a>00581     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].alpha = my_matrix_symm(1,n_in_w,1,n_in_w);
<a name="l00582"></a>00582   }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l00585"></a>00585     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only) {
<a name="l00586"></a>00586       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].h = my_matrix_diag(1,n_in_w,1,n_in_w);
<a name="l00587"></a>00587       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].b = my_matrix_diag(1,n_in_w,1,n_in_w);
<a name="l00588"></a>00588     } <span class="keywordflow">else</span> {
<a name="l00589"></a>00589       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].h = my_matrix_symm(1,n_in_w,1,n_in_w);
<a name="l00590"></a>00590       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].b = my_matrix_symm(1,n_in_w,1,n_in_w);
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592   }
<a name="l00593"></a>00593   
<a name="l00594"></a>00594   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].c   = my_vector(1,n_in_w);
<a name="l00595"></a>00595   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].s   = my_vector(1,n_proj);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SXresYres = my_matrix(1,n_proj,1,n_in_reg);
<a name="l00598"></a>00598   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].ss2 = my_vector(1,n_proj);
<a name="l00599"></a>00599   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].dof = my_vector(1,n_proj);
<a name="l00600"></a>00600   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSYres = my_matrix(1,n_proj,1,n_out);
<a name="l00601"></a>00601   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSXres = my_matrix(1,n_proj,1,n_in_reg);
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <span class="comment">/* the matrix of projection vectors  */</span>
<a name="l00604"></a>00604   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].W     = my_matrix(1,n_proj,1,n_in_reg);
<a name="l00605"></a>00605   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].Wnorm = my_vector(1,n_proj);
<a name="l00606"></a>00606   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].U     = my_matrix(1,n_proj,1,n_in_reg);
<a name="l00607"></a>00607   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].H     = my_matrix(1,n_proj,1,n_out);
<a name="l00608"></a>00608   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].r     = my_vector(1,n_proj);
<a name="l00609"></a>00609   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].T     = my_matrix(1,n_proj,1,n_in_reg);
<a name="l00610"></a>00610   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].A     = my_matrix(1,n_proj,1,n_in_reg);
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="comment">/* mean and variance info */</span>
<a name="l00613"></a>00613   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_x_w   = my_vector(1,n_in_w);
<a name="l00614"></a>00614   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_x_w    = my_vector(1,n_in_w);
<a name="l00615"></a>00615   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_x_reg = my_vector(1,n_in_reg);
<a name="l00616"></a>00616   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_x_reg  = my_vector(1,n_in_reg);
<a name="l00617"></a>00617   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_y     = my_vector(1,n_out);
<a name="l00618"></a>00618   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_y      = my_vector(1,n_out);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="comment">/* the sum of weights for every regression dimension */</span>
<a name="l00621"></a>00621   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights   = my_vector(1,n_proj);
<a name="l00622"></a>00622   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error     = my_vector(1,n_proj);
<a name="l00623"></a>00623   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi = my_vector(1,n_proj);
<a name="l00624"></a>00624   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data        = my_vector(1,n_proj);
<a name="l00625"></a>00625   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].lambda        = my_vector(1,n_proj);
<a name="l00626"></a>00626   
<a name="l00627"></a>00627   <span class="comment">/* the nearest neigbor structure */</span>
<a name="l00628"></a>00628   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn_allocated = n_nn;
<a name="l00629"></a>00629   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nn  = my_ivector(1,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn_allocated);
<a name="l00630"></a>00630   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nnw = my_vector(1,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn_allocated);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   <span class="comment">/* assign what is known now */</span>
<a name="l00633"></a>00633   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj     = n_proj;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00636"></a>00636     <span class="keywordtype">int</span> n_in_reg_2nd;
<a name="l00637"></a>00637     <span class="keywordtype">int</span> n_out_2nd;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     n_in_reg_2nd = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l00640"></a>00640     n_out_2nd    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd;
<a name="l00641"></a>00641     
<a name="l00642"></a>00642     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].B_2nd  = my_matrix(1,n_proj_2nd,1,n_out_2nd);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].s_2nd   = my_vector(1,n_proj_2nd);
<a name="l00645"></a>00645     
<a name="l00646"></a>00646     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SXresYres_2nd = my_matrix(1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00647"></a>00647     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].ss2_2nd       = my_vector(1,n_proj_2nd);
<a name="l00648"></a>00648     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSYres_2nd    = my_matrix(1,n_proj_2nd,1,n_out_2nd);
<a name="l00649"></a>00649     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSXres_2nd    = my_matrix(1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00650"></a>00650     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].dof_2nd       = my_vector(1,n_proj_2nd);
<a name="l00651"></a>00651     
<a name="l00652"></a>00652     <span class="comment">/* the matrix of projection vectors  */</span>
<a name="l00653"></a>00653     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].W_2nd     = my_matrix(1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00654"></a>00654     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].Wnorm_2nd = my_vector(1,n_proj_2nd);
<a name="l00655"></a>00655     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].U_2nd     = my_matrix(1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00656"></a>00656     
<a name="l00657"></a>00657     <span class="comment">/* mean and variance info */</span>
<a name="l00658"></a>00658     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_x_reg_2nd = my_vector(1,n_in_reg_2nd);
<a name="l00659"></a>00659     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_x_reg_2nd  = my_vector(1,n_in_reg_2nd);
<a name="l00660"></a>00660     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_y_2nd     = my_vector(1,n_out_2nd);
<a name="l00661"></a>00661     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_y_2nd      = my_vector(1,n_out_2nd);
<a name="l00662"></a>00662     
<a name="l00663"></a>00663     <span class="comment">/* the sum of weights for every regression dimension */</span>
<a name="l00664"></a>00664     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights_2nd   = my_vector(1,n_proj_2nd);
<a name="l00665"></a>00665     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_2nd     = my_vector(1,n_proj_2nd);
<a name="l00666"></a>00666     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi_2nd = my_vector(1,n_proj_2nd);
<a name="l00667"></a>00667     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data_2nd        = my_vector(1,n_proj_2nd);
<a name="l00668"></a>00668     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].lambda_2nd        = my_vector(1,n_proj_2nd);
<a name="l00669"></a>00669     
<a name="l00670"></a>00670     <span class="comment">/* assign what is known now */</span>
<a name="l00671"></a>00671     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj_2nd     = n_proj_2nd;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   ++<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="keywordflow">return</span> rfID;
<a name="l00678"></a>00678                 
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 <span class="comment">/*!*****************************************************************************</span>
<a name="l00681"></a>00681 <span class="comment"> *******************************************************************************</span>
<a name="l00682"></a>00682 <span class="comment"> \note  deleteRF</span>
<a name="l00683"></a>00683 <span class="comment"> \date  January, 1994</span>
<a name="l00684"></a>00684 <span class="comment"> </span>
<a name="l00685"></a>00685 <span class="comment"> \remarks </span>
<a name="l00686"></a>00686 <span class="comment"> </span>
<a name="l00687"></a>00687 <span class="comment"> deletes a receptive field from the given LWPR and receptive field ID.</span>
<a name="l00688"></a>00688 <span class="comment"> </span>
<a name="l00689"></a>00689 <span class="comment"> *******************************************************************************</span>
<a name="l00690"></a>00690 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l00691"></a>00691 <span class="comment"> </span>
<a name="l00692"></a>00692 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l00693"></a>00693 <span class="comment"> \param[in]     rfID   : the ID of the rf</span>
<a name="l00694"></a>00694 <span class="comment"> </span>
<a name="l00695"></a>00695 <span class="comment"> ******************************************************************************/</span>
<a name="l00696"></a>00696 <span class="keywordtype">int</span> 
<a name="l00697"></a><a class="code" href="lwpr_8h.html#1a9c86129044ef0a65a68684926c456a">00697</a> <a class="code" href="lwpr_8c.html#1a9c86129044ef0a65a68684926c456a">deleteRF</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l00698"></a>00698      
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="keywordtype">int</span> i,j,k;
<a name="l00702"></a>00702   <span class="keywordtype">int</span> n_in_w,n_in_reg,n_proj,n_out;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704   
<a name="l00705"></a>00705   n_in_w     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l00706"></a>00706   n_in_reg   = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l00707"></a>00707   n_out      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l00708"></a>00708   n_proj     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <span class="comment">/* erase this rfID from all nearest neighbor structures */</span>
<a name="l00711"></a>00711   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf; ++i) {
<a name="l00712"></a>00712     deleteNNFromRF(ID,i,rfID);
<a name="l00713"></a>00713   }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="comment">/* deallocate the memory for the rf */</span>
<a name="l00716"></a>00716   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].B,1,n_proj,1,n_out);
<a name="l00717"></a>00717   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].D,1,n_in_w,1,n_in_w);
<a name="l00718"></a>00718   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].M,1,n_in_w,1,n_in_w);
<a name="l00719"></a>00719   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].alpha,1,n_in_w,1,n_in_w);
<a name="l00720"></a>00720   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l00721"></a>00721     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].h,1,n_in_w,1,n_in_w);
<a name="l00722"></a>00722     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].b,1,n_in_w,1,n_in_w);
<a name="l00723"></a>00723   }
<a name="l00724"></a>00724   
<a name="l00725"></a>00725   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].c,1,n_in_w);
<a name="l00726"></a>00726   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].s,1,n_proj);
<a name="l00727"></a>00727   
<a name="l00728"></a>00728   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SXresYres,1,n_proj,1,n_in_reg);
<a name="l00729"></a>00729   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].ss2,1,n_proj);
<a name="l00730"></a>00730   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].dof,1,n_proj);
<a name="l00731"></a>00731   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSYres,1,n_proj,1,n_out);
<a name="l00732"></a>00732   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSXres,1,n_proj,1,n_in_reg);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734   <span class="comment">/* the matrix of projection vectors  */</span>
<a name="l00735"></a>00735   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].W,1,n_proj,1,n_in_reg);
<a name="l00736"></a>00736   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].Wnorm,1,n_proj);
<a name="l00737"></a>00737   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].U,1,n_proj,1,n_in_reg);
<a name="l00738"></a>00738   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].H,1,n_proj,1,n_out);
<a name="l00739"></a>00739   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].r,1,n_proj);
<a name="l00740"></a>00740   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].T,1,n_proj,1,n_in_reg);
<a name="l00741"></a>00741   my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].A,1,n_proj,1,n_in_reg);
<a name="l00742"></a>00742   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].lambda,1,n_proj);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   <span class="comment">/* mean and variance info */</span>
<a name="l00745"></a>00745   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_x_w,1,n_in_w);
<a name="l00746"></a>00746   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_x_w,1,n_in_w);
<a name="l00747"></a>00747   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_x_reg,1,n_in_reg);
<a name="l00748"></a>00748   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_x_reg,1,n_in_reg);
<a name="l00749"></a>00749   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_y,1,n_out);
<a name="l00750"></a>00750   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_y,1,n_out);
<a name="l00751"></a>00751   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights,1,n_proj);
<a name="l00752"></a>00752   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error,1,n_proj);
<a name="l00753"></a>00753   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi,1,n_proj);
<a name="l00754"></a>00754   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data,1,n_proj);
<a name="l00755"></a>00755 
<a name="l00756"></a>00756   <span class="comment">/* the nearest neighbors */</span>
<a name="l00757"></a>00757   my_free_ivector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nn,1,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn_allocated);
<a name="l00758"></a>00758   my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nnw,1,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn_allocated);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   <span class="comment">/* variable for the 2nd regression model */</span>
<a name="l00761"></a>00761   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00762"></a>00762     <span class="keywordtype">int</span> n_proj_2nd;
<a name="l00763"></a>00763     <span class="keywordtype">int</span> n_in_reg_2nd;
<a name="l00764"></a>00764     <span class="keywordtype">int</span> n_out_2nd;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766     n_in_reg_2nd = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l00767"></a>00767     n_proj_2nd    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj_2nd;
<a name="l00768"></a>00768     n_out_2nd    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd;
<a name="l00769"></a>00769     
<a name="l00770"></a>00770     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].B_2nd,1,n_proj_2nd,1,n_out_2nd);
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].s_2nd,1,n_proj_2nd);
<a name="l00773"></a>00773     
<a name="l00774"></a>00774     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SXresYres_2nd,1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00775"></a>00775     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].ss2_2nd,1,n_proj_2nd);
<a name="l00776"></a>00776     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSYres_2nd,1,n_proj_2nd,1,n_out_2nd);
<a name="l00777"></a>00777     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].SSXres_2nd,1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00778"></a>00778     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].dof_2nd,1,n_proj_2nd);
<a name="l00779"></a>00779     
<a name="l00780"></a>00780     <span class="comment">/* the matrix of projection vectors  */</span>
<a name="l00781"></a>00781     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].W_2nd,1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00782"></a>00782     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].Wnorm_2nd,1,n_proj_2nd);
<a name="l00783"></a>00783     my_free_matrix(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].U_2nd,1,n_proj_2nd,1,n_in_reg_2nd);
<a name="l00784"></a>00784     
<a name="l00785"></a>00785     <span class="comment">/* mean and variance info */</span>
<a name="l00786"></a>00786     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_x_reg_2nd,1,n_in_reg_2nd);
<a name="l00787"></a>00787     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_x_reg_2nd,1,n_in_reg_2nd);
<a name="l00788"></a>00788     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].mean_y_2nd,1,n_out_2nd);
<a name="l00789"></a>00789     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].var_y_2nd,1,n_out_2nd);
<a name="l00790"></a>00790     
<a name="l00791"></a>00791     <span class="comment">/* the sum of weights for every regression dimension */</span>
<a name="l00792"></a>00792     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights_2nd,1,n_proj_2nd);
<a name="l00793"></a>00793     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_2nd,1,n_proj_2nd);
<a name="l00794"></a>00794     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi_2nd,1,n_proj_2nd);
<a name="l00795"></a>00795     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data_2nd,1,n_proj_2nd);
<a name="l00796"></a>00796     my_free_vector(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].lambda_2nd,1,n_proj_2nd);
<a name="l00797"></a>00797     
<a name="l00798"></a>00798   }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 
<a name="l00802"></a>00802   <span class="comment">/* copy the last rf to the to be deleted one thus that the last rf in the</span>
<a name="l00803"></a>00803 <span class="comment">     row can be freed */</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805   <span class="keywordflow">if</span> (rfID != <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf) {
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="comment">/* swap in the last RF in the array */</span>
<a name="l00808"></a>00808     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf];
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <span class="comment">/* fix the first NN elements to reflect the change of rfID */</span>
<a name="l00811"></a>00811     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nn[1] = rfID;
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="comment">/* make sure the check counter is not too high */</span>
<a name="l00814"></a>00814     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].next_nn_check &gt;= rfID)
<a name="l00815"></a>00815       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].next_nn_check = rfID - 1;
<a name="l00816"></a>00816   }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818   <span class="comment">/* fix the new ID of the moved RF */</span>
<a name="l00819"></a>00819   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf-1; ++i) {
<a name="l00820"></a>00820     swapNNID(ID,i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf,rfID);
<a name="l00821"></a>00821   }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   --<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf;  <span class="comment">/* this must come last to avoid screwing up the swap */</span>
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 
<a name="l00826"></a>00826   <span class="keywordflow">return</span> TRUE;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 <span class="comment">/*!*****************************************************************************</span>
<a name="l00832"></a>00832 <span class="comment"> *******************************************************************************</span>
<a name="l00833"></a>00833 <span class="comment"> \note  initRF</span>
<a name="l00834"></a>00834 <span class="comment"> \date  January, 1994</span>
<a name="l00835"></a>00835 <span class="comment"> </span>
<a name="l00836"></a>00836 <span class="comment"> \remarks </span>
<a name="l00837"></a>00837 <span class="comment"> </span>
<a name="l00838"></a>00838 <span class="comment"> Initializes a receptive field with a given ID number.</span>
<a name="l00839"></a>00839 <span class="comment"> </span>
<a name="l00840"></a>00840 <span class="comment"> *******************************************************************************</span>
<a name="l00841"></a>00841 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l00842"></a>00842 <span class="comment"> </span>
<a name="l00843"></a>00843 <span class="comment"> \param[in]     ID         : the ID of the LWPR</span>
<a name="l00844"></a>00844 <span class="comment"> \param[in]     rfID       : the ID of the receptive field</span>
<a name="l00845"></a>00845 <span class="comment"> \param[in]     c          : the center of the receptive field</span>
<a name="l00846"></a>00846 <span class="comment"> \param[in]     M          : the decomposed distance metric for the receptive field</span>
<a name="l00847"></a>00847 <span class="comment"> </span>
<a name="l00848"></a>00848 <span class="comment"> ******************************************************************************/</span>
<a name="l00849"></a>00849 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00850"></a>00850 initRF(<span class="keywordtype">int</span>      ID, 
<a name="l00851"></a>00851        <span class="keywordtype">int</span>      rfID, 
<a name="l00852"></a>00852        Vector   c, 
<a name="l00853"></a>00853        Matrix   M)
<a name="l00854"></a>00854      
<a name="l00855"></a>00855 {
<a name="l00856"></a>00856   <span class="keywordtype">int</span>      i,j,k;
<a name="l00857"></a>00857   <span class="keywordtype">double</span>   aux;
<a name="l00858"></a>00858   <span class="keywordtype">int</span>      n_proj, n_in_w, n_in_reg, n_out;
<a name="l00859"></a>00859   LWPR     *s;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l00862"></a>00862   n_in_reg  = s-&gt;n_in_reg;
<a name="l00863"></a>00863   n_in_w    = s-&gt;n_in_w;
<a name="l00864"></a>00864   n_out     = s-&gt;n_out;
<a name="l00865"></a>00865   n_proj    = s-&gt;rfs[rfID].n_proj;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   mat_zero(s-&gt;rfs[rfID].B);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="comment">/* note that some matrices are allocated as symmetric matrices to save </span>
<a name="l00870"></a>00870 <span class="comment">     memory */</span>
<a name="l00871"></a>00871   vec_equal_scalar(s-&gt;init_S2,s-&gt;rfs[rfID].ss2);
<a name="l00872"></a>00872   vec_zero(s-&gt;rfs[rfID].dof);
<a name="l00873"></a>00873   vec_equal_scalar(<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>,s-&gt;rfs[rfID].sum_weights);
<a name="l00874"></a>00874   vec_zero(s-&gt;rfs[rfID].sum_error);
<a name="l00875"></a>00875   vec_zero(s-&gt;rfs[rfID].sum_error_cvi);
<a name="l00876"></a>00876   vec_zero(s-&gt;rfs[rfID].n_data);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   mat_zero(s-&gt;rfs[rfID].SXresYres);
<a name="l00879"></a>00879   mat_zero(s-&gt;rfs[rfID].SSXres);
<a name="l00880"></a>00880   mat_zero(s-&gt;rfs[rfID].SSYres);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l00883"></a>00883     <span class="keywordflow">for</span> (j=i; j&lt;=n_in_w; ++j) {
<a name="l00884"></a>00884       <span class="keywordflow">if</span> (!s-&gt;diag_only || i==j) {
<a name="l00885"></a>00885         s-&gt;rfs[rfID].M[i][j] = uniform(M[i][j], M[i][j]*s-&gt;d_noise);
<a name="l00886"></a>00886       }
<a name="l00887"></a>00887     }
<a name="l00888"></a>00888   }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890   <a class="code" href="lwpr_8c.html#5fb306d23122c90a7b4dcaa7d9f366bd">getLWPRDistMetric</a>(ID,rfID,s-&gt;rfs[rfID].D);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   mat_equal_scalar(s-&gt;init_alpha,s-&gt;rfs[rfID].alpha);
<a name="l00893"></a>00893   
<a name="l00894"></a>00894   <span class="keywordflow">if</span> (s-&gt;allow_meta_learning) {
<a name="l00895"></a>00895     
<a name="l00896"></a>00896     mat_zero(s-&gt;rfs[rfID].h);
<a name="l00897"></a>00897     mat_equal( s-&gt;rfs[rfID].alpha,s-&gt;rfs[rfID].b);
<a name="l00898"></a>00898     mat_add_scalar(s-&gt;rfs[rfID].b,<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>,s-&gt;rfs[rfID].b);
<a name="l00899"></a>00899     mat_equal_apply_math(s-&gt;rfs[rfID].b,&amp;log,s-&gt;rfs[rfID].b);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l00904"></a>00904     s-&gt;rfs[rfID].c[i] = c[i] + uniform(0.0,0.5774)*s-&gt;c_noise;
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906   
<a name="l00907"></a>00907   <span class="keywordflow">if</span> (DEBUG_FLAG) print_vec(<span class="stringliteral">"Center"</span>,s-&gt;rfs[rfID].c);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   s-&gt;rfs[rfID].sum_D2              = 0.0;
<a name="l00910"></a>00910   s-&gt;rfs[rfID].sum_error_cv        = 0.0;
<a name="l00911"></a>00911   s-&gt;rfs[rfID].trustworthy         = FALSE;
<a name="l00912"></a>00912   s-&gt;rfs[rfID].n_updates           = 0;
<a name="l00913"></a>00913   s-&gt;rfs[rfID].w                   = 0;
<a name="l00914"></a>00914   s-&gt;rfs[rfID].next_nn_check       = rfID-1;
<a name="l00915"></a>00915   vec_equal_scalar(s-&gt;init_lambda,s-&gt;rfs[rfID].lambda);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   vec_zero(s-&gt;rfs[rfID].var_x_reg);
<a name="l00918"></a>00918   vec_zero(s-&gt;rfs[rfID].mean_x_reg);
<a name="l00919"></a>00919   vec_zero(s-&gt;rfs[rfID].var_x_w);
<a name="l00920"></a>00920   vec_zero(s-&gt;rfs[rfID].mean_x_w);
<a name="l00921"></a>00921   vec_zero(s-&gt;rfs[rfID].var_y);
<a name="l00922"></a>00922   vec_zero(s-&gt;rfs[rfID].mean_y);
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   mat_eye(s-&gt;rfs[rfID].W);
<a name="l00925"></a>00925   mat_eye(s-&gt;rfs[rfID].U);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="comment">/* the second regression model if needed */</span>
<a name="l00928"></a>00928   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l00929"></a>00929     <span class="keywordtype">int</span> n_proj_2nd;
<a name="l00930"></a>00930     <span class="keywordtype">int</span> n_in_reg_2nd;
<a name="l00931"></a>00931     <span class="keywordtype">int</span> n_out_2nd;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933     n_in_reg_2nd = s-&gt;n_in_reg_2nd;
<a name="l00934"></a>00934     n_out_2nd    = s-&gt;n_out_2nd;
<a name="l00935"></a>00935     n_proj_2nd    = s-&gt;rfs[rfID].n_proj_2nd;
<a name="l00936"></a>00936   
<a name="l00937"></a>00937     mat_zero(s-&gt;rfs[rfID].B_2nd);
<a name="l00938"></a>00938     
<a name="l00939"></a>00939     vec_equal_scalar(s-&gt;init_S2,s-&gt;rfs[rfID].ss2_2nd);
<a name="l00940"></a>00940     vec_zero(s-&gt;rfs[rfID].dof_2nd);
<a name="l00941"></a>00941     vec_equal_scalar(<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>,s-&gt;rfs[rfID].sum_weights_2nd);
<a name="l00942"></a>00942     vec_zero(s-&gt;rfs[rfID].sum_error_2nd);
<a name="l00943"></a>00943     vec_zero(s-&gt;rfs[rfID].sum_error_cvi_2nd);
<a name="l00944"></a>00944     vec_zero(s-&gt;rfs[rfID].n_data_2nd);
<a name="l00945"></a>00945     
<a name="l00946"></a>00946     mat_zero(s-&gt;rfs[rfID].SXresYres_2nd);
<a name="l00947"></a>00947     mat_zero(s-&gt;rfs[rfID].SSXres_2nd);
<a name="l00948"></a>00948     mat_zero(s-&gt;rfs[rfID].SSYres_2nd);
<a name="l00949"></a>00949     
<a name="l00950"></a>00950     vec_equal_scalar(s-&gt;init_lambda,s-&gt;rfs[rfID].lambda_2nd);
<a name="l00951"></a>00951     
<a name="l00952"></a>00952     vec_zero(s-&gt;rfs[rfID].var_x_reg_2nd);
<a name="l00953"></a>00953     vec_zero(s-&gt;rfs[rfID].mean_x_reg_2nd);
<a name="l00954"></a>00954     vec_zero(s-&gt;rfs[rfID].var_y_2nd);
<a name="l00955"></a>00955     vec_zero(s-&gt;rfs[rfID].mean_y_2nd);
<a name="l00956"></a>00956     
<a name="l00957"></a>00957     mat_eye(s-&gt;rfs[rfID].W_2nd);
<a name="l00958"></a>00958     mat_eye(s-&gt;rfs[rfID].U_2nd);
<a name="l00959"></a>00959     
<a name="l00960"></a>00960   }
<a name="l00961"></a>00961   
<a name="l00962"></a>00962   <span class="comment">/* the nearest neigbor structure */</span>
<a name="l00963"></a>00963   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn   = 1;
<a name="l00964"></a>00964   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nn[1]  = rfID;
<a name="l00965"></a>00965   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].nnw[1] = 1.0;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967   <span class="keywordflow">return</span> TRUE;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="comment">/*!*****************************************************************************</span>
<a name="l00973"></a>00973 <span class="comment"> *******************************************************************************</span>
<a name="l00974"></a>00974 <span class="comment"> \note  addDataToLWPRCompControl</span>
<a name="l00975"></a>00975 <span class="comment"> \date  March 2003</span>
<a name="l00976"></a>00976 <span class="comment"> </span>
<a name="l00977"></a>00977 <span class="comment"> \remarks </span>
<a name="l00978"></a>00978 <span class="comment"> </span>
<a name="l00979"></a>00979 <span class="comment"> Customized function for adding data for a model used in composite control.</span>
<a name="l00980"></a>00980 <span class="comment"> All it does is to do an input vector expansion for linear g(x) terms, as</span>
<a name="l00981"></a>00981 <span class="comment"> specified in the LWPR structure.</span>
<a name="l00982"></a>00982 <span class="comment"> </span>
<a name="l00983"></a>00983 <span class="comment"> *******************************************************************************</span>
<a name="l00984"></a>00984 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l00985"></a>00985 <span class="comment"> </span>
<a name="l00986"></a>00986 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l00987"></a>00987 <span class="comment"> \param[in]     x      : the input state vector</span>
<a name="l00988"></a>00988 <span class="comment"> \param[in]     u      : the input control vector</span>
<a name="l00989"></a>00989 <span class="comment"> \param[in]     y      : the output vector</span>
<a name="l00990"></a>00990 <span class="comment"> \param[in]     flag   : FALSE if y is an output, TRUE if y is an error</span>
<a name="l00991"></a>00991 <span class="comment"> \param[in,out] rfID   : neighborhood rfID for input, max activated rfID for output</span>
<a name="l00992"></a>00992 <span class="comment"> \param[out]    y_pred : the prediction for the current training point after updating</span>
<a name="l00993"></a>00993 <span class="comment"> \param[in]     tracking_error : the tracking error per output</span>
<a name="l00994"></a>00994 <span class="comment"> \param[in]     tracking_error_gain: the gain for tracking error updates</span>
<a name="l00995"></a>00995 <span class="comment"> </span>
<a name="l00996"></a>00996 <span class="comment"> ******************************************************************************/</span>
<a name="l00997"></a>00997 <span class="keywordtype">int</span> 
<a name="l00998"></a><a class="code" href="lwpr_8h.html#8771db5ef115880e04151b85c362a080">00998</a> <a class="code" href="lwpr_8c.html#8771db5ef115880e04151b85c362a080">addDataToLWPRCompControl</a>(<span class="keywordtype">int</span> ID, Vector x, Vector u, Vector y, <span class="keywordtype">int</span> flag, <span class="keywordtype">int</span> *rfID,
<a name="l00999"></a>00999                          Vector y_pred, Vector tracking_error, <span class="keywordtype">double</span> tracking_error_gain)
<a name="l01000"></a>01000 {
<a name="l01001"></a>01001   <span class="keywordtype">int</span> rc;
<a name="l01002"></a>01002   <span class="keywordtype">int</span> i,j,r;
<a name="l01003"></a>01003   <span class="keywordtype">int</span> n_in_expected;
<a name="l01004"></a>01004   <span class="keywordtype">double</span> aux;
<a name="l01005"></a>01005   <span class="keyword">static</span> Vector x_aug = NULL;
<a name="l01006"></a>01006   LWPR   *s;
<a name="l01007"></a>01007   
<a name="l01008"></a>01008   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l01009"></a>01009     <span class="keywordflow">return</span> FALSE;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011   s = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l01012"></a>01012   
<a name="l01013"></a>01013   <span class="keywordflow">if</span> (s-&gt;linear_gx) 
<a name="l01014"></a>01014     n_in_expected = s-&gt;n_states + 
<a name="l01015"></a>01015       s-&gt;n_controls*s-&gt;n_states + s-&gt;n_controls;
<a name="l01016"></a>01016   <span class="keywordflow">else</span>
<a name="l01017"></a>01017     n_in_expected = s-&gt;n_states + s-&gt;n_controls;
<a name="l01018"></a>01018   
<a name="l01019"></a>01019   <span class="keywordflow">if</span> (n_in_expected != s-&gt;n_in_reg) {
<a name="l01020"></a>01020     printf(<span class="stringliteral">"addDataToLWPRCompControl: #inputs in LWPR (%d) does not match #inputs computed (%d)\n"</span>,s-&gt;n_in_reg,n_in_expected);
<a name="l01021"></a>01021     <span class="keywordflow">return</span> FALSE;
<a name="l01022"></a>01022   }
<a name="l01023"></a>01023   
<a name="l01024"></a>01024   <span class="keywordflow">if</span> (x_aug == NULL)
<a name="l01025"></a>01025     x_aug = my_vector(1,n_in_expected);
<a name="l01026"></a>01026   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x_aug[NR] &lt; n_in_expected)
<a name="l01027"></a>01027     vec_add_shape(&amp;x_aug,n_in_expected-x_aug[NR]);
<a name="l01028"></a>01028   
<a name="l01029"></a>01029   <span class="comment">/* if a linear g(x) is to be learned, the input vector has to be augmented */</span>
<a name="l01030"></a>01030   <span class="keywordflow">if</span> (s-&gt;linear_gx) {
<a name="l01031"></a>01031     r=0;
<a name="l01032"></a>01032     <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_states; ++i)      
<a name="l01033"></a>01033       x_aug[++r] = x[i];
<a name="l01034"></a>01034     
<a name="l01035"></a>01035     <span class="keywordflow">for</span> (j=1; j&lt;=s-&gt;n_controls; ++j)
<a name="l01036"></a>01036       <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_states; ++i)
<a name="l01037"></a>01037         x_aug[++r] = x[i]*u[j];
<a name="l01038"></a>01038     
<a name="l01039"></a>01039     <span class="keywordflow">for</span> (j=1; j&lt;=s-&gt;n_controls; ++j)
<a name="l01040"></a>01040       x_aug[++r] = u[j];
<a name="l01041"></a>01041   } <span class="keywordflow">else</span> 
<a name="l01042"></a>01042     vec_equal_size(x,s-&gt;n_in_reg,x_aug);
<a name="l01043"></a>01043 
<a name="l01044"></a>01044   <span class="comment">/* the regression update */</span>
<a name="l01045"></a>01045   rc = addDataToLWPR(ID, x, x_aug, y, flag, rfID);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="comment">/* finalize the prediction */</span>
<a name="l01048"></a>01048   aux = 0;
<a name="l01049"></a>01049   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out; ++i) {
<a name="l01050"></a>01050     y_pred[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted[i];
<a name="l01051"></a>01051     aux += y_pred[i];
<a name="l01052"></a>01052   }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054   <span class="keywordflow">if</span> (aux == 0.0)
<a name="l01055"></a>01055     rc = FALSE;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057   <span class="comment">/* the tracking error update */</span>
<a name="l01058"></a>01058   <span class="keywordflow">for</span> (r=1; r&lt;=s-&gt;n_rf; ++r) {
<a name="l01059"></a>01059 
<a name="l01060"></a>01060     <span class="comment">/* should we update this RF: only those RFs that have a nonzero weights</span>
<a name="l01061"></a>01061 <span class="comment">       need to be considered */</span>
<a name="l01062"></a>01062     <span class="keywordflow">if</span> (s-&gt;rfs[r].w &lt; <a class="code" href="lwpr_8h.html#b04f685e26a29b32fd50369b1b15dfec">ACTIVATION_THRESHOLD</a>) {
<a name="l01063"></a>01063       <span class="keywordflow">continue</span>;
<a name="l01064"></a>01064     } 
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     <span class="comment">/* update in the subspace with the normalized weight */</span>
<a name="l01067"></a>01067     <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;rfs[r].n_proj; ++i) {
<a name="l01068"></a>01068       aux = s-&gt;rfs[r].s[i]/(s-&gt;rfs[r].ss2[i]+1.e-10)*s-&gt;rfs[r].w/sum_activation;
<a name="l01069"></a>01069       for (j=1; j&lt;=s-&gt;n_out; ++j)
<a name="l01070"></a>01070         s-&gt;rfs[r].B[i][j] -= aux * tracking_error[j] * tracking_error_gain / s-&gt;norm_out[j];
<a name="l01071"></a>01071     }
<a name="l01072"></a>01072     <span class="comment">/* update the constant regression term */</span>
<a name="l01073"></a>01073     aux = 1./(s-&gt;rfs[r].sum_weights[1]+1.e-10)*s-&gt;rfs[r].w/sum_activation;
<a name="l01074"></a>01074     for (j=1; j&lt;=s-&gt;n_out; ++j)
<a name="l01075"></a>01075       s-&gt;rfs[r].mean_y[j] -= aux * tracking_error[j] * tracking_error_gain / s-&gt;norm_out[j];
<a name="l01076"></a>01076 
<a name="l01077"></a>01077   }
<a name="l01078"></a>01078   
<a name="l01079"></a>01079   <span class="keywordflow">return</span> rc;
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 }
<a name="l01082"></a>01082 <span class="comment">/*!*****************************************************************************</span>
<a name="l01083"></a>01083 <span class="comment"> *******************************************************************************</span>
<a name="l01084"></a>01084 <span class="comment"> \note  addDataToLWPR</span>
<a name="l01085"></a>01085 <span class="comment"> \date  March 1999</span>
<a name="l01086"></a>01086 <span class="comment"> </span>
<a name="l01087"></a>01087 <span class="comment"> \remarks </span>
<a name="l01088"></a>01088 <span class="comment"> </span>
<a name="l01089"></a>01089 <span class="comment"> Adds a data point to the model</span>
<a name="l01090"></a>01090 <span class="comment"> </span>
<a name="l01091"></a>01091 <span class="comment"> *******************************************************************************</span>
<a name="l01092"></a>01092 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01093"></a>01093 <span class="comment"> </span>
<a name="l01094"></a>01094 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l01095"></a>01095 <span class="comment"> \param[in]     x_w    : the input vector for the weights</span>
<a name="l01096"></a>01096 <span class="comment"> \param[in]     x      : the input vector for the regression</span>
<a name="l01097"></a>01097 <span class="comment"> \param[in]     y      : the output vector for the regression</span>
<a name="l01098"></a>01098 <span class="comment"> \param[in]     flag   : FALSE if y is an output, TRUE if y is an error</span>
<a name="l01099"></a>01099 <span class="comment"> \param[in,out] rfID   : neighborhood rfID for input, max activated rfID for output</span>
<a name="l01100"></a>01100 <span class="comment"> </span>
<a name="l01101"></a>01101 <span class="comment"> ******************************************************************************/</span>
<a name="l01102"></a>01102 <span class="keywordtype">int</span> 
<a name="l01103"></a><a class="code" href="lwpr_8h.html#fabff62936cf6f43454068bfbfb4fbde">01103</a> <a class="code" href="lwpr_8c.html#fabff62936cf6f43454068bfbfb4fbde">addDataToLWPRPredictConf</a>(<span class="keywordtype">int</span> ID, Vector x_w, Vector x, Vector y, <span class="keywordtype">int</span> flag, <span class="keywordtype">int</span> *rfID, 
<a name="l01104"></a>01104                          Vector y_pred, Vector conf)
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 {
<a name="l01107"></a>01107   <span class="keywordtype">int</span> i,rc;
<a name="l01108"></a>01108   <span class="keywordtype">double</span> aux=0;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   rc = addDataToLWPR(ID,x_w, x,y,flag,rfID);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out; ++i) {
<a name="l01113"></a>01113     y_pred[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted[i];
<a name="l01114"></a>01114     conf[i]   = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_conf[i];
<a name="l01115"></a>01115     aux += y_pred[i];
<a name="l01116"></a>01116   }
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="keywordflow">if</span> (aux != 0.0)
<a name="l01119"></a>01119     <span class="keywordflow">return</span> rc;
<a name="l01120"></a>01120   <span class="keywordflow">else</span>
<a name="l01121"></a>01121     <span class="keywordflow">return</span> FALSE;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 <span class="keywordtype">int</span> 
<a name="l01126"></a>01126 addDataToLWPRPredict(<span class="keywordtype">int</span> ID, Vector x_w, Vector x, Vector y, <span class="keywordtype">int</span> flag, <span class="keywordtype">int</span> *rfID, 
<a name="l01127"></a>01127                      Vector y_pred)
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 {
<a name="l01130"></a>01130   <span class="keywordtype">int</span> i,rc;
<a name="l01131"></a>01131   <span class="keywordtype">double</span> aux=0;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133   rc = addDataToLWPR(ID,x_w, x,y,flag,rfID);
<a name="l01134"></a>01134 
<a name="l01135"></a>01135   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out; ++i) {
<a name="l01136"></a>01136     y_pred[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted[i];
<a name="l01137"></a>01137     aux += y_pred[i];
<a name="l01138"></a>01138   }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="keywordflow">if</span> (aux != 0.0)
<a name="l01141"></a>01141     <span class="keywordflow">return</span> rc;
<a name="l01142"></a>01142   <span class="keywordflow">else</span>
<a name="l01143"></a>01143     <span class="keywordflow">return</span> FALSE;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147 <span class="keywordtype">int</span> 
<a name="l01148"></a>01148 addDataToLWPR(<span class="keywordtype">int</span> ID, Vector x_w, Vector x, Vector y, <span class="keywordtype">int</span> flag, <span class="keywordtype">int</span> *rfID)
<a name="l01149"></a>01149      
<a name="l01150"></a>01150 {
<a name="l01151"></a>01151   <span class="keywordtype">double</span> w_misc = 1.0;
<a name="l01152"></a>01152   <span class="keywordflow">return</span> addWeightedDataToLWPR(ID, x_w, x, y, w_misc, flag, rfID);
<a name="l01153"></a>01153 }
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="keywordtype">int</span> 
<a name="l01156"></a>01156 addWeightedDataToLWPR(<span class="keywordtype">int</span> ID, Vector x_w, Vector x, Vector y, 
<a name="l01157"></a>01157                       <span class="keywordtype">double</span> w_misc, <span class="keywordtype">int</span> flag, <span class="keywordtype">int</span> *rfID)
<a name="l01158"></a>01158      
<a name="l01159"></a>01159 {
<a name="l01160"></a>01160   <span class="keywordtype">int</span>      i,j,k,r;
<a name="l01161"></a>01161   <span class="keywordtype">double</span>   max_activation=0;
<a name="l01162"></a>01162   <span class="keywordtype">double</span>   sec_activation=0;
<a name="l01163"></a>01163   <span class="keywordtype">int</span>      index_max;
<a name="l01164"></a>01164   <span class="keywordtype">int</span>      index_sec;
<a name="l01165"></a>01165   <span class="keywordtype">int</span>      index_prune;
<a name="l01166"></a>01166   <span class="keywordtype">int</span>      index_non_prune;
<a name="l01167"></a>01167   <span class="keywordtype">double</span>   activation;
<a name="l01168"></a>01168   <span class="keywordtype">int</span>      rfIDaux;
<a name="l01169"></a>01169   <span class="keywordtype">double</span>   aux,aux1;
<a name="l01170"></a>01170   LWPR     *s;
<a name="l01171"></a>01171   <span class="keywordtype">char</span>     stmp[100];
<a name="l01172"></a>01172   <span class="keywordtype">double</span>   dofs;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174   <span class="keyword">static</span> <span class="keywordtype">int</span> count_updates = -1;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   s = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l01177"></a>01177 
<a name="l01178"></a>01178   <span class="comment">/**********************************************/</span>
<a name="l01179"></a>01179   <span class="comment">/* normalize the inputs and outputs           */</span>
<a name="l01180"></a>01180   <span class="comment">/**********************************************/</span>
<a name="l01181"></a>01181 
<a name="l01182"></a>01182   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_reg; ++i) {
<a name="l01183"></a>01183     s-&gt;x[i] = x[i]/s-&gt;norm_in_reg[i];
<a name="l01184"></a>01184   }
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_w; ++i) {
<a name="l01187"></a>01187     s-&gt;x_w[i] = x_w[i]/s-&gt;norm_in_w[i];
<a name="l01188"></a>01188   }
<a name="l01189"></a>01189 
<a name="l01190"></a>01190   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_out; ++i) {
<a name="l01191"></a>01191     s-&gt;y[i] = y[i]/s-&gt;norm_out[i];
<a name="l01192"></a>01192   }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194   <span class="comment">/**********************************************/</span>
<a name="l01195"></a>01195   <span class="comment">/* update the mean and variance of the inputs */</span>
<a name="l01196"></a>01196   <span class="comment">/**********************************************/</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_reg; ++i) {
<a name="l01199"></a>01199     s-&gt;mean_x_reg[i] = (((double)s-&gt;n_data) * s-&gt;mean_x_reg[i] + s-&gt;x[i]) /
<a name="l01200"></a>01200       (((<span class="keywordtype">double</span>)s-&gt;n_data) + 1.);
<a name="l01201"></a>01201     s-&gt;var_x_reg[i] = (((double)s-&gt;n_data) * s-&gt;var_x_reg[i] + 
<a name="l01202"></a>01202                        sqr(s-&gt;x[i]-s-&gt;mean_x_reg[i]))/(((<span class="keywordtype">double</span>)s-&gt;n_data) + 1.);
<a name="l01203"></a>01203   }
<a name="l01204"></a>01204   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_w; ++i) {
<a name="l01205"></a>01205     s-&gt;mean_x_w[i] = (((double)s-&gt;n_data) * s-&gt;mean_x_w[i] + s-&gt;x_w[i]) /
<a name="l01206"></a>01206       (((<span class="keywordtype">double</span>)s-&gt;n_data) + 1.);
<a name="l01207"></a>01207     s-&gt;var_x_w[i] = (((double)s-&gt;n_data) * s-&gt;var_x_w[i] + 
<a name="l01208"></a>01208                      sqr(s-&gt;x_w[i]-s-&gt;mean_x_w[i]))/(((<span class="keywordtype">double</span>)s-&gt;n_data) + 1.);
<a name="l01209"></a>01209   }
<a name="l01210"></a>01210   s-&gt;n_data += 1;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212   <span class="comment">/*****************************************************************/</span>
<a name="l01213"></a>01213   <span class="comment">/* Run through all receptive fields and update their             */</span>
<a name="l01214"></a>01214   <span class="comment">/* parameters appropriately                                      */</span>
<a name="l01215"></a>01215   <span class="comment">/*****************************************************************/</span>
<a name="l01216"></a>01216      
<a name="l01217"></a>01217   sum_activation  = 0;
<a name="l01218"></a>01218   max_activation  = 0;
<a name="l01219"></a>01219   sec_activation  = 0;
<a name="l01220"></a>01220   index_max       = 0;
<a name="l01221"></a>01221   index_sec       = 0;
<a name="l01222"></a>01222   s-&gt;n_no_trust   = 0;
<a name="l01223"></a>01223   s-&gt;mean_n_proj  = 0.0;
<a name="l01224"></a>01224   s-&gt;contrib_n_rf = 0.0;
<a name="l01225"></a>01225   
<a name="l01226"></a>01226   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_out; ++i) {
<a name="l01227"></a>01227     s-&gt;sum_y_predicted[i]  =0.0;
<a name="l01228"></a>01228     s-&gt;sum_y_predicted2[i] =0.0;
<a name="l01229"></a>01229     s-&gt;sum_y_conf[i]       =0.0;
<a name="l01230"></a>01230   }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 
<a name="l01233"></a>01233   <span class="keywordflow">for</span> (r=1; r&lt;=s-&gt;n_rf; ++r) {
<a name="l01234"></a>01234 
<a name="l01235"></a>01235     <span class="comment">/* zero the weight to recognize which RF was updated */</span>
<a name="l01236"></a>01236     s-&gt;rfs[i].w = 0;
<a name="l01237"></a>01237 
<a name="l01238"></a>01238     <span class="comment">/* fudge in the nearest neighbor add */</span>
<a name="l01239"></a>01239     <span class="keywordflow">if</span> (s-&gt;use_nn &amp;&amp; *rfID &gt; 0 &amp;&amp; *rfID &lt;= s-&gt;n_rf) {
<a name="l01240"></a>01240       <span class="keywordflow">if</span> ( (r &gt; s-&gt;max_nn_comp &amp;&amp; max_activation &gt; s-&gt;w_gen) || 
<a name="l01241"></a>01241            r &gt; s-&gt;rfs[*rfID].n_nn)
<a name="l01242"></a>01242         <span class="keywordflow">break</span>;
<a name="l01243"></a>01243       i = s-&gt;rfs[*rfID].nn[r];
<a name="l01244"></a>01244     } <span class="keywordflow">else</span> {
<a name="l01245"></a>01245       i = r;
<a name="l01246"></a>01246     }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248     <span class="keywordflow">if</span> (!s-&gt;rfs[i].trustworthy)   
<a name="l01249"></a>01249       ++s-&gt;n_no_trust;
<a name="l01250"></a>01250 
<a name="l01251"></a>01251     s-&gt;mean_n_proj  += (double) s-&gt;rfs[i].n_proj;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253     <span class="comment">/* get the activation weight */</span>
<a name="l01254"></a>01254     activation = s-&gt;rfs[i].w = calculateWeight(ID,i,s-&gt;x_w)*w_misc;
<a name="l01255"></a>01255  
<a name="l01256"></a>01256     <span class="comment">/* should we update this RF ? */</span>
<a name="l01257"></a>01257     <span class="keywordflow">if</span> (activation &lt; <a class="code" href="lwpr_8h.html#b04f685e26a29b32fd50369b1b15dfec">ACTIVATION_THRESHOLD</a>) {
<a name="l01258"></a>01258       s-&gt;rfs[i].w = 0;
<a name="l01259"></a>01259       <span class="keywordflow">continue</span>;
<a name="l01260"></a>01260     } 
<a name="l01261"></a>01261 
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="comment">/* yes, we are going to update now */</span>
<a name="l01264"></a>01264     ++s-&gt;rfs[i].n_updates;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266    <span class="comment">/* update the mean and variance, return the mean subtracted input for</span>
<a name="l01267"></a>01267 <span class="comment">      regression */</span>
<a name="l01268"></a>01268     updateMeanVar(ID,i,s-&gt;x_w,s-&gt;x,s-&gt;x_mz);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270     <span class="keywordflow">if</span> (DEBUG_FLAG) {
<a name="l01271"></a>01271       printf(<span class="stringliteral">"w=%f\n"</span>,activation);
<a name="l01272"></a>01272       print_vec(<span class="stringliteral">"x_mz"</span>,s-&gt;x_mz);
<a name="l01273"></a>01273     }
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     <span class="comment">/* create a fake training point if error-based learning is on */</span>
<a name="l01276"></a>01276     createFakeTarget(ID,i,s-&gt;x_mz,s-&gt;y,flag,s-&gt;y_mz);
<a name="l01277"></a>01277     
<a name="l01278"></a>01278     <span class="comment">/* update the mean and variance of the outputs, return the mean </span>
<a name="l01279"></a>01279 <span class="comment">       subtracted output */</span>
<a name="l01280"></a>01280     updateRegMeanVar(ID,i,s-&gt;y_mz,s-&gt;y_mz);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="keywordflow">if</span> (DEBUG_FLAG) {
<a name="l01283"></a>01283       print_vec(<span class="stringliteral">"y_mz"</span>,s-&gt;y_mz);
<a name="l01284"></a>01284       getchar();
<a name="l01285"></a>01285     }
<a name="l01286"></a>01286 
<a name="l01287"></a>01287     <span class="comment">/* calculate regression update */</span>
<a name="l01288"></a>01288     calculateRegression(ID,i,s-&gt;x_mz,s-&gt;y_mz);
<a name="l01289"></a>01289     
<a name="l01290"></a>01290     <span class="comment">/* update adminstrative variables */</span>
<a name="l01291"></a>01291     updateAdmVars(ID,i);
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     <span class="comment">/* update the distance metric */</span>
<a name="l01294"></a>01294     updateDistanceMetric(ID,i,s-&gt;x_w,s-&gt;x_mz);
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="comment">/* accumulate the sum of predictions */</span>
<a name="l01297"></a>01297     <span class="keywordflow">if</span> (s-&gt;rfs[i].trustworthy) {
<a name="l01298"></a>01298       sum_activation += activation;
<a name="l01299"></a>01299       <span class="keywordflow">for</span> (j=1; j&lt;=s-&gt;n_out; ++j) {
<a name="l01300"></a>01300         s-&gt;sum_y_predicted[j]  += s-&gt;ypred[j]*activation;
<a name="l01301"></a>01301         s-&gt;sum_y_predicted2[j] += sqr(s-&gt;ypred[j])*activation;
<a name="l01302"></a>01302         dofs = s-&gt;rfs[i].sum_weights[1];
<a name="l01303"></a>01303         aux  = 1;
<a name="l01304"></a>01304         <span class="keywordflow">for</span> (k=1; k&lt;=s-&gt;rfs[i].n_proj; ++k) {
<a name="l01305"></a>01305           dofs -= s-&gt;rfs[i].dof[k];
<a name="l01306"></a>01306           aux  += sqr(s-&gt;rfs[i].s[k])/s-&gt;rfs[i].ss2[k]*activation;
<a name="l01307"></a>01307         }
<a name="l01308"></a>01308         <span class="keywordflow">if</span> (dofs &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>)
<a name="l01309"></a>01309           dofs = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l01310"></a>01310         s-&gt;sum_y_conf[j] += activation*s-&gt;rfs[i].sum_error[s-&gt;rfs[i].n_proj]/dofs*aux;
<a name="l01311"></a>01311       }
<a name="l01312"></a>01312     } <span class="keywordflow">else</span> {
<a name="l01313"></a>01313       <span class="comment">/* indicate that this RF did not contribute to predictions */</span>
<a name="l01314"></a>01314       s-&gt;rfs[i].w = 0;
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="comment">/* check if another dimension has to be added */</span>
<a name="l01318"></a>01318     <span class="keywordflow">if</span> (s-&gt;allow_addDim) {
<a name="l01319"></a>01319       <span class="keywordflow">if</span> (checkAddDim(ID,i)){
<a name="l01320"></a>01320         addDimension(ID,i);
<a name="l01321"></a>01321       }
<a name="l01322"></a>01322     }
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     <span class="comment">/* I have to keep track of the largest and the second largest activation */</span>
<a name="l01325"></a>01325     
<a name="l01326"></a>01326     <span class="keywordflow">if</span> (activation &gt; sec_activation) {
<a name="l01327"></a>01327       sec_activation = activation;
<a name="l01328"></a>01328       index_sec      = i;
<a name="l01329"></a>01329       <span class="keywordflow">if</span> (sec_activation &gt; max_activation) {
<a name="l01330"></a>01330         sec_activation = max_activation;
<a name="l01331"></a>01331         index_sec      = index_max;
<a name="l01332"></a>01332         max_activation = activation;
<a name="l01333"></a>01333         index_max      = i;
<a name="l01334"></a>01334       }
<a name="l01335"></a>01335     }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337  
<a name="l01338"></a>01338   }
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="comment">/* finish some statistics */</span>
<a name="l01341"></a>01341 
<a name="l01342"></a>01342   --r;
<a name="l01343"></a>01343   <span class="keywordflow">if</span> (r &gt; 0) {
<a name="l01344"></a>01344     s-&gt;mean_n_proj  /= (double) r;
<a name="l01345"></a>01345   }
<a name="l01346"></a>01346   s-&gt;contrib_n_rf = r;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348   <span class="comment">/* this is the current prediction for the newly added data point,</span>
<a name="l01349"></a>01349 <span class="comment">     AFTER the RFs have been updated */</span>
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="keywordflow">if</span> (sum_activation &gt; 0) {
<a name="l01352"></a>01352     <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_out; ++i) {
<a name="l01353"></a>01353       <span class="comment">/* first computations without taking the output normalization into account */</span>
<a name="l01354"></a>01354       s-&gt;sum_y_predicted[i] = 
<a name="l01355"></a>01355         s-&gt;sum_y_predicted[i]/sum_activation;
<a name="l01356"></a>01356       aux = fabs(s-&gt;sum_y_predicted2[i]/sum_activation - 
<a name="l01357"></a>01357              sqr(s-&gt;sum_y_predicted[i]))/sum_activation;
<a name="l01358"></a>01358       s-&gt;sum_y_conf[i] = sqrt(s-&gt;sum_y_conf[i]/sqr(sum_activation)+aux);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360       <span class="comment">/* now add the correction for output normalization */</span>
<a name="l01361"></a>01361       s-&gt;sum_y_predicted[i] *= s-&gt;norm_out[i];
<a name="l01362"></a>01362       s-&gt;sum_y_conf[i] *= s-&gt;norm_out[i];
<a name="l01363"></a>01363 
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365   }
<a name="l01366"></a>01366 
<a name="l01367"></a>01367   *rfID = index_max;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369   <span class="comment">/*****************************************************************/</span>
<a name="l01370"></a>01370   <span class="comment">/* check whether a new rf must be created */</span>
<a name="l01371"></a>01371   <span class="comment">/*****************************************************************/</span>
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   
<a name="l01374"></a>01374   <span class="keywordflow">if</span> (max_activation &lt; s-&gt;w_gen &amp;&amp; s-&gt;n_rf &lt; s-&gt;max_rfs &amp;&amp; s-&gt;allow_add_rfs) {
<a name="l01375"></a>01375   
<a name="l01376"></a>01376     <span class="comment">/* this is a simple speed up: if a neighboring RF is activated</span>
<a name="l01377"></a>01377 <span class="comment">       sufficiently and if it is trustworthy, I copy some of its</span>
<a name="l01378"></a>01378 <span class="comment">       parameters */</span>
<a name="l01379"></a>01379 
<a name="l01380"></a>01380     <span class="keywordflow">if</span> (max_activation &gt; s-&gt;w_gen*.1 &amp;&amp; index_max &gt; 0 &amp;&amp;
<a name="l01381"></a>01381         s-&gt;rfs[index_max].trustworthy) {
<a name="l01382"></a>01382       
<a name="l01383"></a>01383       rfIDaux = 
<a name="l01384"></a>01384         addRF(ID,s-&gt;rfs[index_max].n_proj,s-&gt;rfs[index_max].n_proj_2nd,<a class="code" href="lwpr_8h.html#6b96ba77d08e0d538a0e114fba48c167">NN_BLOCK</a>);
<a name="l01385"></a>01385       
<a name="l01386"></a>01386       <span class="keywordflow">if</span> (rfIDaux != FALSE) {
<a name="l01387"></a>01387         initRF(ID, rfIDaux, s-&gt;x_w, s-&gt;rfs[index_max].M);
<a name="l01388"></a>01388       }
<a name="l01389"></a>01389       
<a name="l01390"></a>01390     } <span class="keywordflow">else</span> {
<a name="l01391"></a>01391       
<a name="l01392"></a>01392       <span class="comment">/* default initizialization */</span>
<a name="l01393"></a>01393       
<a name="l01394"></a>01394       rfIDaux = 
<a name="l01395"></a>01395         addRF(ID,s-&gt;init_n_proj,s-&gt;init_n_proj_2nd,<a class="code" href="lwpr_8h.html#6b96ba77d08e0d538a0e114fba48c167">NN_BLOCK</a>);
<a name="l01396"></a>01396       
<a name="l01397"></a>01397       <span class="keywordflow">if</span> (rfIDaux != FALSE) {
<a name="l01398"></a>01398         initRF(ID, rfIDaux, s-&gt;x_w, s-&gt;init_M);
<a name="l01399"></a>01399       }
<a name="l01400"></a>01400       
<a name="l01401"></a>01401     }
<a name="l01402"></a>01402     
<a name="l01403"></a>01403     *rfID = rfIDaux;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405   }
<a name="l01406"></a>01406   
<a name="l01407"></a>01407   <span class="comment">/*****************************************************************/</span>
<a name="l01408"></a>01408   <span class="comment">/* update the nearest neighbor relations                         */</span>
<a name="l01409"></a>01409   <span class="comment">/*****************************************************************/</span>
<a name="l01410"></a>01410 
<a name="l01411"></a>01411   <span class="keywordflow">if</span> (index_max &gt; 0 &amp;&amp; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_nn) {
<a name="l01412"></a>01412     checkNeighborhood(ID,index_max,
<a name="l01413"></a>01413                       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[index_max].next_nn_check);
<a name="l01414"></a>01414     <span class="keywordflow">if</span> (--<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[index_max].next_nn_check &lt; 1)
<a name="l01415"></a>01415       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[index_max].next_nn_check = index_max-1;
<a name="l01416"></a>01416   }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418   <span class="comment">/*****************************************************************/</span>
<a name="l01419"></a>01419   <span class="comment">/* check whether a rf must be pruned because of overlap          */</span>
<a name="l01420"></a>01420   <span class="comment">/*****************************************************************/</span>
<a name="l01421"></a>01421 
<a name="l01422"></a>01422   <span class="keywordflow">if</span> (max_activation &gt; s-&gt;w_prune &amp;&amp; sec_activation &gt; s-&gt;w_prune 
<a name="l01423"></a>01423       &amp;&amp; index_max != index_sec &amp;&amp; index_max &gt; 0 &amp;&amp; index_sec &gt; 0) {
<a name="l01424"></a>01424   
<a name="l01425"></a>01425     <span class="comment">/* pruning the RF with the larger error */</span>
<a name="l01426"></a>01426     index_prune     = index_sec;
<a name="l01427"></a>01427     index_non_prune = index_max;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429     aux  = s-&gt;rfs[index_max].sum_error_cv;
<a name="l01430"></a>01430     aux1 = s-&gt;rfs[index_sec].sum_error_cv;
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     <span class="keywordflow">if</span> (aux &gt; aux1) {
<a name="l01433"></a>01433       index_prune = index_max;
<a name="l01434"></a>01434       index_non_prune = index_sec;
<a name="l01435"></a>01435     }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437     sprintf(stmp,<span class="stringliteral">"overlap prune due to %d"</span>,index_non_prune);
<a name="l01438"></a>01438     <span class="keywordflow">if</span> (s-&gt;write_rfs) <a class="code" href="lwpr_8c.html#9c159349ffa2c22b1e4d2f26b1a13732">writeRFAscii</a>(ID,index_prune,TRUE,stmp);
<a name="l01439"></a>01439     sprintf(stmp,<span class="stringliteral">"this RF caused overlap prune of %d"</span>,index_prune);
<a name="l01440"></a>01440     <span class="keywordflow">if</span> (s-&gt;write_rfs) <a class="code" href="lwpr_8c.html#9c159349ffa2c22b1e4d2f26b1a13732">writeRFAscii</a>(ID,index_non_prune,TRUE,stmp);
<a name="l01441"></a>01441     <a class="code" href="lwpr_8c.html#1a9c86129044ef0a65a68684926c456a">deleteRF</a>(ID,index_prune);
<a name="l01442"></a>01442     ++s-&gt;n_pruned_overlap;
<a name="l01443"></a>01443     <span class="comment">/* printf("Pruned ID#%d  RF#%d\n",ID,index_prune); */</span>
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     *rfID = index_non_prune;
<a name="l01446"></a>01446   
<a name="l01447"></a>01447   }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449   <span class="comment">/*****************************************************************/</span>
<a name="l01450"></a>01450   <span class="comment">/* does any rf have an excessive error? I check this in some</span>
<a name="l01451"></a>01451 <span class="comment">     kind of arbitary interval */</span>
<a name="l01452"></a>01452   <span class="comment">/*****************************************************************/</span>
<a name="l01453"></a>01453 
<a name="l01454"></a>01454   <span class="keywordflow">if</span> (count_updates &lt; 0 || count_updates++ &gt;(10*s-&gt;n_rf) || 
<a name="l01455"></a>01455       count_updates &gt; 1000) {
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     count_updates = 0;
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     <span class="comment">/* get the statistics calculated */</span>
<a name="l01460"></a>01460 <span class="preprocessor">#ifdef FIXXXXXXX</span>
<a name="l01461"></a>01461 <span class="preprocessor"></span>    calculateLWPRStatistics(ID);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463     <span class="comment">/* find those RF which have an excessive error */</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465     checkLargeError(ID);
<a name="l01466"></a>01466 
<a name="l01467"></a>01467     <span class="comment">/* find those RF which have almost no data and have not</span>
<a name="l01468"></a>01468 <span class="comment">       been update for ages */</span>
<a name="l01469"></a>01469 
<a name="l01470"></a>01470     checkLostRFs(ID);
<a name="l01471"></a>01471 <span class="preprocessor">#endif</span>
<a name="l01472"></a>01472 <span class="preprocessor"></span>  }
<a name="l01473"></a>01473 
<a name="l01474"></a>01474   <span class="keywordflow">return</span> TRUE;
<a name="l01475"></a>01475   
<a name="l01476"></a>01476 }
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 <span class="comment">/*!*****************************************************************************</span>
<a name="l01479"></a>01479 <span class="comment"> *******************************************************************************</span>
<a name="l01480"></a>01480 <span class="comment">\note  calculateWeight</span>
<a name="l01481"></a>01481 <span class="comment">\date  Nov 3, 1992</span>
<a name="l01482"></a>01482 <span class="comment"></span>
<a name="l01483"></a>01483 <span class="comment">\remarks </span>
<a name="l01484"></a>01484 <span class="comment"></span>
<a name="l01485"></a>01485 <span class="comment">       calculates the activation of a given rf for a given input vector</span>
<a name="l01486"></a>01486 <span class="comment"></span>
<a name="l01487"></a>01487 <span class="comment"></span>
<a name="l01488"></a>01488 <span class="comment"> *******************************************************************************</span>
<a name="l01489"></a>01489 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01490"></a>01490 <span class="comment"></span>
<a name="l01491"></a>01491 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l01492"></a>01492 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l01493"></a>01493 <span class="comment"> \param[in]     x     : the input vector for weights</span>
<a name="l01494"></a>01494 <span class="comment"></span>
<a name="l01495"></a>01495 <span class="comment"> ******************************************************************************/</span>
<a name="l01496"></a>01496 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l01497"></a>01497 calculateWeight(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x)
<a name="l01498"></a>01498 
<a name="l01499"></a>01499 {
<a name="l01500"></a>01500 
<a name="l01501"></a>01501   <span class="keywordtype">int</span>    i,j,k;
<a name="l01502"></a>01502   <span class="keywordtype">double</span> mahal;
<a name="l01503"></a>01503   <span class="keywordtype">double</span> aux;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 
<a name="l01506"></a>01506   <span class="comment">/* get the mahalanobis distance */</span>
<a name="l01507"></a>01507 
<a name="l01508"></a>01508   mahal = calculateMahal(ID, rfID, x);
<a name="l01509"></a>01509 
<a name="l01510"></a>01510   <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l01511"></a>01511 
<a name="l01512"></a>01512   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#d751f1b6909c0124a4ca151036b28a0e">GAUSSIAN</a>:
<a name="l01513"></a>01513   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#3b712283b9c65c3898ae8872bf3ad7db">VONMISES</a>:
<a name="l01514"></a>01514   
<a name="l01515"></a>01515     <span class="keywordflow">return</span> (myExp(-0.5*mahal,USE_EXP_LOOKUP));
<a name="l01516"></a>01516 
<a name="l01517"></a>01517   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#f375534d17d8af44b0573ce6698cc8f0">BISQUARE</a>:
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="keywordflow">if</span> (mahal &gt; 1.0) {
<a name="l01520"></a>01520       <span class="keywordflow">return</span> (0.0);
<a name="l01521"></a>01521     } <span class="keywordflow">else</span> {
<a name="l01522"></a>01522       aux = 1.- mahal;
<a name="l01523"></a>01523       <span class="keywordflow">return</span> (aux * aux);
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525 
<a name="l01526"></a>01526   }
<a name="l01527"></a>01527 
<a name="l01528"></a>01528   <span class="keywordflow">return</span> FALSE;
<a name="l01529"></a>01529 
<a name="l01530"></a>01530 }
<a name="l01531"></a>01531 
<a name="l01532"></a>01532 <span class="comment">/*!*****************************************************************************</span>
<a name="l01533"></a>01533 <span class="comment"> *******************************************************************************</span>
<a name="l01534"></a>01534 <span class="comment">\note  calculateMahal</span>
<a name="l01535"></a>01535 <span class="comment">\date  Nov 3, 1992</span>
<a name="l01536"></a>01536 <span class="comment"></span>
<a name="l01537"></a>01537 <span class="comment">\remarks </span>
<a name="l01538"></a>01538 <span class="comment"></span>
<a name="l01539"></a>01539 <span class="comment">       calculates the mahalanobis distance</span>
<a name="l01540"></a>01540 <span class="comment"></span>
<a name="l01541"></a>01541 <span class="comment"></span>
<a name="l01542"></a>01542 <span class="comment"> *******************************************************************************</span>
<a name="l01543"></a>01543 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01544"></a>01544 <span class="comment"></span>
<a name="l01545"></a>01545 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l01546"></a>01546 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l01547"></a>01547 <span class="comment"> \param[in]     x     : the input vector for weights</span>
<a name="l01548"></a>01548 <span class="comment"></span>
<a name="l01549"></a>01549 <span class="comment"> ******************************************************************************/</span>
<a name="l01550"></a>01550 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l01551"></a>01551 calculateMahal(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x)
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 {
<a name="l01554"></a>01554 
<a name="l01555"></a>01555   <span class="keywordtype">int</span>    i,j,k;
<a name="l01556"></a>01556   RF    *rfptr;
<a name="l01557"></a>01557   <span class="keywordtype">int</span>    diag_only;
<a name="l01558"></a>01558   <span class="keywordtype">double</span> mahal;
<a name="l01559"></a>01559   <span class="keywordtype">double</span> aux;
<a name="l01560"></a>01560   <span class="keywordtype">int</span>    iaux;
<a name="l01561"></a>01561   Vector delta;
<a name="l01562"></a>01562 
<a name="l01563"></a>01563   <span class="comment">/* hand variables */</span>
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l01566"></a>01566   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l01567"></a>01567   delta     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].delta;
<a name="l01568"></a>01568 
<a name="l01569"></a>01569   <span class="comment">/* the distance from the center */</span>
<a name="l01570"></a>01570   vec_sub(x,rfptr-&gt;c,delta);
<a name="l01571"></a>01571 
<a name="l01572"></a>01572   <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l01573"></a>01573   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#3b712283b9c65c3898ae8872bf3ad7db">VONMISES</a>:
<a name="l01574"></a>01574     <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w; ++i) {
<a name="l01575"></a>01575       delta[i] = sqrt(1.-cos(delta[i]));
<a name="l01576"></a>01576     }
<a name="l01577"></a>01577     mahal = mat_mahal(rfptr-&gt;D,delta);
<a name="l01578"></a>01578     <span class="keywordflow">break</span>;
<a name="l01579"></a>01579 
<a name="l01580"></a>01580   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#d751f1b6909c0124a4ca151036b28a0e">GAUSSIAN</a>:
<a name="l01581"></a>01581   <span class="keywordflow">default</span>:
<a name="l01582"></a>01582     <span class="comment">/* the mahalanobis distance */</span>
<a name="l01583"></a>01583     mahal = mat_mahal(rfptr-&gt;D,delta);
<a name="l01584"></a>01584     <span class="keywordflow">break</span>;
<a name="l01585"></a>01585   }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587   <span class="keywordflow">return</span> mahal;
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 }
<a name="l01590"></a>01590 
<a name="l01591"></a>01591 <span class="comment">/*!*****************************************************************************</span>
<a name="l01592"></a>01592 <span class="comment"> *******************************************************************************</span>
<a name="l01593"></a>01593 <span class="comment">\note  updateMeanVar</span>
<a name="l01594"></a>01594 <span class="comment">\date  Sept, 1996</span>
<a name="l01595"></a>01595 <span class="comment"></span>
<a name="l01596"></a>01596 <span class="comment">\remarks </span>
<a name="l01597"></a>01597 <span class="comment"></span>
<a name="l01598"></a>01598 <span class="comment">       update the weighted mean and variance of a RF and return</span>
<a name="l01599"></a>01599 <span class="comment">       a centered input vector for regression</span>
<a name="l01600"></a>01600 <span class="comment">            </span>
<a name="l01601"></a>01601 <span class="comment">        </span>
<a name="l01602"></a>01602 <span class="comment">       NOTE: the weight w must be assigned in the RF structure already</span>
<a name="l01603"></a>01603 <span class="comment"></span>
<a name="l01604"></a>01604 <span class="comment"> *******************************************************************************</span>
<a name="l01605"></a>01605 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01606"></a>01606 <span class="comment"></span>
<a name="l01607"></a>01607 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l01608"></a>01608 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l01609"></a>01609 <span class="comment"> \param[in]     x_w   : the input vector for weights</span>
<a name="l01610"></a>01610 <span class="comment"> \param[in]     x     : the input vector for regression</span>
<a name="l01611"></a>01611 <span class="comment"> \param[out]    xmz   : x-mean_x</span>
<a name="l01612"></a>01612 <span class="comment"></span>
<a name="l01613"></a>01613 <span class="comment"> ******************************************************************************/</span>
<a name="l01614"></a>01614 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01615"></a>01615 updateMeanVar(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_w, Vector x, Vector xmz)
<a name="l01616"></a>01616 
<a name="l01617"></a>01617 {
<a name="l01618"></a>01618 
<a name="l01619"></a>01619   <span class="keywordtype">int</span>    i,j,k;
<a name="l01620"></a>01620   RF    *rfptr;
<a name="l01621"></a>01621   <span class="keywordtype">int</span>    n_in_w;
<a name="l01622"></a>01622   <span class="keywordtype">int</span>    n_in_reg;
<a name="l01623"></a>01623   <span class="keywordtype">double</span> w, lambda;
<a name="l01624"></a>01624 
<a name="l01625"></a>01625   <span class="comment">/* handy variables */</span>
<a name="l01626"></a>01626 
<a name="l01627"></a>01627   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l01628"></a>01628   n_in_w    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l01629"></a>01629   n_in_reg  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l01630"></a>01630   w         = rfptr-&gt;w;
<a name="l01631"></a>01631   lambda    = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[1],w);
<a name="l01632"></a>01632   
<a name="l01633"></a>01633   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     rfptr-&gt;mean_x_w[i] = 
<a name="l01636"></a>01636       (rfptr-&gt;sum_weights[1] * rfptr-&gt;mean_x_w[i] * lambda + x_w[i]*w) /
<a name="l01637"></a>01637       (rfptr-&gt;sum_weights[1] *lambda + w);
<a name="l01638"></a>01638 
<a name="l01639"></a>01639     rfptr-&gt;var_x_w[i] = 
<a name="l01640"></a>01640       (rfptr-&gt;sum_weights[1] * rfptr-&gt;var_x_w[i] * lambda  + 
<a name="l01641"></a>01641                    sqr(x_w[i]-rfptr-&gt;mean_x_w[i])*w)/
<a name="l01642"></a>01642       (rfptr-&gt;sum_weights[1]  * lambda + w);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   }
<a name="l01645"></a>01645 
<a name="l01646"></a>01646   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_reg; ++i) {
<a name="l01647"></a>01647 
<a name="l01648"></a>01648     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets) {
<a name="l01649"></a>01649       rfptr-&gt;mean_x_reg[i] = 
<a name="l01650"></a>01650         (rfptr-&gt;sum_weights[1] * rfptr-&gt;mean_x_reg[i] * lambda + x[i]*w) /
<a name="l01651"></a>01651         (rfptr-&gt;sum_weights[1] *lambda + w);
<a name="l01652"></a>01652     }
<a name="l01653"></a>01653       
<a name="l01654"></a>01654     rfptr-&gt;var_x_reg[i] = 
<a name="l01655"></a>01655       (rfptr-&gt;sum_weights[1] * rfptr-&gt;var_x_reg[i] * lambda  + 
<a name="l01656"></a>01656                    sqr(x[i]-rfptr-&gt;mean_x_reg[i])*w)/
<a name="l01657"></a>01657       (rfptr-&gt;sum_weights[1]  * lambda + w);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659     xmz[i] = (x[i] - rfptr-&gt;mean_x_reg[i]);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661   }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 }
<a name="l01664"></a>01664 
<a name="l01665"></a>01665 <span class="comment">/*!*****************************************************************************</span>
<a name="l01666"></a>01666 <span class="comment"> *******************************************************************************</span>
<a name="l01667"></a>01667 <span class="comment">\note  updateRegMeanVar</span>
<a name="l01668"></a>01668 <span class="comment">\date  Sept, 1996</span>
<a name="l01669"></a>01669 <span class="comment"></span>
<a name="l01670"></a>01670 <span class="comment">\remarks </span>
<a name="l01671"></a>01671 <span class="comment"></span>
<a name="l01672"></a>01672 <span class="comment">       update the weighted mean and variance of a RF for the </span>
<a name="l01673"></a>01673 <span class="comment">       dependent variables</span>
<a name="l01674"></a>01674 <span class="comment">        </span>
<a name="l01675"></a>01675 <span class="comment">       NOTE: the weight w must be assigned in the RF structure already</span>
<a name="l01676"></a>01676 <span class="comment"></span>
<a name="l01677"></a>01677 <span class="comment"> *******************************************************************************</span>
<a name="l01678"></a>01678 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01679"></a>01679 <span class="comment"></span>
<a name="l01680"></a>01680 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l01681"></a>01681 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l01682"></a>01682 <span class="comment"> \param[in]     y     : the output vector</span>
<a name="l01683"></a>01683 <span class="comment"> \param[out]    ymz   : y-mean_y</span>
<a name="l01684"></a>01684 <span class="comment"></span>
<a name="l01685"></a>01685 <span class="comment"> ******************************************************************************/</span>
<a name="l01686"></a>01686 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01687"></a>01687 updateRegMeanVar(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector y, Vector ymz)
<a name="l01688"></a>01688 
<a name="l01689"></a>01689 {
<a name="l01690"></a>01690 
<a name="l01691"></a>01691   <span class="keywordtype">int</span>    i,j,k;
<a name="l01692"></a>01692   RF    *rfptr;
<a name="l01693"></a>01693   <span class="keywordtype">int</span>    n_out;
<a name="l01694"></a>01694   <span class="keywordtype">double</span> w;
<a name="l01695"></a>01695   <span class="keywordtype">double</span> lambda;
<a name="l01696"></a>01696 
<a name="l01697"></a>01697   <span class="comment">/* handy variables */</span>
<a name="l01698"></a>01698 
<a name="l01699"></a>01699   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l01700"></a>01700   n_out     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l01701"></a>01701   w         = rfptr-&gt;w;
<a name="l01702"></a>01702   lambda    = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[1],w);
<a name="l01703"></a>01703   
<a name="l01704"></a>01704   <span class="keywordflow">for</span> (i=1; i&lt;=n_out; ++i) {
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets) {
<a name="l01707"></a>01707       rfptr-&gt;mean_y[i] = 
<a name="l01708"></a>01708         (rfptr-&gt;sum_weights[1] * rfptr-&gt;mean_y[i] * lambda + y[i]*w) /
<a name="l01709"></a>01709         (rfptr-&gt;sum_weights[1] * lambda + w);
<a name="l01710"></a>01710     }
<a name="l01711"></a>01711 
<a name="l01712"></a>01712     rfptr-&gt;var_y[i] = 
<a name="l01713"></a>01713       (rfptr-&gt;sum_weights[1] * rfptr-&gt;var_y[i] * lambda  + 
<a name="l01714"></a>01714                    sqr(y[i]-rfptr-&gt;mean_y[i])*w)/
<a name="l01715"></a>01715       (rfptr-&gt;sum_weights[1]  * lambda + w);
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     ymz[i] = (y[i] - rfptr-&gt;mean_y[i]);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719   }
<a name="l01720"></a>01720 
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 }
<a name="l01723"></a>01723 
<a name="l01724"></a>01724 <span class="comment">/*!*****************************************************************************</span>
<a name="l01725"></a>01725 <span class="comment"> *******************************************************************************</span>
<a name="l01726"></a>01726 <span class="comment">\note  updateAdmVars</span>
<a name="l01727"></a>01727 <span class="comment">\date  April 1999</span>
<a name="l01728"></a>01728 <span class="comment"></span>
<a name="l01729"></a>01729 <span class="comment">\remarks </span>
<a name="l01730"></a>01730 <span class="comment"></span>
<a name="l01731"></a>01731 <span class="comment">       updates several adminstrative variables for a receptive field.</span>
<a name="l01732"></a>01732 <span class="comment">       This function should be called last since various other update</span>
<a name="l01733"></a>01733 <span class="comment">       function require the non-updated adminstrative variables.</span>
<a name="l01734"></a>01734 <span class="comment"></span>
<a name="l01735"></a>01735 <span class="comment"> *******************************************************************************</span>
<a name="l01736"></a>01736 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01737"></a>01737 <span class="comment"></span>
<a name="l01738"></a>01738 <span class="comment"> \param[in]     ID        : lwpr ID</span>
<a name="l01739"></a>01739 <span class="comment"> \param[in]     rfID      : the rfID</span>
<a name="l01740"></a>01740 <span class="comment"></span>
<a name="l01741"></a>01741 <span class="comment"> ******************************************************************************/</span>
<a name="l01742"></a>01742 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01743"></a>01743 updateAdmVars(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l01744"></a>01744 
<a name="l01745"></a>01745 {
<a name="l01746"></a>01746 
<a name="l01747"></a>01747   <span class="keywordtype">int</span>    i;
<a name="l01748"></a>01748   RF    *rfptr;
<a name="l01749"></a>01749 
<a name="l01750"></a>01750   <span class="comment">/* handy variables */</span>
<a name="l01751"></a>01751   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l01752"></a>01752 
<a name="l01753"></a>01753   <span class="comment">/* several trace values */</span>
<a name="l01754"></a>01754   <span class="keywordflow">for</span> (i=1; i&lt;=rfptr-&gt;n_proj; ++i) {
<a name="l01755"></a>01755 
<a name="l01756"></a>01756     rfptr-&gt;sum_weights[i] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],rfptr-&gt;w)*rfptr-&gt;sum_weights[i] + rfptr-&gt;w;
<a name="l01757"></a>01757     rfptr-&gt;n_data[i]      = rfptr-&gt;lambda[i] * rfptr-&gt;n_data[i] + 1;
<a name="l01758"></a>01758 
<a name="l01759"></a>01759     <span class="comment">/* and finally update the forgetting factor lambda itself */</span>
<a name="l01760"></a>01760     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].final_lambda - rfptr-&gt;lambda[i] &gt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) {
<a name="l01761"></a>01761       rfptr-&gt;lambda[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].tau_lambda * rfptr-&gt;lambda[i] + 
<a name="l01762"></a>01762         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].final_lambda*(1.-<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].tau_lambda);
<a name="l01763"></a>01763       
<a name="l01764"></a>01764     }
<a name="l01765"></a>01765   }
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 
<a name="l01768"></a>01768 }
<a name="l01769"></a>01769 <span class="comment">/*!*****************************************************************************</span>
<a name="l01770"></a>01770 <span class="comment"> *******************************************************************************</span>
<a name="l01771"></a>01771 <span class="comment">\note  myExp</span>
<a name="l01772"></a>01772 <span class="comment">\date  Nov 3, 1992</span>
<a name="l01773"></a>01773 <span class="comment"></span>
<a name="l01774"></a>01774 <span class="comment">\remarks </span>
<a name="l01775"></a>01775 <span class="comment"></span>
<a name="l01776"></a>01776 <span class="comment">       calculates the value of exp from the lookup table</span>
<a name="l01777"></a>01777 <span class="comment">       NOTE: only negative values are tablulated, tailored for</span>
<a name="l01778"></a>01778 <span class="comment">       distance metric calculations</span>
<a name="l01779"></a>01779 <span class="comment"></span>
<a name="l01780"></a>01780 <span class="comment"></span>
<a name="l01781"></a>01781 <span class="comment"> *******************************************************************************</span>
<a name="l01782"></a>01782 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01783"></a>01783 <span class="comment"></span>
<a name="l01784"></a>01784 <span class="comment"> \param[in]     value   : the argument to exp</span>
<a name="l01785"></a>01785 <span class="comment"> \param[in]     lookup  : TRUE=use lookup table, FALSE=use normal exp()</span>
<a name="l01786"></a>01786 <span class="comment"></span>
<a name="l01787"></a>01787 <span class="comment"> ******************************************************************************/</span>
<a name="l01788"></a>01788 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l01789"></a>01789 myExp(<span class="keywordtype">double</span> value, <span class="keywordtype">int</span> lookup)
<a name="l01790"></a>01790 
<a name="l01791"></a>01791 {
<a name="l01792"></a>01792 
<a name="l01793"></a>01793   <span class="keyword">static</span> <span class="keywordtype">double</span>             *exp_array;
<a name="l01794"></a>01794   <span class="keyword">static</span> <span class="keywordtype">int</span>                 firsttime = TRUE;
<a name="l01795"></a>01795   <span class="keywordtype">int</span>    i;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797   <span class="keywordflow">if</span> (firsttime) {
<a name="l01798"></a>01798     firsttime = FALSE;
<a name="l01799"></a>01799     exp_array = (<span class="keywordtype">double</span> *) my_vector(0, 10000);
<a name="l01800"></a>01800     <span class="keywordflow">for</span> (i = 0; i &lt;= 10000; ++i) {
<a name="l01801"></a>01801       exp_array[i] = exp((<span class="keywordtype">double</span>) (-i) / 1000.);
<a name="l01802"></a>01802     }
<a name="l01803"></a>01803   }
<a name="l01804"></a>01804 
<a name="l01805"></a>01805   <span class="keywordflow">if</span> ( !lookup ) <span class="keywordflow">return</span> (exp(value));
<a name="l01806"></a>01806 
<a name="l01807"></a>01807   <span class="keywordflow">if</span> (fabs(value) &gt; 10.0) {
<a name="l01808"></a>01808     <span class="keywordflow">return</span> 0.000001;
<a name="l01809"></a>01809   } <span class="keywordflow">else</span> {
<a name="l01810"></a>01810     i = (int) fabs(value * 1000.0);
<a name="l01811"></a>01811     <span class="keywordflow">return</span> (exp_array[i]);
<a name="l01812"></a>01812   }
<a name="l01813"></a>01813 
<a name="l01814"></a>01814 }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="comment">/*!*****************************************************************************</span>
<a name="l01817"></a>01817 <span class="comment"> *******************************************************************************</span>
<a name="l01818"></a>01818 <span class="comment"> \note  calculateRegression</span>
<a name="l01819"></a>01819 <span class="comment"> \date  April 1999</span>
<a name="l01820"></a>01820 <span class="comment"> </span>
<a name="l01821"></a>01821 <span class="comment"> \remarks </span>
<a name="l01822"></a>01822 <span class="comment"> </span>
<a name="l01823"></a>01823 <span class="comment"> recursively calculates the regressions in all directions</span>
<a name="l01824"></a>01824 <span class="comment"> </span>
<a name="l01825"></a>01825 <span class="comment"> *******************************************************************************</span>
<a name="l01826"></a>01826 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l01827"></a>01827 <span class="comment"> </span>
<a name="l01828"></a>01828 <span class="comment"> \param[in]     ID       : the ID of the LWPR</span>
<a name="l01829"></a>01829 <span class="comment"> \param[in]     rfID     : the receptive field ID</span>
<a name="l01830"></a>01830 <span class="comment"> \param[in]     x_mz : the input vector (zero mean)</span>
<a name="l01831"></a>01831 <span class="comment"> \param[in]     y_mz     : the output vector (mean zero)</span>
<a name="l01832"></a>01832 <span class="comment"> </span>
<a name="l01833"></a>01833 <span class="comment"> ******************************************************************************/</span>
<a name="l01834"></a>01834 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01835"></a>01835 calculateRegression(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_mz, Vector y_mz)
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 {
<a name="l01838"></a>01838   RF       *rfptr;
<a name="l01839"></a>01839   <span class="keywordtype">int</span>       n_in_reg, n_out;
<a name="l01840"></a>01840   <span class="keywordtype">int</span>       i, j, k;
<a name="l01841"></a>01841   <span class="keywordtype">int</span>       n_proj;
<a name="l01842"></a>01842   <span class="keywordtype">double</span>    aux;
<a name="l01843"></a>01843   <span class="keywordtype">double</span>    sum_val;
<a name="l01844"></a>01844   <span class="keywordtype">double</span>   *xres;
<a name="l01845"></a>01845   <span class="keywordtype">double</span>   *yres;
<a name="l01846"></a>01846   <span class="keywordtype">double</span>    s;
<a name="l01847"></a>01847   <span class="keywordtype">double</span>   *ypred;
<a name="l01848"></a>01848   <span class="keywordtype">double</span>    w;
<a name="l01849"></a>01849   <span class="keywordtype">double</span>    y_partial;
<a name="l01850"></a>01850   <span class="keywordtype">double</span>  **error_cv;
<a name="l01851"></a>01851   <span class="keywordtype">double</span>  **error;
<a name="l01852"></a>01852   <span class="keywordtype">double</span>   *xproj;
<a name="l01853"></a>01853   Vector    cr;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855   rfptr    = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l01856"></a>01856   n_in_reg =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l01857"></a>01857   n_out    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l01858"></a>01858   n_proj   =  rfptr-&gt;n_proj;
<a name="l01859"></a>01859   xres     =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xres;
<a name="l01860"></a>01860   yres     =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].yres;
<a name="l01861"></a>01861   w        =  rfptr-&gt;w;
<a name="l01862"></a>01862   ypred    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].ypred;
<a name="l01863"></a>01863   error_cv =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv;
<a name="l01864"></a>01864   error    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error;
<a name="l01865"></a>01865   xproj    =  rfptr-&gt;s;
<a name="l01866"></a>01866   cr       =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].cr;
<a name="l01867"></a>01867 
<a name="l01868"></a>01868   <span class="comment">/* prepare residual variables */</span>
<a name="l01869"></a>01869 
<a name="l01870"></a>01870   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_reg; ++i)
<a name="l01871"></a>01871 #<span class="keywordflow">if</span> <a class="code" href="lwpr_8c.html#959b3abf0f46a44251fd75b173360097" title="sphering of local model distribution TRUE/FALSE">SPHERING</a>
<a name="l01872"></a>01872     xres[i] = x_mz[i]/(sqrt(rfptr-&gt;var_x_reg[i])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l01873"></a>01873 <span class="preprocessor">#else</span>
<a name="l01874"></a>01874 <span class="preprocessor"></span>    xres[i] = x_mz[i];
<a name="l01875"></a>01875 <span class="preprocessor">#endif</span>
<a name="l01876"></a>01876 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=1; i&lt;=n_out; ++i) {
<a name="l01877"></a>01877     yres[i]  = y_mz[i];
<a name="l01878"></a>01878     ypred[i] = rfptr-&gt;mean_y[i];
<a name="l01879"></a>01879   }
<a name="l01880"></a>01880 
<a name="l01881"></a>01881   <span class="comment">/* loop over all regression outputs, find the projections, and update</span>
<a name="l01882"></a>01882 <span class="comment">     the regression parameters */</span>
<a name="l01883"></a>01883   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) {
<a name="l01884"></a>01884 
<a name="l01885"></a>01885     <span class="comment">/* project the input onto the projection vector *before* updating the</span>
<a name="l01886"></a>01886 <span class="comment">       projections: this is like "synchronous" update for PLS while </span>
<a name="l01887"></a>01887 <span class="comment">       classical PLS is asynchonous -- but synchronous updates keep</span>
<a name="l01888"></a>01888 <span class="comment">       cross validation for PLS cleaner */</span>
<a name="l01889"></a>01889     s=0.0;
<a name="l01890"></a>01890     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j)
<a name="l01891"></a>01891       s += rfptr-&gt;W[i][j]*xres[j];
<a name="l01892"></a>01892 
<a name="l01893"></a>01893     <span class="comment">/* update the projection direction; NOTE: this is not the proper</span>
<a name="l01894"></a>01894 <span class="comment">       version for multivariate outputs, but rather a quick and dirty</span>
<a name="l01895"></a>01895 <span class="comment">       version. Multivariate outputs are not recommended in any of the </span>
<a name="l01896"></a>01896 <span class="comment">       LWPR methods, and in particular not in PLS */</span>
<a name="l01897"></a>01897 
<a name="l01898"></a>01898     sum_val = 0.0;
<a name="l01899"></a>01899     for (j=1; j&lt;=n_in_reg; ++j) {
<a name="l01900"></a>01900       cr[j] = 0.0;
<a name="l01901"></a>01901       <span class="keywordflow">for</span> (k=1; k&lt;=n_out; ++k) {
<a name="l01902"></a>01902         cr[j] += xres[j]*yres[k];
<a name="l01903"></a>01903       }
<a name="l01904"></a>01904       <span class="comment">/* NOTE: for nonstationary learning problems, it turns out to be</span>
<a name="l01905"></a>01905 <span class="comment">         useful if the projections change a bit more slowly than the</span>
<a name="l01906"></a>01906 <span class="comment">         regression -- thus the weird formula below for lambda */</span>
<a name="l01907"></a>01907       rfptr-&gt;SXresYres[i][j] = 
<a name="l01908"></a>01908         <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>((1.-(1.-rfptr-&gt;lambda[i])/10.),w) * rfptr-&gt;SXresYres[i][j] + w * cr[j];
<a name="l01909"></a>01909       sum_val += sqr(rfptr-&gt;SXresYres[i][j]);
<a name="l01910"></a>01910     }
<a name="l01911"></a>01911     sum_val = sqrt(sum_val)+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l01912"></a>01912     rfptr-&gt;Wnorm[i] = sum_val;
<a name="l01913"></a>01913 
<a name="l01914"></a>01914     <span class="comment">/* normalize this direction */</span>
<a name="l01915"></a>01915     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j)
<a name="l01916"></a>01916       rfptr-&gt;W[i][j] = rfptr-&gt;SXresYres[i][j]/sum_val;
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     <span class="comment">/* update sufficient statistics for regression based on this projection */</span>
<a name="l01919"></a>01919     rfptr-&gt;ss2[i] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) * rfptr-&gt;ss2[i] + sqr(s) * w;
<a name="l01920"></a>01920     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l01921"></a>01921       rfptr-&gt;SSYres[i][j] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) * rfptr-&gt;SSYres[i][j] +  
<a name="l01922"></a>01922         w * yres[j] * s;
<a name="l01923"></a>01923     }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925     <span class="comment">/* update the regression parameters for this dimension and predict</span>
<a name="l01926"></a>01926 <span class="comment">       the outputs */</span>
<a name="l01927"></a>01927     aux = 0;
<a name="l01928"></a>01928     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l01929"></a>01929 
<a name="l01930"></a>01930       <span class="comment">/* the cross validation error at this regression stage */</span>
<a name="l01931"></a>01931       y_partial      = rfptr-&gt;B[i][j]*s;
<a name="l01932"></a>01932       error_cv[i][j] = yres[j] - y_partial;
<a name="l01933"></a>01933       ypred[j]      += y_partial;
<a name="l01934"></a>01934       yres[j]       -= y_partial;
<a name="l01935"></a>01935       aux           += sqr(error_cv[i][j]);
<a name="l01936"></a>01936 
<a name="l01937"></a>01937       <span class="comment">/* update the local model */</span>
<a name="l01938"></a>01938       rfptr-&gt;B[i][j] = rfptr-&gt;SSYres[i][j]/rfptr-&gt;ss2[i];
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 
<a name="l01941"></a>01941     }
<a name="l01942"></a>01942     aux /= (double)n_out;  <span class="comment">/* the mean squared cv error accross all outputs */</span>
<a name="l01943"></a>01943 
<a name="l01944"></a>01944     <span class="comment">/* update the sum_error term: this is a sum of CV terms */</span>
<a name="l01945"></a>01945     rfptr-&gt;sum_error_cvi[i]   = rfptr-&gt;sum_error_cvi[i] * <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) + w * aux;
<a name="l01946"></a>01946 
<a name="l01947"></a>01947     <span class="comment">/* the total CV error of the RF needs to be accumulated separately as</span>
<a name="l01948"></a>01948 <span class="comment">       individual projections have different life times */</span>
<a name="l01949"></a>01949     <span class="keywordflow">if</span> (i==n_proj)
<a name="l01950"></a>01950       rfptr-&gt;sum_error_cv   = rfptr-&gt;sum_error_cv * <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[1],w) + w * aux;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952     <span class="comment">/* the regression parameters on the inputs variables and</span>
<a name="l01953"></a>01953 <span class="comment">       prepare the variables for the next iteration */</span>
<a name="l01954"></a>01954     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l01955"></a>01955       rfptr-&gt;SSXres[i][j] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) * rfptr-&gt;SSXres[i][j] +  
<a name="l01956"></a>01956         w * xres[j] * s;
<a name="l01957"></a>01957       xres[j] -= rfptr-&gt;U[i][j]*s;
<a name="l01958"></a>01958       rfptr-&gt;U[i][j] = rfptr-&gt;SSXres[i][j]/rfptr-&gt;ss2[i];
<a name="l01959"></a>01959     }
<a name="l01960"></a>01960     
<a name="l01961"></a>01961   }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963   <span class="comment">/* finally calulate the predicted regression output *after* updating */</span>
<a name="l01964"></a>01964   <span class="keywordflow">for</span> (i=1; i&lt;=n_out; ++i) {
<a name="l01965"></a>01965     yres[i]  = y_mz[i];
<a name="l01966"></a>01966     ypred[i] = rfptr-&gt;mean_y[i];
<a name="l01967"></a>01967   }
<a name="l01968"></a>01968   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_reg; ++i)
<a name="l01969"></a>01969 #<span class="keywordflow">if</span> <a class="code" href="lwpr_8c.html#959b3abf0f46a44251fd75b173360097" title="sphering of local model distribution TRUE/FALSE">SPHERING</a>
<a name="l01970"></a>01970     xres[i] = x_mz[i]/(sqrt(rfptr-&gt;var_x_reg[i])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l01971"></a>01971 <span class="preprocessor">#else</span>
<a name="l01972"></a>01972 <span class="preprocessor"></span>    xres[i] = x_mz[i];
<a name="l01973"></a>01973 <span class="preprocessor">#endif</span>
<a name="l01974"></a>01974 <span class="preprocessor"></span>
<a name="l01975"></a>01975   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) {
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     s=0.0;
<a name="l01978"></a>01978     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j)
<a name="l01979"></a>01979       s += rfptr-&gt;W[i][j]*xres[j];
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     xproj[i] = s;
<a name="l01982"></a>01982 
<a name="l01983"></a>01983     <span class="comment">/* update the local degree of freedoms */</span>
<a name="l01984"></a>01984     rfptr-&gt;dof[i] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) * rfptr-&gt;dof[i] + 
<a name="l01985"></a>01985       sqr(w)*sqr(s)/rfptr-&gt;ss2[i];
<a name="l01986"></a>01986 
<a name="l01987"></a>01987     <span class="comment">/* compute the predicted output */</span>
<a name="l01988"></a>01988     aux = 0;
<a name="l01989"></a>01989     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l01990"></a>01990       <span class="comment">/* the non-CV error at this regression stage */</span>
<a name="l01991"></a>01991       y_partial   = rfptr-&gt;B[i][j]*s;
<a name="l01992"></a>01992       error[i][j] = yres[j] - y_partial;
<a name="l01993"></a>01993       ypred[j]   += y_partial;
<a name="l01994"></a>01994       yres[j]    -= y_partial;
<a name="l01995"></a>01995       aux        += sqr(error[i][j]);
<a name="l01996"></a>01996     }
<a name="l01997"></a>01997     aux /= (double)n_out;  <span class="comment">/* the mean squared error accross all outputs */</span>
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     <span class="comment">/* update the sum_error term: this is a sum of NON-CV terms */</span>
<a name="l02000"></a>02000     rfptr-&gt;sum_error[i]   = rfptr-&gt;sum_error[i] * <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) + w * aux;
<a name="l02001"></a>02001 
<a name="l02002"></a>02002     <span class="comment">/* update the residual input for the next iteration */</span>
<a name="l02003"></a>02003     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02004"></a>02004       xres[j] -= rfptr-&gt;U[i][j]*s;
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007   }
<a name="l02008"></a>02008 
<a name="l02009"></a>02009   <span class="keywordflow">if</span> (rfptr-&gt;n_data[1] &gt; 2*n_in_reg)
<a name="l02010"></a>02010     rfptr-&gt;trustworthy = TRUE; 
<a name="l02011"></a>02011 
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 }
<a name="l02014"></a>02014 
<a name="l02015"></a>02015 <span class="comment">/*!*****************************************************************************</span>
<a name="l02016"></a>02016 <span class="comment"> *******************************************************************************</span>
<a name="l02017"></a>02017 <span class="comment"> \note  predictLWPROutput</span>
<a name="l02018"></a>02018 <span class="comment"> \date  January, 1994</span>
<a name="l02019"></a>02019 <span class="comment"> </span>
<a name="l02020"></a>02020 <span class="comment"> \remarks </span>
<a name="l02021"></a>02021 <span class="comment"> </span>
<a name="l02022"></a>02022 <span class="comment"> generates a prediction from a given input</span>
<a name="l02023"></a>02023 <span class="comment"> </span>
<a name="l02024"></a>02024 <span class="comment"> *******************************************************************************</span>
<a name="l02025"></a>02025 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02026"></a>02026 <span class="comment"> </span>
<a name="l02027"></a>02027 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02028"></a>02028 <span class="comment"> \param[in]     x_w    : the input vector for weights</span>
<a name="l02029"></a>02029 <span class="comment"> \param[in]     x      : the input vector for regression</span>
<a name="l02030"></a>02030 <span class="comment"> \param[in]     cutoff : a number between [0,1] which indicates at which threshold</span>
<a name="l02031"></a>02031 <span class="comment">             a receptive field is not used for averaging anymore</span>
<a name="l02032"></a>02032 <span class="comment"> \param[in]     blend  : blend predictions or use max only </span>
<a name="l02033"></a>02033 <span class="comment"> \param[out]    y      : the output vector</span>
<a name="l02034"></a>02034 <span class="comment"> \param[in,out] rfID   : the rf for the neighborhood for input, returns the max activated rf </span>
<a name="l02035"></a>02035 <span class="comment"></span>
<a name="l02036"></a>02036 <span class="comment"> returns the max activation contributing to this output</span>
<a name="l02037"></a>02037 <span class="comment"> </span>
<a name="l02038"></a>02038 <span class="comment"> ******************************************************************************/</span>
<a name="l02039"></a>02039 <span class="keywordtype">double</span>
<a name="l02040"></a><a class="code" href="lwpr_8h.html#eddc4028a5d930fe026ff3e678463e3c">02040</a> <a class="code" href="lwpr_8c.html#eddc4028a5d930fe026ff3e678463e3c">predictLWPROutputConf</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x_w, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> cutoff, 
<a name="l02041"></a>02041                   <span class="keywordtype">int</span> blend, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> *rfID, <span class="keywordtype">double</span> *conf)
<a name="l02042"></a>02042 {
<a name="l02043"></a>02043   <span class="keywordtype">int</span> i;
<a name="l02044"></a>02044   <span class="keywordtype">double</span> rc;
<a name="l02045"></a>02045 
<a name="l02046"></a>02046   rc = predictLWPROutput(ID, x_w, x, cutoff, blend, y, rfID);
<a name="l02047"></a>02047   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out; ++i)
<a name="l02048"></a>02048     conf[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_conf[i];
<a name="l02049"></a>02049   
<a name="l02050"></a>02050   <span class="keywordflow">return</span> rc;
<a name="l02051"></a>02051 
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="keywordtype">double</span>
<a name="l02055"></a>02055 predictLWPROutput(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x_w, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> cutoff, 
<a name="l02056"></a>02056                   <span class="keywordtype">int</span> blend, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> *rfID)
<a name="l02057"></a>02057      
<a name="l02058"></a>02058 {
<a name="l02059"></a>02059   
<a name="l02060"></a>02060   <span class="keywordtype">int</span>     i,j,k,n,r;
<a name="l02061"></a>02061   <span class="keywordtype">double</span>  max_activation = 0;
<a name="l02062"></a>02062   <span class="keywordtype">double</span>  sum_w = 0;
<a name="l02063"></a>02063   <span class="keywordtype">double</span>  w=0.;
<a name="l02064"></a>02064   <span class="keywordtype">int</span>     n_in_w;
<a name="l02065"></a>02065   <span class="keywordtype">int</span>     n_in_reg;
<a name="l02066"></a>02066   <span class="keywordtype">int</span>     n_proj;
<a name="l02067"></a>02067   <span class="keywordtype">int</span>     n_rf;
<a name="l02068"></a>02068   <span class="keywordtype">int</span>     n_out;
<a name="l02069"></a>02069   <span class="keywordtype">int</span>     index_max= -999;
<a name="l02070"></a>02070   RF     *rfptr;
<a name="l02071"></a>02071   <span class="keywordtype">int</span>     count_rf=0;
<a name="l02072"></a>02072   LWPR    *s;
<a name="l02073"></a>02073   <span class="keywordtype">double</span>  x_proj;
<a name="l02074"></a>02074   Vector  xres;
<a name="l02075"></a>02075   <span class="keywordtype">double</span>  aux;
<a name="l02076"></a>02076   <span class="keywordtype">double</span>  dofs;
<a name="l02077"></a>02077 
<a name="l02078"></a>02078   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l02079"></a>02079     <span class="keywordflow">return</span> FALSE;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l02082"></a>02082   n_in_w    = s-&gt;n_in_w;
<a name="l02083"></a>02083   n_in_reg  = s-&gt;n_in_reg;
<a name="l02084"></a>02084   n_out     = s-&gt;n_out;
<a name="l02085"></a>02085   n_rf      = s-&gt;n_rf;
<a name="l02086"></a>02086   xres      = s-&gt;x_tempp;
<a name="l02087"></a>02087 
<a name="l02088"></a>02088   <span class="comment">/* normalize the query point */</span>
<a name="l02089"></a>02089   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02090"></a>02090     s-&gt;xp[j] = x[j]/s-&gt;norm_in_reg[j];
<a name="l02091"></a>02091   }
<a name="l02092"></a>02092 
<a name="l02093"></a>02093   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_w; ++j) {
<a name="l02094"></a>02094     s-&gt;xp_w[j] = x_w[j]/s-&gt;norm_in_w[j];
<a name="l02095"></a>02095   }
<a name="l02096"></a>02096 
<a name="l02097"></a>02097   <span class="comment">/* reset the y[j] here since we sum over them */</span>
<a name="l02098"></a>02098   <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02099"></a>02099     y[j] = 0.0;
<a name="l02100"></a>02100     s-&gt;y_predicted[j]  = 0.0;
<a name="l02101"></a>02101     s-&gt;y_predicted2[j] = 0.0;
<a name="l02102"></a>02102     s-&gt;y_conf[j] = 0.0;
<a name="l02103"></a>02103   }
<a name="l02104"></a>02104 
<a name="l02105"></a>02105   <span class="comment">/* if there are no receptive fields */</span>
<a name="l02106"></a>02106   <span class="keywordflow">if</span> (n_rf == 0)
<a name="l02107"></a>02107     <span class="keywordflow">return</span> max_activation;
<a name="l02108"></a>02108   
<a name="l02109"></a>02109   <span class="comment">/* scan the receptive fields */</span>
<a name="l02110"></a>02110 
<a name="l02111"></a>02111   <span class="keywordflow">for</span> (r=1; r&lt;=n_rf; ++r) {
<a name="l02112"></a>02112 
<a name="l02113"></a>02113     <span class="comment">/* fudge in the nearest neighbor lookup */</span>
<a name="l02114"></a>02114     <span class="keywordflow">if</span> (s-&gt;use_nn &amp;&amp; *rfID &gt; 0 &amp;&amp; *rfID &lt;= n_rf) {
<a name="l02115"></a>02115       <span class="keywordflow">if</span> ( (r &gt; s-&gt;max_nn_comp &amp;&amp; max_activation &gt; cutoff) || 
<a name="l02116"></a>02116            r &gt; s-&gt;rfs[*rfID].n_nn)
<a name="l02117"></a>02117         <span class="keywordflow">break</span>;
<a name="l02118"></a>02118       i = s-&gt;rfs[*rfID].nn[r];
<a name="l02119"></a>02119     } <span class="keywordflow">else</span> {
<a name="l02120"></a>02120       i = r;
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122   
<a name="l02123"></a>02123     rfptr     = &amp;s-&gt;rfs[i];
<a name="l02124"></a>02124     n_proj    = rfptr-&gt;n_proj;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="keywordflow">if</span> (!rfptr-&gt;trustworthy) <span class="keywordflow">continue</span>;
<a name="l02127"></a>02127     
<a name="l02128"></a>02128     <span class="comment">/* the mean subtracted input  */</span>
<a name="l02129"></a>02129     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02130"></a>02130       s-&gt;x_mzp[j] = s-&gt;xp[j] - rfptr-&gt;mean_x_reg[j];
<a name="l02131"></a>02131     }
<a name="l02132"></a>02132     
<a name="l02133"></a>02133     <span class="comment">/* generate the weight for this RF */</span>
<a name="l02134"></a>02134     rfptr-&gt;ww = w = calculateWeightp(ID,i,s-&gt;xp_w);
<a name="l02135"></a>02135 
<a name="l02136"></a>02136     <span class="keywordflow">if</span> (w &gt; max_activation) {
<a name="l02137"></a>02137       max_activation = w;
<a name="l02138"></a>02138       index_max = i;
<a name="l02139"></a>02139     }
<a name="l02140"></a>02140 
<a name="l02141"></a>02141     <span class="keywordflow">if</span> (w &gt; cutoff &amp;&amp; blend) {
<a name="l02142"></a>02142 
<a name="l02143"></a>02143       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02144"></a>02144 <span class="preprocessor">#if SPHERING</span>
<a name="l02145"></a>02145 <span class="preprocessor"></span>        xres[j] = s-&gt;x_mzp[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l02146"></a>02146 <span class="preprocessor">#else</span>
<a name="l02147"></a>02147 <span class="preprocessor"></span>        xres[j] = s-&gt;x_mzp[j];
<a name="l02148"></a>02148 <span class="preprocessor">#endif</span>
<a name="l02149"></a>02149 <span class="preprocessor"></span>      }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151       <span class="comment">/* add the constant part */</span>
<a name="l02152"></a>02152       <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02153"></a>02153         aux = rfptr-&gt;mean_y[j];
<a name="l02154"></a>02154         s-&gt;y_predicted[j] = aux; 
<a name="l02155"></a>02155         y[j] += aux * w;
<a name="l02156"></a>02156       }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 
<a name="l02159"></a>02159       <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02160"></a>02160 
<a name="l02161"></a>02161         <span class="comment">/* project the input onto the current projection */</span>
<a name="l02162"></a>02162         x_proj = vec_mult_inner_size(xres,rfptr-&gt;W[k],n_in_reg);
<a name="l02163"></a>02163         
<a name="l02164"></a>02164         <span class="comment">/* do single variate prediction */</span>
<a name="l02165"></a>02165         <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02166"></a>02166           aux   = x_proj * rfptr-&gt;B[k][j];
<a name="l02167"></a>02167           y[j] += aux * w;
<a name="l02168"></a>02168           s-&gt;y_predicted[j] += aux;
<a name="l02169"></a>02169         }
<a name="l02170"></a>02170         
<a name="l02171"></a>02171         <span class="comment">/* adjust the input data */</span>
<a name="l02172"></a>02172         <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02173"></a>02173           xres[j] -= x_proj * rfptr-&gt;U[k][j];
<a name="l02174"></a>02174         }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176       }
<a name="l02177"></a>02177       
<a name="l02178"></a>02178       <span class="comment">/* prepare summary statistics and confidence intervals */</span>
<a name="l02179"></a>02179       sum_w += w;
<a name="l02180"></a>02180       <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02181"></a>02181         s-&gt;y_predicted2[j] += sqr(s-&gt;y_predicted[j]) * w;
<a name="l02182"></a>02182         dofs = rfptr-&gt;sum_weights[1];
<a name="l02183"></a>02183         aux  = 1;
<a name="l02184"></a>02184         <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02185"></a>02185           dofs -= rfptr-&gt;dof[k];
<a name="l02186"></a>02186           aux  += sqr(rfptr-&gt;s[k])/rfptr-&gt;ss2[k] * w;
<a name="l02187"></a>02187         }
<a name="l02188"></a>02188         <span class="keywordflow">if</span> (dofs &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>)
<a name="l02189"></a>02189           dofs = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l02190"></a>02190         s-&gt;y_conf[j] += w * rfptr-&gt;sum_error[n_proj]/dofs*aux;
<a name="l02191"></a>02191       }
<a name="l02192"></a>02192       ++count_rf;
<a name="l02193"></a>02193 
<a name="l02194"></a>02194     }
<a name="l02195"></a>02195 
<a name="l02196"></a>02196   }
<a name="l02197"></a>02197 
<a name="l02198"></a>02198 
<a name="l02199"></a>02199   <span class="comment">/* finish up */</span>
<a name="l02200"></a>02200 
<a name="l02201"></a>02201   <span class="keywordflow">if</span> (blend) {
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     <span class="keywordflow">if</span> (sum_w &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) 
<a name="l02204"></a>02204       sum_w = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l02205"></a>02205 
<a name="l02206"></a>02206     <span class="keywordflow">for</span> (i=1; i&lt;=n_out; ++i) {
<a name="l02207"></a>02207       y[i] = y[i]/sum_w;
<a name="l02208"></a>02208       aux = fabs(s-&gt;y_predicted2[i]/sum_w - sqr(y[i]))/sum_w;
<a name="l02209"></a>02209       s-&gt;y_conf[i] = sqrt(s-&gt;y_conf[i]/sqr(sum_w)+aux);
<a name="l02210"></a>02210 
<a name="l02211"></a>02211       <span class="comment">/* add output normalization */</span>
<a name="l02212"></a>02212       y[i] *= s-&gt;norm_out[i];
<a name="l02213"></a>02213       s-&gt;y_conf[i] *= s-&gt;norm_out[i];
<a name="l02214"></a>02214     }
<a name="l02215"></a>02215     
<a name="l02216"></a>02216   } <span class="keywordflow">else</span> {
<a name="l02217"></a>02217     
<a name="l02218"></a>02218     <span class="comment">/* predict y from the max activated rf */</span>
<a name="l02219"></a>02219     rfptr = &amp;s-&gt;rfs[index_max];
<a name="l02220"></a>02220     n_proj = rfptr-&gt;n_proj;
<a name="l02221"></a>02221 
<a name="l02222"></a>02222     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02223"></a>02223       s-&gt;x_mzp[j] = s-&gt;xp[j] - rfptr-&gt;mean_x_reg[j];
<a name="l02224"></a>02224 <span class="preprocessor">#if SPHERING</span>
<a name="l02225"></a>02225 <span class="preprocessor"></span>      xres[j] = s-&gt;x_mzp[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l02226"></a>02226 <span class="preprocessor">#else</span>
<a name="l02227"></a>02227 <span class="preprocessor"></span>      xres[j] = s-&gt;x_mzp[j];
<a name="l02228"></a>02228 <span class="preprocessor">#endif</span>
<a name="l02229"></a>02229 <span class="preprocessor"></span>    }
<a name="l02230"></a>02230 
<a name="l02231"></a>02231     <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02232"></a>02232       
<a name="l02233"></a>02233       <span class="comment">/* project the input onto the current projection */</span>
<a name="l02234"></a>02234       x_proj = vec_mult_inner_size(xres,rfptr-&gt;W[k],n_in_reg);
<a name="l02235"></a>02235       
<a name="l02236"></a>02236       <span class="comment">/* do single variate prediction */</span>
<a name="l02237"></a>02237       <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02238"></a>02238         y[j] += x_proj * rfptr-&gt;B[k][j];
<a name="l02239"></a>02239       }
<a name="l02240"></a>02240       
<a name="l02241"></a>02241       <span class="comment">/* adjust the input data */</span>
<a name="l02242"></a>02242       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02243"></a>02243         xres[j] -= x_proj * rfptr-&gt;U[k][j];
<a name="l02244"></a>02244       }
<a name="l02245"></a>02245     
<a name="l02246"></a>02246     }
<a name="l02247"></a>02247     
<a name="l02248"></a>02248     <span class="comment">/* add the constant part and compute confidence interval */</span>
<a name="l02249"></a>02249     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02250"></a>02250       y[j] = (y[j] + rfptr-&gt;mean_y[j])*s-&gt;norm_out[j]; 
<a name="l02251"></a>02251 
<a name="l02252"></a>02252       dofs = rfptr-&gt;sum_weights[1];
<a name="l02253"></a>02253       aux  = 1;
<a name="l02254"></a>02254       for (k=1; k&lt;=n_proj; ++k) {
<a name="l02255"></a>02255         dofs -= rfptr-&gt;dof[k];
<a name="l02256"></a>02256         aux  += sqr(rfptr-&gt;s[k])/rfptr-&gt;ss2[k] * w;
<a name="l02257"></a>02257       }
<a name="l02258"></a>02258       <span class="keywordflow">if</span> (dofs &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) 
<a name="l02259"></a>02259         dofs = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l02260"></a>02260       s-&gt;y_conf[j] = rfptr-&gt;sum_error[n_proj]/dofs*aux/w;
<a name="l02261"></a>02261     }
<a name="l02262"></a>02262 
<a name="l02263"></a>02263     <span class="keywordflow">if</span> (!s-&gt;rfs[index_max].trustworthy) max_activation = 0;
<a name="l02264"></a>02264     
<a name="l02265"></a>02265   }
<a name="l02266"></a>02266 
<a name="l02267"></a>02267   *rfID = index_max;
<a name="l02268"></a>02268 
<a name="l02269"></a>02269   <span class="keywordflow">return</span> max_activation;
<a name="l02270"></a>02270 
<a name="l02271"></a>02271 }
<a name="l02272"></a>02272 
<a name="l02273"></a>02273 <span class="comment">/*!*****************************************************************************</span>
<a name="l02274"></a>02274 <span class="comment"> *******************************************************************************</span>
<a name="l02275"></a>02275 <span class="comment"> \note  predictLWPROutputPart</span>
<a name="l02276"></a>02276 <span class="comment"> \date  January, 1994</span>
<a name="l02277"></a>02277 <span class="comment"> </span>
<a name="l02278"></a>02278 <span class="comment"> \remarks </span>
<a name="l02279"></a>02279 <span class="comment"> </span>
<a name="l02280"></a>02280 <span class="comment"> generates a prediction from a given input, but does not generate the total</span>
<a name="l02281"></a>02281 <span class="comment"> output. Instead, the output for each output dimensions is partitioned such</span>
<a name="l02282"></a>02282 <span class="comment"> into y1,  y2, y3 ..... Paritioning is decided based on an index</span>
<a name="l02283"></a>02283 <span class="comment"> matrix that creates paritions according to the information in each of its</span>
<a name="l02284"></a>02284 <span class="comment"> rows, e.g.:</span>
<a name="l02285"></a>02285 <span class="comment"></span>
<a name="l02286"></a>02286 <span class="comment"> row1: 1 1 1 0 0 0 1 means that there are coefficients 1-3 and 7 contribute</span>
<a name="l02287"></a>02287 <span class="comment">                     to the results.</span>
<a name="l02288"></a>02288 <span class="comment"></span>
<a name="l02289"></a>02289 <span class="comment"> Note that each row is d+1 elements long, indices starting at 1, and the d+1-th</span>
<a name="l02290"></a>02290 <span class="comment"> element denoting the constant part of the regression</span>
<a name="l02291"></a>02291 <span class="comment"></span>
<a name="l02292"></a>02292 <span class="comment"> </span>
<a name="l02293"></a>02293 <span class="comment"> *******************************************************************************</span>
<a name="l02294"></a>02294 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02295"></a>02295 <span class="comment"> </span>
<a name="l02296"></a>02296 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02297"></a>02297 <span class="comment"> \param[in]     x_w    : the input vector for weights</span>
<a name="l02298"></a>02298 <span class="comment"> \param[in]     x      : the input vector for regression</span>
<a name="l02299"></a>02299 <span class="comment"> \param[in]     cutoff : a number between [0,1] which indicates at which threshold</span>
<a name="l02300"></a>02300 <span class="comment">             a receptive field is not used for averaging anymore</span>
<a name="l02301"></a>02301 <span class="comment"> \param[in]     blend  : blend predictions or use max only </span>
<a name="l02302"></a>02302 <span class="comment"> \param[in]     n_part : number of partitions (=number of rows in partition matrix)</span>
<a name="l02303"></a>02303 <span class="comment"> \param[in]     partmat: partition matrix</span>
<a name="l02304"></a>02304 <span class="comment"> \param[out]    y      : the output **matrix** (one column for every partition)</span>
<a name="l02305"></a>02305 <span class="comment"> \param[in,out] rfID   : the rf for the neighborhood for input, returns the max activated rf </span>
<a name="l02306"></a>02306 <span class="comment"></span>
<a name="l02307"></a>02307 <span class="comment"> returns the max activation contributing to this output</span>
<a name="l02308"></a>02308 <span class="comment"> </span>
<a name="l02309"></a>02309 <span class="comment"> ******************************************************************************/</span>
<a name="l02310"></a>02310 <span class="keywordtype">double</span>
<a name="l02311"></a><a class="code" href="lwpr_8c.html#294510baf02273d888bda26effdba614">02311</a> <a class="code" href="lwpr_8c.html#294510baf02273d888bda26effdba614">predictLWPROutputPart</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x_w, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> cutoff, <span class="keywordtype">int</span> blend, <span class="keywordtype">int</span> n_part,
<a name="l02312"></a>02312                       <span class="keywordtype">int</span> **partmat, <span class="keywordtype">double</span> **y, <span class="keywordtype">int</span> *rfID)
<a name="l02313"></a>02313      
<a name="l02314"></a>02314 {
<a name="l02315"></a>02315   <span class="keywordtype">int</span>     i,j,k,n,r,m;
<a name="l02316"></a>02316   <span class="keywordtype">double</span>  max_activation = 0;
<a name="l02317"></a>02317   <span class="keywordtype">double</span>  sum_w = 0;
<a name="l02318"></a>02318   <span class="keywordtype">double</span>  w=0.;
<a name="l02319"></a>02319   <span class="keywordtype">int</span>     n_in_w;
<a name="l02320"></a>02320   <span class="keywordtype">int</span>     n_in_reg;
<a name="l02321"></a>02321   <span class="keywordtype">int</span>     n_proj;
<a name="l02322"></a>02322   <span class="keywordtype">int</span>     n_rf;
<a name="l02323"></a>02323   <span class="keywordtype">int</span>     n_out;
<a name="l02324"></a>02324   <span class="keywordtype">int</span>     index_max= -999;
<a name="l02325"></a>02325   RF     *rfptr=NULL;
<a name="l02326"></a>02326   <span class="keywordtype">int</span>     count_rf=0;
<a name="l02327"></a>02327   LWPR    *s;
<a name="l02328"></a>02328   <span class="keywordtype">double</span>  x_proj;
<a name="l02329"></a>02329   Vector  xres;
<a name="l02330"></a>02330   Vector  y_mean_p;
<a name="l02331"></a>02331 
<a name="l02332"></a>02332   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l02333"></a>02333     <span class="keywordflow">return</span> FALSE;
<a name="l02334"></a>02334 
<a name="l02335"></a>02335   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l02336"></a>02336   n_in_w    = s-&gt;n_in_w;
<a name="l02337"></a>02337   n_in_reg  = s-&gt;n_in_reg;
<a name="l02338"></a>02338   n_out     = s-&gt;n_out;
<a name="l02339"></a>02339   n_rf      = s-&gt;n_rf;
<a name="l02340"></a>02340   xres      = s-&gt;x_tempp;
<a name="l02341"></a>02341   y_mean_p  = s-&gt;y_mean_predicted;
<a name="l02342"></a>02342 
<a name="l02343"></a>02343   <span class="comment">/* normalize the query point */</span>
<a name="l02344"></a>02344   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02345"></a>02345     s-&gt;xp[j] = x[j]/s-&gt;norm_in_reg[j];
<a name="l02346"></a>02346   }
<a name="l02347"></a>02347 
<a name="l02348"></a>02348   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_w; ++j) {
<a name="l02349"></a>02349     s-&gt;xp_w[j] = x_w[j]/s-&gt;norm_in_w[j];
<a name="l02350"></a>02350   }
<a name="l02351"></a>02351 
<a name="l02352"></a>02352   <span class="comment">/* reset the y[j] here since we sum over them */</span>
<a name="l02353"></a>02353   <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02354"></a>02354     y_mean_p[j] = 0;
<a name="l02355"></a>02355     <span class="keywordflow">for</span> (m=1; m&lt;=n_part; ++m) 
<a name="l02356"></a>02356       y[j][m] = 0.0;
<a name="l02357"></a>02357   }
<a name="l02358"></a>02358 
<a name="l02359"></a>02359   <span class="comment">/* if there are no receptive fields */</span>
<a name="l02360"></a>02360   <span class="keywordflow">if</span> (n_rf == 0)
<a name="l02361"></a>02361     <span class="keywordflow">return</span> max_activation;
<a name="l02362"></a>02362   
<a name="l02363"></a>02363   <span class="comment">/* scan the receptive fields */</span>
<a name="l02364"></a>02364   <span class="keywordflow">for</span> (r=1; r&lt;=n_rf; ++r) {
<a name="l02365"></a>02365 
<a name="l02366"></a>02366     <span class="comment">/* fudge in the nearest neighbor lookup */</span>
<a name="l02367"></a>02367     <span class="keywordflow">if</span> (s-&gt;use_nn &amp;&amp; *rfID &gt; 0 &amp;&amp; *rfID &lt;= n_rf) {
<a name="l02368"></a>02368       <span class="keywordflow">if</span> ( (r &gt; s-&gt;max_nn_comp &amp;&amp; max_activation &gt; cutoff) || 
<a name="l02369"></a>02369            r &gt; s-&gt;rfs[*rfID].n_nn)
<a name="l02370"></a>02370         <span class="keywordflow">break</span>;
<a name="l02371"></a>02371       i = s-&gt;rfs[*rfID].nn[r];
<a name="l02372"></a>02372     } <span class="keywordflow">else</span> {
<a name="l02373"></a>02373       i = r;
<a name="l02374"></a>02374     }
<a name="l02375"></a>02375   
<a name="l02376"></a>02376     rfptr     = &amp;s-&gt;rfs[i];
<a name="l02377"></a>02377     n_proj    = rfptr-&gt;n_proj;
<a name="l02378"></a>02378 
<a name="l02379"></a>02379     <span class="keywordflow">if</span> (!rfptr-&gt;trustworthy) 
<a name="l02380"></a>02380       <span class="keywordflow">continue</span>;
<a name="l02381"></a>02381     
<a name="l02382"></a>02382     <span class="comment">/* the mean subtracted input  */</span>
<a name="l02383"></a>02383     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02384"></a>02384       <span class="comment">/* NOTE: in order to obtain the true slope component associated with</span>
<a name="l02385"></a>02385 <span class="comment">         each input, the rfptr-&gt;mean_x MUST NOT be subtracted from the</span>
<a name="l02386"></a>02386 <span class="comment">         input. However, we need to make a correction on the constant </span>
<a name="l02387"></a>02387 <span class="comment">         part of the regression, by subtracting the prediction for the</span>
<a name="l02388"></a>02388 <span class="comment">         mean -- this is handled in an extra loop below */</span>
<a name="l02389"></a>02389       s-&gt;x_mzp[j] = s-&gt;xp[j];
<a name="l02390"></a>02390     }
<a name="l02391"></a>02391     
<a name="l02392"></a>02392     
<a name="l02393"></a>02393     <span class="comment">/* generate the weight for this RF */</span>
<a name="l02394"></a>02394     rfptr-&gt;ww = w = calculateWeightp(ID,i,s-&gt;xp_w);
<a name="l02395"></a>02395 
<a name="l02396"></a>02396     <span class="keywordflow">if</span> (w &gt; max_activation) {
<a name="l02397"></a>02397       max_activation = w;
<a name="l02398"></a>02398       index_max = i;
<a name="l02399"></a>02399     }
<a name="l02400"></a>02400 
<a name="l02401"></a>02401     <span class="keywordflow">if</span> (w &gt; cutoff &amp;&amp; blend) {
<a name="l02402"></a>02402 
<a name="l02403"></a>02403       <span class="comment">/* add the constant part */</span>
<a name="l02404"></a>02404       <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02405"></a>02405         <span class="keywordflow">for</span> (m=1; m&lt;=n_part; ++m) {
<a name="l02406"></a>02406           <span class="keywordflow">if</span> (partmat[m][n_in_reg+1] == 1)
<a name="l02407"></a>02407             y[j][m] += rfptr-&gt;mean_y[j] * w; 
<a name="l02408"></a>02408         }
<a name="l02409"></a>02409       }
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 
<a name="l02412"></a>02412       <span class="keywordflow">for</span> (m=1; m&lt;=n_part+1; ++m) {
<a name="l02413"></a>02413 
<a name="l02414"></a>02414         <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02415"></a>02415 <span class="preprocessor">#if SPHERING</span>
<a name="l02416"></a>02416 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (m==n_part+1)
<a name="l02417"></a>02417             xres[j] = rfptr-&gt;mean_x_reg[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l02418"></a>02418           <span class="keywordflow">else</span>
<a name="l02419"></a>02419             xres[j] = s-&gt;x_mzp[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>)*partmat[m][j];
<a name="l02420"></a>02420 <span class="preprocessor">#else</span>
<a name="l02421"></a>02421 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (m==n_part+1)
<a name="l02422"></a>02422             xres[j] = rfptr-&gt;mean_x_reg[j];
<a name="l02423"></a>02423           <span class="keywordflow">else</span>
<a name="l02424"></a>02424             xres[j] = s-&gt;x_mzp[j]*partmat[m][j];
<a name="l02425"></a>02425 <span class="preprocessor">#endif</span>
<a name="l02426"></a>02426 <span class="preprocessor"></span>        }
<a name="l02427"></a>02427         
<a name="l02428"></a>02428         <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02429"></a>02429           
<a name="l02430"></a>02430           <span class="comment">/* project the input onto the current projection */</span>
<a name="l02431"></a>02431           x_proj = vec_mult_inner_size(xres,rfptr-&gt;W[k],n_in_reg);
<a name="l02432"></a>02432           
<a name="l02433"></a>02433           <span class="comment">/* do single variate prediction */</span>
<a name="l02434"></a>02434           <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02435"></a>02435             <span class="keywordflow">if</span> (m==n_part+1)
<a name="l02436"></a>02436               y_mean_p[j] += x_proj * rfptr-&gt;B[k][j] * w;
<a name="l02437"></a>02437             <span class="keywordflow">else</span>
<a name="l02438"></a>02438               y[j][m] += x_proj * rfptr-&gt;B[k][j] * w;
<a name="l02439"></a>02439           }
<a name="l02440"></a>02440           
<a name="l02441"></a>02441           <span class="comment">/* adjust the input data */</span>
<a name="l02442"></a>02442           <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02443"></a>02443             xres[j] -= x_proj * rfptr-&gt;U[k][j];
<a name="l02444"></a>02444           }
<a name="l02445"></a>02445           
<a name="l02446"></a>02446         }
<a name="l02447"></a>02447 
<a name="l02448"></a>02448       } <span class="comment">/* end  for (m=1; m&lt;=n_part+1; ++m) */</span>
<a name="l02449"></a>02449       
<a name="l02450"></a>02450       <span class="comment">/* fix the constant part according to mean of RF*/</span>
<a name="l02451"></a>02451       <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02452"></a>02452         <span class="keywordflow">for</span> (m=1; m&lt;=n_part; ++m) {
<a name="l02453"></a>02453           <span class="keywordflow">if</span> (partmat[m][n_in_reg+1] == 1)
<a name="l02454"></a>02454             y[j][m] -= y_mean_p[j];
<a name="l02455"></a>02455         }
<a name="l02456"></a>02456         y_mean_p[j] = 0;
<a name="l02457"></a>02457       }
<a name="l02458"></a>02458 
<a name="l02459"></a>02459       sum_w += w;
<a name="l02460"></a>02460       ++count_rf;
<a name="l02461"></a>02461 
<a name="l02462"></a>02462     }
<a name="l02463"></a>02463 
<a name="l02464"></a>02464   }
<a name="l02465"></a>02465 
<a name="l02466"></a>02466 
<a name="l02467"></a>02467   <span class="comment">/* finish up */</span>
<a name="l02468"></a>02468 
<a name="l02469"></a>02469   <span class="keywordflow">if</span> (blend) {
<a name="l02470"></a>02470 
<a name="l02471"></a>02471     <span class="keywordflow">if</span> (sum_w &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) 
<a name="l02472"></a>02472       sum_w = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l02473"></a>02473 
<a name="l02474"></a>02474 
<a name="l02475"></a>02475     <span class="keywordflow">for</span> (i=1; i&lt;=n_out; ++i) 
<a name="l02476"></a>02476       <span class="keywordflow">for</span> (m=1; m&lt;=n_part; ++m)
<a name="l02477"></a>02477         y[i][m] = y[i][m]/sum_w*s-&gt;norm_out[i];
<a name="l02478"></a>02478     
<a name="l02479"></a>02479   } <span class="keywordflow">else</span> {
<a name="l02480"></a>02480     
<a name="l02481"></a>02481     <span class="comment">/* predict y from the max activated rf */</span>
<a name="l02482"></a>02482     rfptr = &amp;s-&gt;rfs[index_max];
<a name="l02483"></a>02483     n_proj = rfptr-&gt;n_proj;
<a name="l02484"></a>02484     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02485"></a>02485       <span class="comment">/* again, do not subtract the mean */</span>
<a name="l02486"></a>02486       s-&gt;x_mzp[j] = s-&gt;xp[j];
<a name="l02487"></a>02487     }
<a name="l02488"></a>02488 
<a name="l02489"></a>02489     <span class="keywordflow">for</span> (m=1; m&lt;=n_part+1; ++m) {
<a name="l02490"></a>02490       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02491"></a>02491 <span class="preprocessor">#if SPHERING</span>
<a name="l02492"></a>02492 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m==n_part+1)
<a name="l02493"></a>02493           xres[j] = rfptr-&gt;mean_x_reg[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l02494"></a>02494         <span class="keywordflow">else</span>
<a name="l02495"></a>02495           xres[j] = s-&gt;x_mzp[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>)*partmat[m][j];
<a name="l02496"></a>02496 <span class="preprocessor">#else</span>
<a name="l02497"></a>02497 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m==n_part+1)
<a name="l02498"></a>02498           xres[j] = rfptr-&gt;mean_x_reg[j];
<a name="l02499"></a>02499         <span class="keywordflow">else</span>
<a name="l02500"></a>02500           xres[j] = s-&gt;x_mzp[j]*partmat[m][j];
<a name="l02501"></a>02501 <span class="preprocessor">#endif</span>
<a name="l02502"></a>02502 <span class="preprocessor"></span>      }
<a name="l02503"></a>02503       
<a name="l02504"></a>02504       <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02505"></a>02505         
<a name="l02506"></a>02506         <span class="comment">/* project the input onto the current projection */</span>
<a name="l02507"></a>02507         x_proj = vec_mult_inner_size(xres,rfptr-&gt;W[k],n_in_reg);
<a name="l02508"></a>02508         
<a name="l02509"></a>02509         <span class="comment">/* do single variate prediction */</span>
<a name="l02510"></a>02510         <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02511"></a>02511           y[j][m] += x_proj * rfptr-&gt;B[k][j];
<a name="l02512"></a>02512           <span class="keywordflow">if</span> (m==n_part+1)
<a name="l02513"></a>02513             y_mean_p[j] += x_proj * rfptr-&gt;B[k][j];
<a name="l02514"></a>02514           <span class="keywordflow">else</span>
<a name="l02515"></a>02515             y[j][m] += x_proj * rfptr-&gt;B[k][j];
<a name="l02516"></a>02516         }
<a name="l02517"></a>02517         
<a name="l02518"></a>02518         <span class="comment">/* adjust the input data */</span>
<a name="l02519"></a>02519         <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02520"></a>02520           xres[j] -= x_proj * rfptr-&gt;U[k][j];
<a name="l02521"></a>02521         }
<a name="l02522"></a>02522         
<a name="l02523"></a>02523       }
<a name="l02524"></a>02524     }
<a name="l02525"></a>02525     
<a name="l02526"></a>02526     <span class="comment">/* add the constant part */</span>
<a name="l02527"></a>02527     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02528"></a>02528       <span class="keywordflow">for</span> (m=1; m&lt;=n_part; ++m) {
<a name="l02529"></a>02529         <span class="keywordflow">if</span> (partmat[m][n_in_reg+1] == 1)
<a name="l02530"></a>02530           y[j][m] = (y[j][m] + rfptr-&gt;mean_y[j] - y_mean_p[j])*s-&gt;norm_out[j]; 
<a name="l02531"></a>02531       }
<a name="l02532"></a>02532     }
<a name="l02533"></a>02533 
<a name="l02534"></a>02534     <span class="keywordflow">if</span> (!s-&gt;rfs[index_max].trustworthy) max_activation = 0;
<a name="l02535"></a>02535     
<a name="l02536"></a>02536   }
<a name="l02537"></a>02537 
<a name="l02538"></a>02538   *rfID = index_max;
<a name="l02539"></a>02539 
<a name="l02540"></a>02540   <span class="keywordflow">return</span> max_activation;
<a name="l02541"></a>02541 
<a name="l02542"></a>02542 }
<a name="l02543"></a>02543 
<a name="l02544"></a>02544 <span class="comment">/*!*****************************************************************************</span>
<a name="l02545"></a>02545 <span class="comment"> *******************************************************************************</span>
<a name="l02546"></a>02546 <span class="comment"> \note  predictLWPROutputPartCompControl</span>
<a name="l02547"></a>02547 <span class="comment"> \date  March 2003</span>
<a name="l02548"></a>02548 <span class="comment"> </span>
<a name="l02549"></a>02549 <span class="comment"> \remarks </span>
<a name="l02550"></a>02550 <span class="comment"> </span>
<a name="l02551"></a>02551 <span class="comment"> A special wrapper for using predictLWPROutputPart for composite control </span>
<a name="l02552"></a>02552 <span class="comment"> that splits the input vector into x and u components. The partition matrix,</span>
<a name="l02553"></a>02553 <span class="comment"> however, needs to be provided correctly for the entire (potentially</span>
<a name="l02554"></a>02554 <span class="comment"> augmented) input vector consisting of [x x*u' u 1].</span>
<a name="l02555"></a>02555 <span class="comment"> </span>
<a name="l02556"></a>02556 <span class="comment"> *******************************************************************************</span>
<a name="l02557"></a>02557 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02558"></a>02558 <span class="comment"> </span>
<a name="l02559"></a>02559 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02560"></a>02560 <span class="comment"> \param[in]     x      : the input state vector</span>
<a name="l02561"></a>02561 <span class="comment"> \param[in]     u      : the input controlvector</span>
<a name="l02562"></a>02562 <span class="comment"> \param[in]     cutoff : a number between [0,1] which indicates at which threshold</span>
<a name="l02563"></a>02563 <span class="comment">             a receptive field is not used for averaging anymore</span>
<a name="l02564"></a>02564 <span class="comment"> \param[in]     blend  : blend predictions or use max only </span>
<a name="l02565"></a>02565 <span class="comment"> \param[in]     n_part : number of partitions (=number of rows in partition matrix)</span>
<a name="l02566"></a>02566 <span class="comment"> \param[in]     partmat: partition matrix</span>
<a name="l02567"></a>02567 <span class="comment"> \param[out]    y      : the output **matrix** (one column for every partition)</span>
<a name="l02568"></a>02568 <span class="comment"> \param[in,out] rfID   : the rf for the neighborhood for input, returns the max activated rf </span>
<a name="l02569"></a>02569 <span class="comment"></span>
<a name="l02570"></a>02570 <span class="comment"> returns the max activation contributing to this output</span>
<a name="l02571"></a>02571 <span class="comment"> </span>
<a name="l02572"></a>02572 <span class="comment"> ******************************************************************************/</span>
<a name="l02573"></a>02573 <span class="keywordtype">double</span>
<a name="l02574"></a><a class="code" href="lwpr_8h.html#3c8c57f4659c4ca081dbeeec04275c24">02574</a> <a class="code" href="lwpr_8c.html#3c8c57f4659c4ca081dbeeec04275c24">predictLWPROutputPartCompControl</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *u, <span class="keywordtype">double</span> cutoff, 
<a name="l02575"></a>02575                                  <span class="keywordtype">int</span> blend, <span class="keywordtype">int</span> n_part, <span class="keywordtype">int</span> **partmat, <span class="keywordtype">double</span> **y, 
<a name="l02576"></a>02576                                  <span class="keywordtype">int</span> *rfID)
<a name="l02577"></a>02577 {
<a name="l02578"></a>02578   <span class="keywordtype">int</span> i,j,r;
<a name="l02579"></a>02579   <span class="keywordtype">int</span> n_in_expected;
<a name="l02580"></a>02580   <span class="keyword">static</span> Vector x_aug = NULL;
<a name="l02581"></a>02581   
<a name="l02582"></a>02582   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l02583"></a>02583     <span class="keywordflow">return</span> FALSE;
<a name="l02584"></a>02584   
<a name="l02585"></a>02585   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].linear_gx) 
<a name="l02586"></a>02586     n_in_expected = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states + 
<a name="l02587"></a>02587       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls*<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states + <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls;
<a name="l02588"></a>02588   <span class="keywordflow">else</span>
<a name="l02589"></a>02589     n_in_expected = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states + <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls;
<a name="l02590"></a>02590   
<a name="l02591"></a>02591   <span class="keywordflow">if</span> (n_in_expected != <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg) {
<a name="l02592"></a>02592     printf(<span class="stringliteral">"predictLWPROutputCompControl: #inputs in LWPR (%d) does not match #inputs computed (%d)\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg,n_in_expected);
<a name="l02593"></a>02593     <span class="keywordflow">return</span> FALSE;
<a name="l02594"></a>02594   }
<a name="l02595"></a>02595   
<a name="l02596"></a>02596   <span class="keywordflow">if</span> (x_aug == NULL)
<a name="l02597"></a>02597     x_aug = my_vector(1,n_in_expected);
<a name="l02598"></a>02598   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x_aug[NR] &lt; n_in_expected)
<a name="l02599"></a>02599     vec_add_shape(&amp;x_aug,n_in_expected-x_aug[NR]);
<a name="l02600"></a>02600   
<a name="l02601"></a>02601   <span class="comment">/* if a linear g(x) is to be learned, the input vector has to be augmented */</span>
<a name="l02602"></a>02602   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].linear_gx) {
<a name="l02603"></a>02603     r=0;
<a name="l02604"></a>02604     <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states; ++i)      
<a name="l02605"></a>02605       x_aug[++r] = x[i];
<a name="l02606"></a>02606     
<a name="l02607"></a>02607     <span class="keywordflow">for</span> (j=1; j&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls; ++j)
<a name="l02608"></a>02608       <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states; ++i)
<a name="l02609"></a>02609         x_aug[++r] = x[i]*u[j];
<a name="l02610"></a>02610     
<a name="l02611"></a>02611     <span class="keywordflow">for</span> (j=1; j&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls; ++j)
<a name="l02612"></a>02612       x_aug[++r] = u[j];
<a name="l02613"></a>02613   } <span class="keywordflow">else</span> 
<a name="l02614"></a>02614     vec_equal_size(x,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg,x_aug);
<a name="l02615"></a>02615   
<a name="l02616"></a>02616   <span class="keywordflow">return</span> <a class="code" href="lwpr_8c.html#294510baf02273d888bda26effdba614">predictLWPROutputPart</a>(ID, x, x_aug, cutoff, blend, n_part,partmat,y,rfID);
<a name="l02617"></a>02617 }
<a name="l02618"></a>02618 
<a name="l02619"></a>02619 <span class="comment">/*!*****************************************************************************</span>
<a name="l02620"></a>02620 <span class="comment"> *******************************************************************************</span>
<a name="l02621"></a>02621 <span class="comment"> \note  predictLWPROutputRF</span>
<a name="l02622"></a>02622 <span class="comment"> \date  January, 1994</span>
<a name="l02623"></a>02623 <span class="comment"> </span>
<a name="l02624"></a>02624 <span class="comment"> \remarks </span>
<a name="l02625"></a>02625 <span class="comment"> </span>
<a name="l02626"></a>02626 <span class="comment"> generates a prediction from a given input for a particular RF</span>
<a name="l02627"></a>02627 <span class="comment"> </span>
<a name="l02628"></a>02628 <span class="comment"> *******************************************************************************</span>
<a name="l02629"></a>02629 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02630"></a>02630 <span class="comment"> </span>
<a name="l02631"></a>02631 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02632"></a>02632 <span class="comment"> \param[in]     x_w    : the input vector</span>
<a name="l02633"></a>02633 <span class="comment"> \param[in]     x      : the input vector</span>
<a name="l02634"></a>02634 <span class="comment"> \param[in]     rfID   : the targeted</span>
<a name="l02635"></a>02635 <span class="comment"> \param[out]    y      : the output vector</span>
<a name="l02636"></a>02636 <span class="comment"></span>
<a name="l02637"></a>02637 <span class="comment"> returns the activation contributing to this output</span>
<a name="l02638"></a>02638 <span class="comment"> </span>
<a name="l02639"></a>02639 <span class="comment"> ******************************************************************************/</span>
<a name="l02640"></a>02640 <span class="keywordtype">double</span>
<a name="l02641"></a><a class="code" href="lwpr_8c.html#78605bbd05bb5d193e1e5843c5f78ffd">02641</a> <a class="code" href="lwpr_8c.html#78605bbd05bb5d193e1e5843c5f78ffd">predictLWPROutputRF</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x_w, <span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> rfID, <span class="keywordtype">double</span> *y)
<a name="l02642"></a>02642      
<a name="l02643"></a>02643 {
<a name="l02644"></a>02644 
<a name="l02645"></a>02645   <span class="keywordtype">int</span>     i,j,k,n;
<a name="l02646"></a>02646   <span class="keywordtype">double</span>  max_activation = 0;
<a name="l02647"></a>02647   <span class="keywordtype">double</span>  sum_w = 0;
<a name="l02648"></a>02648   <span class="keywordtype">double</span>  w=0.;
<a name="l02649"></a>02649   <span class="keywordtype">int</span>     n_in_w;
<a name="l02650"></a>02650   <span class="keywordtype">int</span>     n_in_reg;
<a name="l02651"></a>02651   <span class="keywordtype">int</span>     n_proj;
<a name="l02652"></a>02652   <span class="keywordtype">int</span>     n_rf;
<a name="l02653"></a>02653   <span class="keywordtype">int</span>     n_out;
<a name="l02654"></a>02654   <span class="keywordtype">int</span>     index_max= -999;
<a name="l02655"></a>02655   RF     *rfptr;
<a name="l02656"></a>02656   <span class="keywordtype">int</span>     count_rf=0;
<a name="l02657"></a>02657   LWPR    *s;
<a name="l02658"></a>02658   <span class="keywordtype">double</span>  x_proj;
<a name="l02659"></a>02659 
<a name="l02660"></a>02660   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l02661"></a>02661     <span class="keywordflow">return</span> FALSE;
<a name="l02662"></a>02662 
<a name="l02663"></a>02663   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l02664"></a>02664   n_in_w    = s-&gt;n_in_w;
<a name="l02665"></a>02665   n_in_reg  = s-&gt;n_in_reg;
<a name="l02666"></a>02666   n_out     = s-&gt;n_out;
<a name="l02667"></a>02667   n_rf      = s-&gt;n_rf;
<a name="l02668"></a>02668 
<a name="l02669"></a>02669   rfptr  = &amp;s-&gt;rfs[rfID];
<a name="l02670"></a>02670   n_proj = rfptr-&gt;n_proj;
<a name="l02671"></a>02671   
<a name="l02672"></a>02672   <span class="comment">/* normalize the query point */</span>
<a name="l02673"></a>02673   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02674"></a>02674     s-&gt;xp[j] = x[j]/s-&gt;norm_in_reg[j];
<a name="l02675"></a>02675   }
<a name="l02676"></a>02676 
<a name="l02677"></a>02677   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_w; ++j) {
<a name="l02678"></a>02678     s-&gt;xp_w[j] = x_w[j]/s-&gt;norm_in_w[j];
<a name="l02679"></a>02679   }
<a name="l02680"></a>02680 
<a name="l02681"></a>02681   <span class="comment">/* the mean subtracted input  */</span>
<a name="l02682"></a>02682   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02683"></a>02683     s-&gt;x_mzp[j] = s-&gt;xp[j] - rfptr-&gt;mean_x_reg[j];
<a name="l02684"></a>02684   }
<a name="l02685"></a>02685     
<a name="l02686"></a>02686   w = calculateWeightp(ID,rfID,s-&gt;xp_w);
<a name="l02687"></a>02687 
<a name="l02688"></a>02688   <span class="comment">/* reset the y[j] here since we sum over them */</span>
<a name="l02689"></a>02689 
<a name="l02690"></a>02690   <span class="comment">/* add the constant part */</span>
<a name="l02691"></a>02691   <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02692"></a>02692     y[j] = rfptr-&gt;mean_y[j]; 
<a name="l02693"></a>02693   }
<a name="l02694"></a>02694   
<a name="l02695"></a>02695   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02696"></a>02696 <span class="preprocessor">#if SPHERING</span>
<a name="l02697"></a>02697 <span class="preprocessor"></span>    s-&gt;xp[j] = s-&gt;x_mzp[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l02698"></a>02698 <span class="preprocessor">#else</span>
<a name="l02699"></a>02699 <span class="preprocessor"></span>    s-&gt;xp[j] = s-&gt;x_mzp[j];
<a name="l02700"></a>02700 <span class="preprocessor">#endif</span>
<a name="l02701"></a>02701 <span class="preprocessor"></span>  }
<a name="l02702"></a>02702 
<a name="l02703"></a>02703   <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02704"></a>02704     
<a name="l02705"></a>02705     <span class="comment">/* project the input onto the current projection */</span>
<a name="l02706"></a>02706     x_proj = vec_mult_inner_size(s-&gt;xp,rfptr-&gt;W[k],n_in_reg);
<a name="l02707"></a>02707     
<a name="l02708"></a>02708     <span class="comment">/* do single variate prediction */</span>
<a name="l02709"></a>02709     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02710"></a>02710       y[j] += x_proj * rfptr-&gt;B[k][j];
<a name="l02711"></a>02711     }
<a name="l02712"></a>02712     
<a name="l02713"></a>02713     <span class="comment">/* adjust the input data */</span>
<a name="l02714"></a>02714     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02715"></a>02715       s-&gt;xp[j] -= x_proj * rfptr-&gt;U[k][j];
<a name="l02716"></a>02716     }
<a name="l02717"></a>02717     
<a name="l02718"></a>02718   }
<a name="l02719"></a>02719     
<a name="l02720"></a>02720   <span class="comment">/* adjust the normalization */</span>
<a name="l02721"></a>02721   <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02722"></a>02722     y[j] *= s-&gt;norm_out[j];
<a name="l02723"></a>02723   }
<a name="l02724"></a>02724 
<a name="l02725"></a>02725   <span class="keywordflow">if</span> (!s-&gt;rfs[index_max].trustworthy) 
<a name="l02726"></a>02726     max_activation = 0;
<a name="l02727"></a>02727   <span class="keywordflow">else</span>
<a name="l02728"></a>02728     max_activation = w;
<a name="l02729"></a>02729 
<a name="l02730"></a>02730   <span class="keywordflow">return</span> max_activation;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732 }
<a name="l02733"></a>02733 
<a name="l02734"></a>02734 <span class="comment">/*!*****************************************************************************</span>
<a name="l02735"></a>02735 <span class="comment"> *******************************************************************************</span>
<a name="l02736"></a>02736 <span class="comment"> \note  createFakeTarget</span>
<a name="l02737"></a>02737 <span class="comment"> \date  June 1999</span>
<a name="l02738"></a>02738 <span class="comment"> </span>
<a name="l02739"></a>02739 <span class="comment"> \remarks </span>
<a name="l02740"></a>02740 <span class="comment"> </span>
<a name="l02741"></a>02741 <span class="comment"> creates a fake target form an error based learning input</span>
<a name="l02742"></a>02742 <span class="comment"> </span>
<a name="l02743"></a>02743 <span class="comment"> *******************************************************************************</span>
<a name="l02744"></a>02744 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02745"></a>02745 <span class="comment"> </span>
<a name="l02746"></a>02746 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02747"></a>02747 <span class="comment"> \param[in]     rfID   : the receptive field ID</span>
<a name="l02748"></a>02748 <span class="comment"> \param[in]     xmz    : mean zero input</span>
<a name="l02749"></a>02749 <span class="comment"> \param[in]     err    : error</span>
<a name="l02750"></a>02750 <span class="comment"> \param[in]     flag   : TRUE if this is an error</span>
<a name="l02751"></a>02751 <span class="comment"> \param[out]    yfake  : faked output</span>
<a name="l02752"></a>02752 <span class="comment"></span>
<a name="l02753"></a>02753 <span class="comment"> this function assumes that various quantities have been pre-computed</span>
<a name="l02754"></a>02754 <span class="comment"> </span>
<a name="l02755"></a>02755 <span class="comment"> ******************************************************************************/</span>
<a name="l02756"></a>02756 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02757"></a>02757 createFakeTarget(<span class="keywordtype">int</span> ID,<span class="keywordtype">int</span> rfID, Vector xmz, Vector err,<span class="keywordtype">int</span> flag, 
<a name="l02758"></a>02758                  Vector yfake)
<a name="l02759"></a>02759      
<a name="l02760"></a>02760 {
<a name="l02761"></a>02761 
<a name="l02762"></a>02762   <span class="keywordtype">int</span>     j,k,n;
<a name="l02763"></a>02763   <span class="keywordtype">int</span>     n_in_reg;
<a name="l02764"></a>02764   <span class="keywordtype">int</span>     n_proj;
<a name="l02765"></a>02765   <span class="keywordtype">int</span>     n_out;
<a name="l02766"></a>02766   RF     *rfptr;
<a name="l02767"></a>02767   LWPR    *s;
<a name="l02768"></a>02768   <span class="keywordtype">double</span>  x_proj;
<a name="l02769"></a>02769   <span class="keywordtype">double</span>  w;
<a name="l02770"></a>02770 
<a name="l02771"></a>02771   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l02772"></a>02772   n_in_reg  = s-&gt;n_in_reg;
<a name="l02773"></a>02773   n_out     = s-&gt;n_out;
<a name="l02774"></a>02774 
<a name="l02775"></a>02775   rfptr  = &amp;s-&gt;rfs[rfID];
<a name="l02776"></a>02776   n_proj = rfptr-&gt;n_proj;
<a name="l02777"></a>02777   
<a name="l02778"></a>02778   w = rfptr-&gt;w;
<a name="l02779"></a>02779 
<a name="l02780"></a>02780   <span class="comment">/* the constant part */</span>
<a name="l02781"></a>02781 
<a name="l02782"></a>02782   <span class="keywordflow">if</span> (!flag) {
<a name="l02783"></a>02783     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) 
<a name="l02784"></a>02784       yfake[j] = err[j];
<a name="l02785"></a>02785     <span class="keywordflow">return</span>;
<a name="l02786"></a>02786   }
<a name="l02787"></a>02787 
<a name="l02788"></a>02788   <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) 
<a name="l02789"></a>02789     yfake[j] = rfptr-&gt;mean_y[j]+err[j];
<a name="l02790"></a>02790   
<a name="l02791"></a>02791   for (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02792"></a>02792 <span class="preprocessor">#if SPHERING</span>
<a name="l02793"></a>02793 <span class="preprocessor"></span>    s-&gt;x_temp[j] = xmz[j]/(sqrt(rfptr-&gt;var_x_reg[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l02794"></a>02794 <span class="preprocessor">#else</span>
<a name="l02795"></a>02795 <span class="preprocessor"></span>    s-&gt;x_temp[j] = xmz[j];
<a name="l02796"></a>02796 <span class="preprocessor">#endif</span>
<a name="l02797"></a>02797 <span class="preprocessor"></span>  }
<a name="l02798"></a>02798 
<a name="l02799"></a>02799   <span class="keywordflow">for</span> (k=1; k&lt;=n_proj; ++k) {
<a name="l02800"></a>02800     
<a name="l02801"></a>02801     <span class="comment">/* project the input onto the current projection */</span>
<a name="l02802"></a>02802     x_proj = vec_mult_inner_size(s-&gt;x_temp,rfptr-&gt;W[k],n_in_reg);
<a name="l02803"></a>02803     
<a name="l02804"></a>02804     <span class="comment">/* do single variate prediction */</span>
<a name="l02805"></a>02805     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l02806"></a>02806       yfake[j] += x_proj * rfptr-&gt;B[k][j];
<a name="l02807"></a>02807     }
<a name="l02808"></a>02808     
<a name="l02809"></a>02809     <span class="comment">/* adjust the input data */</span>
<a name="l02810"></a>02810     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l02811"></a>02811       s-&gt;x_temp[j] -= x_proj * rfptr-&gt;U[k][j];
<a name="l02812"></a>02812     }
<a name="l02813"></a>02813     
<a name="l02814"></a>02814   }
<a name="l02815"></a>02815 
<a name="l02816"></a>02816   <span class="keywordflow">return</span>;
<a name="l02817"></a>02817 
<a name="l02818"></a>02818 }
<a name="l02819"></a>02819 
<a name="l02820"></a>02820 <span class="comment">/*!*****************************************************************************</span>
<a name="l02821"></a>02821 <span class="comment"> *******************************************************************************</span>
<a name="l02822"></a>02822 <span class="comment"> \note  printLWPRStatistics</span>
<a name="l02823"></a>02823 <span class="comment"> \date  June, 1995</span>
<a name="l02824"></a>02824 <span class="comment"> </span>
<a name="l02825"></a>02825 <span class="comment"> \remarks </span>
<a name="l02826"></a>02826 <span class="comment"> </span>
<a name="l02827"></a>02827 <span class="comment"> prints various information about the LWPR</span>
<a name="l02828"></a>02828 <span class="comment"> </span>
<a name="l02829"></a>02829 <span class="comment"> *******************************************************************************</span>
<a name="l02830"></a>02830 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02831"></a>02831 <span class="comment"> </span>
<a name="l02832"></a>02832 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02833"></a>02833 <span class="comment"> </span>
<a name="l02834"></a>02834 <span class="comment"> ******************************************************************************/</span>
<a name="l02835"></a>02835 <span class="keywordtype">void</span>
<a name="l02836"></a><a class="code" href="lwpr_8h.html#7aa1196c093aae7d08d8596720d78ba6">02836</a> <a class="code" href="lwpr_8c.html#7aa1196c093aae7d08d8596720d78ba6">printLWPRStatistics</a>(<span class="keywordtype">int</span> ID) 
<a name="l02837"></a>02837 
<a name="l02838"></a>02838 {
<a name="l02839"></a>02839 
<a name="l02840"></a>02840   <span class="keywordtype">int</span>   n_in_reg;
<a name="l02841"></a>02841   <span class="keywordtype">int</span>   n_in_w;
<a name="l02842"></a>02842   <span class="keywordtype">int</span>   n_out;
<a name="l02843"></a>02843   <span class="keywordtype">int</span>   diag_only;
<a name="l02844"></a>02844   <span class="keywordtype">int</span>   n_rf;
<a name="l02845"></a>02845   LWPR  *s;
<a name="l02846"></a>02846   <span class="keywordtype">int</span>   i,j,k;
<a name="l02847"></a>02847   <span class="keywordtype">char</span>  name[100];
<a name="l02848"></a>02848   <span class="keywordtype">int</span>   num;
<a name="l02849"></a>02849   FILE *out;
<a name="l02850"></a>02850 
<a name="l02851"></a>02851   <span class="comment">/* some handy variables */</span>
<a name="l02852"></a>02852   
<a name="l02853"></a>02853   n_in_reg  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l02854"></a>02854   n_in_w    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l02855"></a>02855   n_out     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l02856"></a>02856   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l02857"></a>02857   n_rf      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf;
<a name="l02858"></a>02858   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l02859"></a>02859   out       = stdout;
<a name="l02860"></a>02860   
<a name="l02861"></a>02861   fprintf(out,<span class="stringliteral">"Data of LWPR &gt;%s&lt;:\n\n"</span>,s-&gt;lwpr_name);
<a name="l02862"></a>02862 
<a name="l02863"></a>02863   fprintf(out,<span class="stringliteral">"       n_in_w            = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w);
<a name="l02864"></a>02864   fprintf(out,<span class="stringliteral">"       n_in_reg          = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg);
<a name="l02865"></a>02865   fprintf(out,<span class="stringliteral">"       n_out             = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out);
<a name="l02866"></a>02866   fprintf(out,<span class="stringliteral">"       init_n_proj       = %d\n"</span>,s-&gt;init_n_proj);
<a name="l02867"></a>02867   fprintf(out,<span class="stringliteral">"       diag_only         = %d\n"</span>,s-&gt;diag_only);
<a name="l02868"></a>02868   fprintf(out,<span class="stringliteral">"       #n_data           = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_data);
<a name="l02869"></a>02869   fprintf(out,<span class="stringliteral">"       #rfs              = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf);
<a name="l02870"></a>02870   fprintf(out,<span class="stringliteral">"       max_rfs           = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].max_rfs);
<a name="l02871"></a>02871   fprintf(out,<span class="stringliteral">"       use_nn            = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_nn);
<a name="l02872"></a>02872   fprintf(out,<span class="stringliteral">"       max_nn_comp       = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].max_nn_comp);
<a name="l02873"></a>02873   fprintf(out,<span class="stringliteral">"       #no_trust         = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_no_trust);
<a name="l02874"></a>02874   fprintf(out,<span class="stringliteral">"       #pruned error     = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_pruned_error);
<a name="l02875"></a>02875   fprintf(out,<span class="stringliteral">"       #pruned overlap   = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_pruned_overlap);
<a name="l02876"></a>02876   fprintf(out,<span class="stringliteral">"       w_gen             = %f\n"</span>,s-&gt;w_gen);
<a name="l02877"></a>02877   fprintf(out,<span class="stringliteral">"       w_prune           = %f\n"</span>,s-&gt;w_prune);
<a name="l02878"></a>02878   fprintf(out,<span class="stringliteral">"       factor_prune      = %f\n"</span>,s-&gt;factor_prune);
<a name="l02879"></a>02879   fprintf(out,<span class="stringliteral">"       final_lambda      = %g\n"</span>,s-&gt;final_lambda);
<a name="l02880"></a>02880   fprintf(out,<span class="stringliteral">"       init_lambda       = %g\n"</span>,s-&gt;init_lambda);
<a name="l02881"></a>02881   fprintf(out,<span class="stringliteral">"       tau_lambda        = %g\n"</span>,s-&gt;tau_lambda);
<a name="l02882"></a>02882   fprintf(out,<span class="stringliteral">"       penalty           = %g\n"</span>,s-&gt;penalty);
<a name="l02883"></a>02883   fprintf(out,<span class="stringliteral">"       init_S2           = %g\n"</span>,s-&gt;init_S2);
<a name="l02884"></a>02884   fprintf(out,<span class="stringliteral">"       meta_learn_rate   = %f\n"</span>,s-&gt;meta_learning_rate);
<a name="l02885"></a>02885   fprintf(out,<span class="stringliteral">"       d_noise           = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].d_noise);
<a name="l02886"></a>02886   fprintf(out,<span class="stringliteral">"       c_noise           = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].c_noise);
<a name="l02887"></a>02887   fprintf(out,<span class="stringliteral">"       mean_error        = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_error);
<a name="l02888"></a>02888   fprintf(out,<span class="stringliteral">"       std_error         = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].std_error);
<a name="l02889"></a>02889   fprintf(out,<span class="stringliteral">"       mean_n_proj       = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_n_proj);
<a name="l02890"></a>02890   fprintf(out,<span class="stringliteral">"       allow meta learn. = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning);
<a name="l02891"></a>02891   fprintf(out,<span class="stringliteral">"       allow D update    = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_d_update);
<a name="l02892"></a>02892   fprintf(out,<span class="stringliteral">"       allow add dim     = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_addDim);
<a name="l02893"></a>02893   fprintf(out,<span class="stringliteral">"       allow add rfs     = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_add_rfs);
<a name="l02894"></a>02894   fprintf(out,<span class="stringliteral">"       add threshold     = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].add_threshold);
<a name="l02895"></a>02895   fprintf(out,<span class="stringliteral">"       composite control = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].composite_control);
<a name="l02896"></a>02896   fprintf(out,<span class="stringliteral">"       n_states          = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states);
<a name="l02897"></a>02897   fprintf(out,<span class="stringliteral">"       n_controls        = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls);
<a name="l02898"></a>02898   fprintf(out,<span class="stringliteral">"       linear g(x)       = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].linear_gx);
<a name="l02899"></a>02899   fprintf(out,<span class="stringliteral">"       kernel_function   = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function);
<a name="l02900"></a>02900 
<a name="l02901"></a>02901   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l02902"></a>02902     fprintf(out,<span class="stringliteral">"       n_in_reg_2nd      = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd);
<a name="l02903"></a>02903     fprintf(out,<span class="stringliteral">"       n_out_2nd         = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd);
<a name="l02904"></a>02904     fprintf(out,<span class="stringliteral">"       #n_data_2nd       = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_data_2nd);
<a name="l02905"></a>02905     fprintf(out,<span class="stringliteral">"       mean_n_proj_2nd   = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].mean_n_proj_2nd);
<a name="l02906"></a>02906     fprintf(out,<span class="stringliteral">"       init_n_proj_2nd   = %d\n"</span>,s-&gt;init_n_proj_2nd);
<a name="l02907"></a>02907   }
<a name="l02908"></a>02908 
<a name="l02909"></a>02909   fprintf(out,<span class="stringliteral">"\n"</span>);
<a name="l02910"></a>02910 
<a name="l02911"></a>02911   fprint_vec(out,<span class="stringliteral">"Normalization Factors norm_in_w"</span>,s-&gt;norm_in_w);
<a name="l02912"></a>02912   fprint_vec(out,<span class="stringliteral">"Normalization Factors norm_in_reg"</span>,s-&gt;norm_in_reg);
<a name="l02913"></a>02913   fprint_vec(out,<span class="stringliteral">"Normalization Factors norm_out"</span>,s-&gt;norm_out);
<a name="l02914"></a>02914   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l02915"></a>02915     fprint_vec(out,<span class="stringliteral">"Normalization Factors norm_in_reg_2nd"</span>,s-&gt;norm_in_reg_2nd);
<a name="l02916"></a>02916     fprint_vec(out,<span class="stringliteral">"Normalization Factors norm_out_2nd"</span>,s-&gt;norm_out_2nd);
<a name="l02917"></a>02917   }
<a name="l02918"></a>02918   fprint_vec(out,<span class="stringliteral">"Mean Inputs mean_x_w"</span>,s-&gt;mean_x_w);
<a name="l02919"></a>02919   fprint_vec(out,<span class="stringliteral">"Var Inputs var_x_w"</span>,s-&gt;var_x_w);
<a name="l02920"></a>02920   fprint_vec(out,<span class="stringliteral">"Mean Inputs mean_x_reg"</span>,s-&gt;mean_x_reg);
<a name="l02921"></a>02921   fprint_vec(out,<span class="stringliteral">"Var Inputs var_x_reg"</span>,s-&gt;var_x_reg);
<a name="l02922"></a>02922   
<a name="l02923"></a>02923 }
<a name="l02924"></a>02924 
<a name="l02925"></a>02925 <span class="comment">/*!*****************************************************************************</span>
<a name="l02926"></a>02926 <span class="comment"> *******************************************************************************</span>
<a name="l02927"></a>02927 <span class="comment"> \note  printRFStatistics</span>
<a name="l02928"></a>02928 <span class="comment"> \date  January, 1995</span>
<a name="l02929"></a>02929 <span class="comment"> </span>
<a name="l02930"></a>02930 <span class="comment"> \remarks </span>
<a name="l02931"></a>02931 <span class="comment"> </span>
<a name="l02932"></a>02932 <span class="comment"> writes the major RF stats to the screen</span>
<a name="l02933"></a>02933 <span class="comment"> </span>
<a name="l02934"></a>02934 <span class="comment"> *******************************************************************************</span>
<a name="l02935"></a>02935 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l02936"></a>02936 <span class="comment"> </span>
<a name="l02937"></a>02937 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l02938"></a>02938 <span class="comment"> \param[in]     rfID   : the ID of the RF </span>
<a name="l02939"></a>02939 <span class="comment"></span>
<a name="l02940"></a>02940 <span class="comment"> ******************************************************************************/</span>
<a name="l02941"></a>02941 <span class="keywordtype">int</span>
<a name="l02942"></a><a class="code" href="lwpr_8h.html#f505db4ae827b555841378003bfb686c">02942</a> <a class="code" href="lwpr_8c.html#f505db4ae827b555841378003bfb686c">printRFStatistics</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l02943"></a>02943      
<a name="l02944"></a>02944 {
<a name="l02945"></a>02945 
<a name="l02946"></a>02946   FILE *out;
<a name="l02947"></a>02947   <span class="keywordtype">int</span>   n_in_reg;
<a name="l02948"></a>02948   <span class="keywordtype">int</span>   n_in_w;
<a name="l02949"></a>02949   <span class="keywordtype">int</span>   n_proj;
<a name="l02950"></a>02950   <span class="keywordtype">int</span>   n_out;
<a name="l02951"></a>02951   <span class="keywordtype">int</span>   diag_only;
<a name="l02952"></a>02952   <span class="keywordtype">int</span>   n_rf;
<a name="l02953"></a>02953   LWPR  *s;
<a name="l02954"></a>02954   <span class="keywordtype">int</span>   i,j,k;
<a name="l02955"></a>02955   <span class="keywordtype">char</span>  name[100];
<a name="l02956"></a>02956   <span class="keywordtype">int</span>   num;
<a name="l02957"></a>02957 
<a name="l02958"></a>02958   out = stdout;
<a name="l02959"></a>02959 
<a name="l02960"></a>02960   <span class="comment">/* some handy variables */</span>
<a name="l02961"></a>02961   
<a name="l02962"></a>02962   n_in_w    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l02963"></a>02963   n_in_reg  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l02964"></a>02964   n_out     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l02965"></a>02965   n_proj    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj;
<a name="l02966"></a>02966   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l02967"></a>02967   n_rf      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf;
<a name="l02968"></a>02968   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l02969"></a>02969 
<a name="l02970"></a>02970   sprintf(name,<span class="stringliteral">"%s.%d.rf"</span>,s-&gt;lwpr_name,rfID);
<a name="l02971"></a>02971   out = fopen(name,<span class="stringliteral">"w"</span>);
<a name="l02972"></a>02972   <span class="keywordflow">if</span> (out == NULL) <span class="keywordflow">return</span> FALSE;
<a name="l02973"></a>02973   
<a name="l02974"></a>02974   fprintf(out,<span class="stringliteral">"Data of RF #%d of LWPR &gt;%s&lt;:\n\n"</span>,rfID,s-&gt;lwpr_name);
<a name="l02975"></a>02975 
<a name="l02976"></a>02976   fprintf(out,<span class="stringliteral">"n_proj              = %d\n"</span>,n_proj);
<a name="l02977"></a>02977   fprintf(out,<span class="stringliteral">"n_nn                = %d\n"</span>,s-&gt;rfs[rfID].n_nn);
<a name="l02978"></a>02978   fprintf(out,<span class="stringliteral">"cost                = %f\n"</span>,0.0);
<a name="l02979"></a>02979   fprintf(out,<span class="stringliteral">"trustworthy         = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].trustworthy);
<a name="l02980"></a>02980   fprintf(out,<span class="stringliteral">"sum_D2              = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_D2);
<a name="l02981"></a>02981   fprintf(out,<span class="stringliteral">"n_updates           = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_updates);
<a name="l02982"></a>02982   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) {
<a name="l02983"></a>02983     fprintf(out,<span class="stringliteral">"%d.sum_weights      = %f\n"</span>,
<a name="l02984"></a>02984             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights[i]);
<a name="l02985"></a>02985     fprintf(out,<span class="stringliteral">"%d.sum_error        = %f\n"</span>,
<a name="l02986"></a>02986             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error[i]);
<a name="l02987"></a>02987     fprintf(out,<span class="stringliteral">"%d.sum_error_cvi    = %f\n"</span>,
<a name="l02988"></a>02988             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi[i]);
<a name="l02989"></a>02989     fprintf(out,<span class="stringliteral">"%d.n_data           = %f\n"</span>,
<a name="l02990"></a>02990             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data[i]);
<a name="l02991"></a>02991   }
<a name="l02992"></a>02992 
<a name="l02993"></a>02993   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l02994"></a>02994 
<a name="l02995"></a>02995     fprintf(out,<span class="stringliteral">"n_proj_2nd              = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj_2nd);
<a name="l02996"></a>02996     <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj_2nd; ++i) {
<a name="l02997"></a>02997       fprintf(out,<span class="stringliteral">"%d.sum_weights_2nd      = %f\n"</span>,
<a name="l02998"></a>02998               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights_2nd[i]);
<a name="l02999"></a>02999       fprintf(out,<span class="stringliteral">"%d.sum_error_2nd        = %f\n"</span>,
<a name="l03000"></a>03000               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_2nd[i]);
<a name="l03001"></a>03001       fprintf(out,<span class="stringliteral">"%d.sum_error_cvi_2nd    = %f\n"</span>,
<a name="l03002"></a>03002               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi_2nd[i]);
<a name="l03003"></a>03003       fprintf(out,<span class="stringliteral">"%d.n_data_2nd           = %f\n"</span>,
<a name="l03004"></a>03004               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data_2nd[i]);
<a name="l03005"></a>03005     }
<a name="l03006"></a>03006 
<a name="l03007"></a>03007   }
<a name="l03008"></a>03008 
<a name="l03009"></a>03009   fflush(out);
<a name="l03010"></a>03010 
<a name="l03011"></a>03011   <span class="keywordflow">return</span> TRUE;
<a name="l03012"></a>03012   
<a name="l03013"></a>03013 
<a name="l03014"></a>03014 } 
<a name="l03015"></a>03015 
<a name="l03016"></a>03016 <span class="comment">/*!*****************************************************************************</span>
<a name="l03017"></a>03017 <span class="comment"> *******************************************************************************</span>
<a name="l03018"></a>03018 <span class="comment"> \note  getLWPRCenterInfo</span>
<a name="l03019"></a>03019 <span class="comment"> \date  January, 1995</span>
<a name="l03020"></a>03020 <span class="comment"></span>
<a name="l03021"></a>03021 <span class="comment"> \remarks </span>
<a name="l03022"></a>03022 <span class="comment"></span>
<a name="l03023"></a>03023 <span class="comment"> returns the location of a RF center</span>
<a name="l03024"></a>03024 <span class="comment"></span>
<a name="l03025"></a>03025 <span class="comment"> *******************************************************************************</span>
<a name="l03026"></a>03026 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l03027"></a>03027 <span class="comment"></span>
<a name="l03028"></a>03028 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l03029"></a>03029 <span class="comment"> \param[in]     rfID   : the ID of the RF</span>
<a name="l03030"></a>03030 <span class="comment"> \param[out]    c      : the center</span>
<a name="l03031"></a>03031 <span class="comment"></span>
<a name="l03032"></a>03032 <span class="comment"> ******************************************************************************/</span>
<a name="l03033"></a>03033 <span class="keywordtype">int</span>
<a name="l03034"></a><a class="code" href="lwpr_8c.html#e85de838c074ff792e5f8f39691bb7d6">03034</a> <a class="code" href="lwpr_8c.html#e85de838c074ff792e5f8f39691bb7d6">getLWPRCenterInfo</a>(<span class="keywordtype">int</span> ID,<span class="keywordtype">int</span> rfID,<span class="keywordtype">double</span> *c)
<a name="l03035"></a>03035 
<a name="l03036"></a>03036 {
<a name="l03037"></a>03037   <span class="keywordtype">int</span> i;
<a name="l03038"></a>03038 
<a name="l03039"></a>03039   <span class="keywordflow">if</span> (rfID &gt; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf || rfID &lt; 1) <span class="keywordflow">return</span> FALSE;
<a name="l03040"></a>03040 
<a name="l03041"></a>03041   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w; ++i) {
<a name="l03042"></a>03042     c[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].c[i]*<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_w[i];
<a name="l03043"></a>03043   }
<a name="l03044"></a>03044 
<a name="l03045"></a>03045   <span class="keywordflow">return</span> TRUE;
<a name="l03046"></a>03046 }
<a name="l03047"></a>03047 <span class="comment">/*!*****************************************************************************</span>
<a name="l03048"></a>03048 <span class="comment"> *******************************************************************************</span>
<a name="l03049"></a>03049 <span class="comment"> \note  getLWPRCenterInfoJac</span>
<a name="l03050"></a>03050 <span class="comment"> \date  January, 1995</span>
<a name="l03051"></a>03051 <span class="comment"></span>
<a name="l03052"></a>03052 <span class="comment"> \remarks </span>
<a name="l03053"></a>03053 <span class="comment"></span>
<a name="l03054"></a>03054 <span class="comment"> returns the location and prediction at a RF center and the locally</span>
<a name="l03055"></a>03055 <span class="comment"> linear model</span>
<a name="l03056"></a>03056 <span class="comment"></span>
<a name="l03057"></a>03057 <span class="comment"> *******************************************************************************</span>
<a name="l03058"></a>03058 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l03059"></a>03059 <span class="comment"></span>
<a name="l03060"></a>03060 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l03061"></a>03061 <span class="comment"> \param[in]     rfID   : the ID of the RF</span>
<a name="l03062"></a>03062 <span class="comment"> \param[out]    c      : the center</span>
<a name="l03063"></a>03063 <span class="comment"> \param[out]    jac    : linear model at center</span>
<a name="l03064"></a>03064 <span class="comment"></span>
<a name="l03065"></a>03065 <span class="comment"> ******************************************************************************/</span>
<a name="l03066"></a>03066 <span class="keywordtype">int</span>
<a name="l03067"></a><a class="code" href="lwpr_8c.html#6180f133be19bde2ddd5ef6bd2fc80f6">03067</a> <a class="code" href="lwpr_8c.html#6180f133be19bde2ddd5ef6bd2fc80f6">getLWPRCenterInfoJac</a>(<span class="keywordtype">int</span> ID,<span class="keywordtype">int</span> rfID,<span class="keywordtype">double</span> *c, <span class="keywordtype">double</span> **jac)
<a name="l03068"></a>03068 
<a name="l03069"></a>03069 {
<a name="l03070"></a>03070   <span class="keywordtype">int</span> i,j,k;
<a name="l03071"></a>03071 
<a name="l03072"></a>03072   printf(<span class="stringliteral">"this needs to be fixed ....\n"</span>);
<a name="l03073"></a>03073 
<a name="l03074"></a>03074   <span class="keywordflow">if</span> (rfID &gt; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf || rfID &lt; 1) <span class="keywordflow">return</span> FALSE;
<a name="l03075"></a>03075 
<a name="l03076"></a>03076   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w; ++i) {
<a name="l03077"></a>03077     c[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].c[i]*<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_w[i];
<a name="l03078"></a>03078   }
<a name="l03079"></a>03079 
<a name="l03080"></a>03080   <span class="keywordflow">for</span> (j=1; j&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out; ++j) {
<a name="l03081"></a>03081     <span class="keywordflow">for</span> (k=1; k&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj; ++k) {
<a name="l03082"></a>03082       jac[j][k] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].B[k][j] / <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].norm_in_reg[j];
<a name="l03083"></a>03083     }
<a name="l03084"></a>03084   }
<a name="l03085"></a>03085 
<a name="l03086"></a>03086   <span class="keywordflow">return</span> TRUE;
<a name="l03087"></a>03087 }
<a name="l03088"></a>03088 
<a name="l03089"></a>03089 <span class="comment">/*!*****************************************************************************</span>
<a name="l03090"></a>03090 <span class="comment"> *******************************************************************************</span>
<a name="l03091"></a>03091 <span class="comment"> \note  several simple functions to change varibles of an lwpr</span>
<a name="l03092"></a>03092 <span class="comment"> \date  January, 1994</span>
<a name="l03093"></a>03093 <span class="comment"> </span>
<a name="l03094"></a>03094 <span class="comment"> \remarks </span>
<a name="l03095"></a>03095 <span class="comment"> </span>
<a name="l03096"></a>03096 <span class="comment"> none</span>
<a name="l03097"></a>03097 <span class="comment"> </span>
<a name="l03098"></a>03098 <span class="comment"> *******************************************************************************</span>
<a name="l03099"></a>03099 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l03100"></a>03100 <span class="comment"> </span>
<a name="l03101"></a>03101 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l03102"></a>03102 <span class="comment"> \param[in]     val    : the value to be changed</span>
<a name="l03103"></a>03103 <span class="comment"> </span>
<a name="l03104"></a>03104 <span class="comment"> ******************************************************************************/</span>
<a name="l03105"></a>03105 <span class="keywordtype">void</span>
<a name="l03106"></a><a class="code" href="lwpr_8h.html#0fddd2b8c255f83be487a0fd3c071fd0">03106</a> <a class="code" href="lwpr_8c.html#0fddd2b8c255f83be487a0fd3c071fd0">changeLWPRPenalty</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> val)
<a name="l03107"></a>03107 {
<a name="l03108"></a>03108   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03109"></a>03109   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].penalty = val;
<a name="l03110"></a>03110 }
<a name="l03111"></a>03111 <span class="keywordtype">void</span>
<a name="l03112"></a>03112 changeLWPRInitLambda(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> init_val)
<a name="l03113"></a>03113 {
<a name="l03114"></a>03114   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03115"></a>03115   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_lambda  = init_val;
<a name="l03116"></a>03116 }
<a name="l03117"></a>03117 <span class="keywordtype">void</span>
<a name="l03118"></a>03118 changeLWPRFinalLambda(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> final_val)
<a name="l03119"></a>03119 {
<a name="l03120"></a>03120   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03121"></a>03121   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].final_lambda = final_val;
<a name="l03122"></a>03122 }
<a name="l03123"></a>03123 <span class="keywordtype">void</span>
<a name="l03124"></a>03124 changeLWPRTauLambda(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> tau_val)
<a name="l03125"></a>03125 {
<a name="l03126"></a>03126   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03127"></a>03127   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].tau_lambda = tau_val;
<a name="l03128"></a>03128 }
<a name="l03129"></a>03129 <span class="keywordtype">void</span>
<a name="l03130"></a>03130 changeLWPRInitS2(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> init_S2)
<a name="l03131"></a>03131 {
<a name="l03132"></a>03132   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03133"></a>03133   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_S2 = init_S2;
<a name="l03134"></a>03134 }
<a name="l03135"></a>03135 <span class="keywordtype">void</span>
<a name="l03136"></a>03136 changeLWPRMetaLearningRate(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> val)
<a name="l03137"></a>03137 {
<a name="l03138"></a>03138   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03139"></a>03139   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].meta_learning_rate = val;
<a name="l03140"></a>03140 }
<a name="l03141"></a>03141 <span class="keywordtype">void</span>
<a name="l03142"></a>03142 changeLWPRInitD(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> **init_D)
<a name="l03143"></a>03143 {
<a name="l03144"></a>03144 
<a name="l03145"></a>03145   <span class="keywordtype">int</span>     i,j;
<a name="l03146"></a>03146   <span class="keywordtype">double</span> *temp;
<a name="l03147"></a>03147   <span class="keywordtype">int</span>     n_in;
<a name="l03148"></a>03148 
<a name="l03149"></a>03149   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03150"></a>03150 
<a name="l03151"></a>03151   <span class="comment">/* the distance metric */</span>
<a name="l03152"></a>03152 
<a name="l03153"></a>03153   n_in = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l03154"></a>03154   
<a name="l03155"></a>03155   <span class="keywordflow">for</span> (i=1; i&lt;=n_in; ++i) {
<a name="l03156"></a>03156     <span class="keywordflow">for</span> (j=i; j&lt;=n_in; ++j) {
<a name="l03157"></a>03157       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j]     = init_D[i][j];
<a name="l03158"></a>03158       <span class="keywordflow">if</span> (i==j &amp;&amp; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] == 0) {
<a name="l03159"></a>03159         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l03160"></a>03160       }
<a name="l03161"></a>03161       <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only &amp;&amp; i != j) <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] = 0.0;
<a name="l03162"></a>03162       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[j][i]     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j];
<a name="l03163"></a>03163       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[j][i]     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j];
<a name="l03164"></a>03164       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j]     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j];
<a name="l03165"></a>03165     }
<a name="l03166"></a>03166   }
<a name="l03167"></a>03167 
<a name="l03168"></a>03168   <span class="comment">/* get the init_M by cholesky decomposition */</span>
<a name="l03169"></a>03169 
<a name="l03170"></a>03170   temp = my_vector(1,n_in);
<a name="l03171"></a>03171 
<a name="l03172"></a>03172   <span class="keywordflow">if</span> (!my_choldc(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M,n_in,temp)) {
<a name="l03173"></a>03173 
<a name="l03174"></a>03174     printf(<span class="stringliteral">"ERROR: Matrix is not positive definite\n"</span>);
<a name="l03175"></a>03175     exit(-50);
<a name="l03176"></a>03176 
<a name="l03177"></a>03177   } <span class="keywordflow">else</span> {
<a name="l03178"></a>03178 
<a name="l03179"></a>03179     <span class="comment">/* since choldc returns the M matrix as lower triangular matrix</span>
<a name="l03180"></a>03180 <span class="comment">       in init_M, and the diagonal elements in temp, I have</span>
<a name="l03181"></a>03181 <span class="comment">       to fix this nonsense */</span>
<a name="l03182"></a>03182 
<a name="l03183"></a>03183     <span class="keywordflow">for</span> (i=1; i&lt;=n_in; ++i) {
<a name="l03184"></a>03184       <span class="keywordflow">for</span> (j=1; j&lt;=n_in; ++j) {
<a name="l03185"></a>03185         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[j][i];
<a name="l03186"></a>03186         <span class="keywordflow">if</span> (i==j) {
<a name="l03187"></a>03187           <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_D[i][j] == 0)
<a name="l03188"></a>03188             <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = 0.0;
<a name="l03189"></a>03189           <span class="keywordflow">else</span>      
<a name="l03190"></a>03190             <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = temp[i];
<a name="l03191"></a>03191         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i&gt;j) {
<a name="l03192"></a>03192           <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j] = 0.0;
<a name="l03193"></a>03193         }
<a name="l03194"></a>03194       }
<a name="l03195"></a>03195     }
<a name="l03196"></a>03196 
<a name="l03197"></a>03197   }
<a name="l03198"></a>03198 
<a name="l03199"></a>03199   my_free_vector(temp,1,n_in);
<a name="l03200"></a>03200 
<a name="l03201"></a>03201 }
<a name="l03202"></a>03202 <span class="keywordtype">void</span>
<a name="l03203"></a>03203 changeLWPRInitAlpha(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> init_alpha)
<a name="l03204"></a>03204 {
<a name="l03205"></a>03205   <span class="keywordtype">int</span>     i,j;
<a name="l03206"></a>03206 
<a name="l03207"></a>03207   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03208"></a>03208   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_alpha = init_alpha;
<a name="l03209"></a>03209 }
<a name="l03210"></a>03210 <span class="keywordtype">void</span>
<a name="l03211"></a>03211 changeLWPRInitNProj(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> init_n_proj)
<a name="l03212"></a>03212 {
<a name="l03213"></a>03213   <span class="keywordtype">int</span>     i,j;
<a name="l03214"></a>03214 
<a name="l03215"></a>03215   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03216"></a>03216   <span class="keywordflow">if</span> (init_n_proj &lt;= <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg &amp;&amp; init_n_proj &gt;= 2)
<a name="l03217"></a>03217     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj = init_n_proj;
<a name="l03218"></a>03218   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_n_proj == 1) { <span class="comment">/* special learning rule for only one dimension */</span>
<a name="l03219"></a>03219     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf == 0) {
<a name="l03220"></a>03220       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_addDim = FALSE;
<a name="l03221"></a>03221       <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj = init_n_proj;
<a name="l03222"></a>03222     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (init_n_proj &gt; 1) {
<a name="l03223"></a>03223       printf(<span class="stringliteral">"ERROR: n_proj=1 cannot be used to change a trained LWPR!\n"</span>);
<a name="l03224"></a>03224     }
<a name="l03225"></a>03225   }
<a name="l03226"></a>03226 
<a name="l03227"></a>03227 }
<a name="l03228"></a>03228 <span class="keywordtype">void</span>
<a name="l03229"></a>03229 changeLWPRInitNProj2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> init_n_proj_2nd)
<a name="l03230"></a>03230 {
<a name="l03231"></a>03231   <span class="keywordtype">int</span>     i,j;
<a name="l03232"></a>03232 
<a name="l03233"></a>03233   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03234"></a>03234   <span class="keywordflow">if</span> (init_n_proj_2nd &lt;= <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd &amp;&amp; init_n_proj_2nd &gt;= 2)
<a name="l03235"></a>03235     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj_2nd = init_n_proj_2nd;
<a name="l03236"></a>03236 }
<a name="l03237"></a>03237 <span class="keywordtype">void</span>
<a name="l03238"></a>03238 changeLWPRAddThreshold(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> add_threshold)
<a name="l03239"></a>03239 {
<a name="l03240"></a>03240   <span class="keywordtype">int</span>     i,j;
<a name="l03241"></a>03241 
<a name="l03242"></a>03242   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03243"></a>03243   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].add_threshold = add_threshold;
<a name="l03244"></a>03244 }
<a name="l03245"></a>03245 <span class="keywordtype">void</span>
<a name="l03246"></a>03246 changeLWPRAllowAddDim(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> allow_addDim)
<a name="l03247"></a>03247 {
<a name="l03248"></a>03248   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03249"></a>03249   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj &gt; 1)
<a name="l03250"></a>03250     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_addDim = allow_addDim;
<a name="l03251"></a>03251 }
<a name="l03252"></a>03252 <span class="keywordtype">void</span>
<a name="l03253"></a>03253 changeLWPRAllowAddRFS(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> allow_add_rfs)
<a name="l03254"></a>03254 {
<a name="l03255"></a>03255   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03256"></a>03256   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_add_rfs = allow_add_rfs;
<a name="l03257"></a>03257 }
<a name="l03258"></a>03258 <span class="keywordtype">void</span>
<a name="l03259"></a>03259 changeLWPRUseNN(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> use_nn)
<a name="l03260"></a>03260 {
<a name="l03261"></a>03261   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03262"></a>03262   <span class="keywordflow">if</span> (use_nn &gt; 1)
<a name="l03263"></a>03263     use_nn = 1;
<a name="l03264"></a>03264   <span class="keywordflow">if</span> (use_nn &lt; 0)
<a name="l03265"></a>03265     use_nn = 0;
<a name="l03266"></a>03266   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_nn = use_nn;
<a name="l03267"></a>03267 }
<a name="l03268"></a>03268 <span class="keywordtype">void</span>
<a name="l03269"></a>03269 changeLWPRMaxNNComp(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> max_nn_comp)
<a name="l03270"></a>03270 {
<a name="l03271"></a>03271   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03272"></a>03272   <span class="keywordflow">if</span> (max_nn_comp &lt; 0)
<a name="l03273"></a>03273     max_nn_comp = 0;
<a name="l03274"></a>03274   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].max_nn_comp = max_nn_comp;
<a name="l03275"></a>03275 }
<a name="l03276"></a>03276 <span class="keywordtype">void</span>
<a name="l03277"></a>03277 changeLWPRAllowDUpdate(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> allow_d_update)
<a name="l03278"></a>03278 {
<a name="l03279"></a>03279   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03280"></a>03280   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_d_update        = allow_d_update;
<a name="l03281"></a>03281 }
<a name="l03282"></a>03282 <span class="keywordtype">void</span>
<a name="l03283"></a>03283 changeLWPRWriteRFs(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> write_rfs)
<a name="l03284"></a>03284 {
<a name="l03285"></a>03285   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03286"></a>03286   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].write_rfs             = write_rfs;
<a name="l03287"></a>03287 }
<a name="l03288"></a>03288 <span class="keywordtype">void</span>
<a name="l03289"></a>03289 changeLWPRMaxRFs(<span class="keywordtype">int</span> ID, <span class="keywordtype">long</span> max_rfs)
<a name="l03290"></a>03290 {
<a name="l03291"></a>03291   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03292"></a>03292   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].max_rfs               = max_rfs;
<a name="l03293"></a>03293 }
<a name="l03294"></a>03294 <span class="keywordtype">void</span>
<a name="l03295"></a>03295 changeLWPRWgen(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> w_gen)
<a name="l03296"></a>03296 {
<a name="l03297"></a>03297   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03298"></a>03298   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].w_gen          = w_gen;
<a name="l03299"></a>03299 }
<a name="l03300"></a>03300 <span class="keywordtype">void</span>
<a name="l03301"></a>03301 changeLWPRWprune(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> w_prune)
<a name="l03302"></a>03302 {
<a name="l03303"></a>03303   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03304"></a>03304   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].w_prune        = w_prune;
<a name="l03305"></a>03305 }
<a name="l03306"></a>03306 <span class="keywordtype">void</span>
<a name="l03307"></a>03307 changeLWPRFactorPrune(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> factor_prune)
<a name="l03308"></a>03308 {
<a name="l03309"></a>03309   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03310"></a>03310   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].factor_prune   = factor_prune;
<a name="l03311"></a>03311 }
<a name="l03312"></a>03312 <span class="keywordtype">void</span>
<a name="l03313"></a>03313 changeLWPRDNoise(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> val)
<a name="l03314"></a>03314 {
<a name="l03315"></a>03315   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03316"></a>03316   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].d_noise        = val;
<a name="l03317"></a>03317 }
<a name="l03318"></a>03318 <span class="keywordtype">void</span>
<a name="l03319"></a>03319 changeLWPRCNoise(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> val)
<a name="l03320"></a>03320 {
<a name="l03321"></a>03321   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03322"></a>03322   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].c_noise        = val;
<a name="l03323"></a>03323 }
<a name="l03324"></a>03324 <span class="keywordtype">int</span>
<a name="l03325"></a>03325 checkLWPRExists(<span class="keywordtype">int</span> ID)
<a name="l03326"></a>03326 {
<a name="l03327"></a>03327 
<a name="l03328"></a>03328   <span class="keywordflow">if</span> (ID &gt; <a class="code" href="lwpr_8h.html#c378fe6d9192236b65019aec93d430d4">MAX_LWPRS</a> || ID &lt; 0) {
<a name="l03329"></a>03329     printf(<span class="stringliteral">"LWPR ID=%d must be in the range of %d until %d --  change ID\n"</span>,
<a name="l03330"></a>03330            ID,0,<a class="code" href="lwpr_8h.html#c378fe6d9192236b65019aec93d430d4">MAX_LWPRS</a>);
<a name="l03331"></a>03331     <span class="keywordflow">return</span> FALSE;
<a name="l03332"></a>03332   }
<a name="l03333"></a>03333   
<a name="l03334"></a>03334   <span class="keywordflow">if</span> (!<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used) {
<a name="l03335"></a>03335     printf(<span class="stringliteral">"LWPR ID=%d is not inited yet\n"</span>,ID);
<a name="l03336"></a>03336     <span class="keywordflow">return</span> FALSE;
<a name="l03337"></a>03337   }
<a name="l03338"></a>03338   <span class="keywordflow">return</span> TRUE;
<a name="l03339"></a>03339 }
<a name="l03340"></a>03340 <span class="keywordtype">void</span>
<a name="l03341"></a>03341 changeLWPRCompositeControl(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> composite_control, 
<a name="l03342"></a>03342                            <span class="keywordtype">int</span> n_states, <span class="keywordtype">int</span> n_controls, <span class="keywordtype">int</span> linear_gx)
<a name="l03343"></a>03343 {
<a name="l03344"></a>03344   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03345"></a>03345   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].composite_control  = composite_control;
<a name="l03346"></a>03346   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_states           = n_states;
<a name="l03347"></a>03347   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_controls         = n_controls;
<a name="l03348"></a>03348   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].linear_gx          = linear_gx;
<a name="l03349"></a>03349 }
<a name="l03350"></a>03350 <span class="keywordtype">void</span>
<a name="l03351"></a>03351 changeLWPRUseOffset(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> val)
<a name="l03352"></a>03352 {
<a name="l03353"></a>03353   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03354"></a>03354   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets        = val;
<a name="l03355"></a>03355 }
<a name="l03356"></a>03356 <span class="keywordtype">void</span>
<a name="l03357"></a>03357 changeLWPRUseOffset2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> val)
<a name="l03358"></a>03358 {
<a name="l03359"></a>03359   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03360"></a>03360   <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets_2nd        = val;
<a name="l03361"></a>03361 }
<a name="l03362"></a>03362 <span class="keywordtype">void</span>
<a name="l03363"></a>03363 changeLWPRKernelFunction(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> val)
<a name="l03364"></a>03364 {
<a name="l03365"></a>03365   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03366"></a>03366   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf == 0)
<a name="l03367"></a>03367     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function = val;
<a name="l03368"></a>03368   <span class="keywordflow">else</span> 
<a name="l03369"></a>03369     printf(<span class="stringliteral">"Cannot change kernel function of an existing LWPR model\n"</span>);
<a name="l03370"></a>03370 }
<a name="l03371"></a>03371 <span class="keywordtype">void</span>
<a name="l03372"></a>03372 changeLWPRName(<span class="keywordtype">int</span> ID, <span class="keywordtype">char</span> * new_name)
<a name="l03373"></a>03373 {
<a name="l03374"></a>03374   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) <span class="keywordflow">return</span>;
<a name="l03375"></a>03375   <span class="comment">/* overwrite the lwpr name */</span>
<a name="l03376"></a>03376   strcpy(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_name,new_name);
<a name="l03377"></a>03377 }
<a name="l03378"></a>03378 
<a name="l03379"></a>03379 <span class="comment">/*!*****************************************************************************</span>
<a name="l03380"></a>03380 <span class="comment"> *******************************************************************************</span>
<a name="l03381"></a>03381 <span class="comment"> \note  writeLWPR</span>
<a name="l03382"></a>03382 <span class="comment"> \date  January, 1994</span>
<a name="l03383"></a>03383 <span class="comment"> </span>
<a name="l03384"></a>03384 <span class="comment"> \remarks </span>
<a name="l03385"></a>03385 <span class="comment"> </span>
<a name="l03386"></a>03386 <span class="comment"> dumps the lwpr with the given ID to a binary file</span>
<a name="l03387"></a>03387 <span class="comment"> </span>
<a name="l03388"></a>03388 <span class="comment"> *******************************************************************************</span>
<a name="l03389"></a>03389 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l03390"></a>03390 <span class="comment"> </span>
<a name="l03391"></a>03391 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l03392"></a>03392 <span class="comment"> </span>
<a name="l03393"></a>03393 <span class="comment"> ******************************************************************************/</span>
<a name="l03394"></a>03394 <span class="keywordtype">int</span>
<a name="l03395"></a><a class="code" href="lwpr_8h.html#53ed9feea7cd762b492817dfb3edde92">03395</a> <a class="code" href="lwpr_8c.html#53ed9feea7cd762b492817dfb3edde92">writeLWPR</a>(<span class="keywordtype">int</span> ID)
<a name="l03396"></a>03396      
<a name="l03397"></a>03397 {
<a name="l03398"></a>03398 
<a name="l03399"></a>03399   FILE *out;
<a name="l03400"></a>03400   <span class="keywordtype">int</span>   diag_only;
<a name="l03401"></a>03401   <span class="keywordtype">int</span>   meta;
<a name="l03402"></a>03402   <span class="keywordtype">int</span>   n_rf;
<a name="l03403"></a>03403   LWPR  *s,st;
<a name="l03404"></a>03404   <span class="keywordtype">int</span>   i,j,k;
<a name="l03405"></a>03405   <span class="keywordtype">char</span>  name[100];
<a name="l03406"></a>03406   <span class="keywordtype">int</span>   num;
<a name="l03407"></a>03407   RF   *r,rt;
<a name="l03408"></a>03408 
<a name="l03409"></a>03409   <span class="keywordflow">if</span> (!<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used) {
<a name="l03410"></a>03410     printf(<span class="stringliteral">"No #LWPR=%d existent!\n"</span>,ID);
<a name="l03411"></a>03411     <span class="keywordflow">return</span> FALSE;
<a name="l03412"></a>03412   }
<a name="l03413"></a>03413 
<a name="l03414"></a>03414   <span class="comment">/* some handy variables */</span>
<a name="l03415"></a>03415   
<a name="l03416"></a>03416   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l03417"></a>03417   n_rf      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf;
<a name="l03418"></a>03418   s         = &amp;(<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID]);
<a name="l03419"></a>03419   meta      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning;
<a name="l03420"></a>03420 
<a name="l03421"></a>03421   sprintf(name,<span class="stringliteral">"%s.lwpr"</span>,s-&gt;lwpr_name);
<a name="l03422"></a>03422   out = fopen(name,<span class="stringliteral">"w"</span>);
<a name="l03423"></a>03423   <span class="keywordflow">if</span> (out == NULL) <span class="keywordflow">return</span> FALSE;
<a name="l03424"></a>03424   
<a name="l03425"></a>03425   printf(<span class="stringliteral">"Writing to file &gt;%s&lt; ..."</span>,name);
<a name="l03426"></a>03426 
<a name="l03427"></a>03427   st = *s;
<a name="l03428"></a>03428 <span class="preprocessor">#ifdef BYTESWAP</span>
<a name="l03429"></a>03429 <span class="preprocessor"></span>  st.n_in_reg            = byteswap_int( st.n_in_reg );
<a name="l03430"></a>03430   st.n_in_reg_2nd        = byteswap_int( st.n_in_reg_2nd );
<a name="l03431"></a>03431   st.n_in_w              = byteswap_int( st.n_in_w );
<a name="l03432"></a>03432   st.n_out               = byteswap_int( st.n_out );
<a name="l03433"></a>03433   st.n_out_2nd           = byteswap_int( st.n_out_2nd );
<a name="l03434"></a>03434   st.n_data              = byteswap_int( st.n_data );
<a name="l03435"></a>03435   st.n_data_2nd          = byteswap_int( st.n_data_2nd );
<a name="l03436"></a>03436   st.w_gen               = byteswap_double( st.w_gen );
<a name="l03437"></a>03437   st.w_prune             = byteswap_double( st.w_prune );
<a name="l03438"></a>03438   st.factor_prune        = byteswap_double( st.factor_prune );
<a name="l03439"></a>03439   st.n_rf                = byteswap_int( st.n_rf );
<a name="l03440"></a>03440   st.n_rf_allocated      = byteswap_int( st.n_rf_allocated );
<a name="l03441"></a>03441   st.lwpr_used           = byteswap_int( st.lwpr_used );
<a name="l03442"></a>03442   st.use_offsets         = byteswap_int( st.use_offsets );
<a name="l03443"></a>03443   st.use_offsets_2nd     = byteswap_int( st.use_offsets_2nd );
<a name="l03444"></a>03444   st.final_lambda        = byteswap_double( st.final_lambda );
<a name="l03445"></a>03445   st.tau_lambda          = byteswap_double( st.tau_lambda );
<a name="l03446"></a>03446   st.init_S2             = byteswap_double( st.init_S2 );
<a name="l03447"></a>03447   st.diag_only           = byteswap_int( st.diag_only );
<a name="l03448"></a>03448   st.penalty             = byteswap_double( st.penalty );
<a name="l03449"></a>03449   st.allow_meta_learning = byteswap_int( st.allow_meta_learning );
<a name="l03450"></a>03450   st.meta_learning_rate  = byteswap_double( st.meta_learning_rate );
<a name="l03451"></a>03451   st.n_pruned_overlap    = byteswap_int( st.n_pruned_overlap );
<a name="l03452"></a>03452   st.n_pruned_error      = byteswap_int( st.n_pruned_error );
<a name="l03453"></a>03453   st.add_threshold       = byteswap_double( st.add_threshold );
<a name="l03454"></a>03454   st.max_rfs             = byteswap_int( st.max_rfs );
<a name="l03455"></a>03455   st.d_noise             = byteswap_double( st.d_noise );
<a name="l03456"></a>03456   st.c_noise             = byteswap_double( st.c_noise );
<a name="l03457"></a>03457   st.allow_d_update      = byteswap_int( st.allow_d_update );
<a name="l03458"></a>03458   st.allow_addDim        = byteswap_int( st.allow_addDim );
<a name="l03459"></a>03459   st.write_rfs           = byteswap_int( st.write_rfs );
<a name="l03460"></a>03460   st.mean_n_proj         = byteswap_double( st.mean_n_proj );
<a name="l03461"></a>03461   st.mean_n_proj_2nd     = byteswap_double( st.mean_n_proj_2nd );
<a name="l03462"></a>03462   st.contrib_n_rf        = byteswap_double( st.contrib_n_rf );
<a name="l03463"></a>03463   st.use_nn              = byteswap_int( st.use_nn );
<a name="l03464"></a>03464   st.max_nn_comp         = byteswap_int( st.max_nn_comp );
<a name="l03465"></a>03465   st.kernel_function     = byteswap_int( st.kernel_function );
<a name="l03466"></a>03466   st.use_reg_2nd         = byteswap_int( st.use_reg_2nd );
<a name="l03467"></a>03467   st.init_n_proj_2nd     = byteswap_int( st.init_n_proj_2nd );
<a name="l03468"></a>03468   st.init_n_proj         = byteswap_int( st.init_n_proj );
<a name="l03469"></a>03469   st.init_alpha          = byteswap_double( st.init_alpha );
<a name="l03470"></a>03470 <span class="preprocessor">#endif</span>
<a name="l03471"></a>03471 <span class="preprocessor"></span>
<a name="l03472"></a>03472   <span class="comment">/* the defining main structure */</span>
<a name="l03473"></a>03473   num = 1;
<a name="l03474"></a>03474   <span class="keywordflow">if</span> (fwrite(&amp;st,<span class="keyword">sizeof</span>(LWPR),num,out)!= num) {
<a name="l03475"></a>03475     printf( <span class="stringliteral">"cannot fwrite file.\n"</span> );
<a name="l03476"></a>03476     <span class="keywordflow">return</span> FALSE;
<a name="l03477"></a>03477   }
<a name="l03478"></a>03478 
<a name="l03479"></a>03479   <span class="comment">/* norm, init_D,  mean_x, var_x */</span>
<a name="l03480"></a>03480   fwrite_vec(out,s-&gt;norm_in_w);
<a name="l03481"></a>03481   fwrite_vec(out,s-&gt;norm_in_reg);
<a name="l03482"></a>03482   fwrite_vec(out,s-&gt;norm_out);
<a name="l03483"></a>03483   fwrite_mat(out,s-&gt;init_D);
<a name="l03484"></a>03484   fwrite_vec(out,s-&gt;mean_x_w);
<a name="l03485"></a>03485   fwrite_vec(out,s-&gt;var_x_w);
<a name="l03486"></a>03486   fwrite_vec(out,s-&gt;mean_x_reg);
<a name="l03487"></a>03487   fwrite_vec(out,s-&gt;var_x_reg);
<a name="l03488"></a>03488 
<a name="l03489"></a>03489   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l03490"></a>03490     fwrite_vec(out,s-&gt;norm_in_reg_2nd);
<a name="l03491"></a>03491     fwrite_vec(out,s-&gt;norm_out_2nd);
<a name="l03492"></a>03492   }
<a name="l03493"></a>03493 
<a name="l03494"></a>03494   <span class="comment">/* all the rfs */</span>
<a name="l03495"></a>03495   <span class="keywordflow">if</span> (n_rf &gt; 0) {
<a name="l03496"></a>03496     <span class="keywordflow">for</span> (i=1; i&lt;=n_rf; ++i) {
<a name="l03497"></a>03497 
<a name="l03498"></a>03498       rt = s-&gt;rfs[i];
<a name="l03499"></a>03499 <span class="preprocessor">#ifdef BYTESWAP</span>
<a name="l03500"></a>03500 <span class="preprocessor"></span>      rt.w = byteswap_double(rt.w);
<a name="l03501"></a>03501       rt.ww = byteswap_double(rt.ww);
<a name="l03502"></a>03502       rt.n_proj = byteswap_int(rt.n_proj);
<a name="l03503"></a>03503       rt.n_proj_2nd = byteswap_int(rt.n_proj_2nd);
<a name="l03504"></a>03504       rt.trustworthy = byteswap_int(rt.trustworthy);
<a name="l03505"></a>03505       rt.trustworthy_2nd = byteswap_int(rt.trustworthy_2nd);
<a name="l03506"></a>03506       rt.sum_D2 = byteswap_double(rt.sum_D2);
<a name="l03507"></a>03507       rt.sum_error_cv = byteswap_double(rt.sum_error_cv);
<a name="l03508"></a>03508       rt.sum_error_cv_2nd = byteswap_double(rt.sum_error_cv_2nd);
<a name="l03509"></a>03509       rt.n_updates = byteswap_int(rt.n_updates);
<a name="l03510"></a>03510       rt.n_nn = byteswap_int(rt.n_nn);
<a name="l03511"></a>03511       rt.n_nn_allocated = byteswap_int(rt.n_nn_allocated);
<a name="l03512"></a>03512       rt.next_nn_check = byteswap_int(rt.next_nn_check);
<a name="l03513"></a>03513 <span class="preprocessor">#endif</span>
<a name="l03514"></a>03514 <span class="preprocessor"></span>      
<a name="l03515"></a>03515       num = 1;
<a name="l03516"></a>03516       <span class="keywordflow">if</span> (fwrite(&amp;rt,<span class="keyword">sizeof</span>(RF),num,out)!= num) {
<a name="l03517"></a>03517         printf( <span class="stringliteral">"cannot fwrite file.\n"</span> );
<a name="l03518"></a>03518         <span class="keywordflow">return</span> FALSE;
<a name="l03519"></a>03519       }
<a name="l03520"></a>03520     }
<a name="l03521"></a>03521   }
<a name="l03522"></a>03522 
<a name="l03523"></a>03523   <span class="comment">/* the matrices of the rf */</span>
<a name="l03524"></a>03524 
<a name="l03525"></a>03525   <span class="keywordflow">for</span> (i=1; i&lt;=n_rf; ++i) {
<a name="l03526"></a>03526 
<a name="l03527"></a>03527     r = &amp;s-&gt;rfs[i];
<a name="l03528"></a>03528 
<a name="l03529"></a>03529     fwrite_mat(out,r-&gt;B);
<a name="l03530"></a>03530     fwrite_mat(out,r-&gt;D);
<a name="l03531"></a>03531     fwrite_mat(out,r-&gt;M);
<a name="l03532"></a>03532     fwrite_vec(out,r-&gt;c);
<a name="l03533"></a>03533     fwrite_mat(out,r-&gt;SXresYres);
<a name="l03534"></a>03534     fwrite_vec(out,r-&gt;ss2);
<a name="l03535"></a>03535     fwrite_vec(out,r-&gt;dof);
<a name="l03536"></a>03536     fwrite_mat(out,r-&gt;SSYres);
<a name="l03537"></a>03537     fwrite_mat(out,r-&gt;SSXres);
<a name="l03538"></a>03538     fwrite_mat(out,r-&gt;alpha);
<a name="l03539"></a>03539     fwrite_vec(out,r-&gt;mean_x_w);
<a name="l03540"></a>03540     fwrite_vec(out,r-&gt;var_x_w);
<a name="l03541"></a>03541     fwrite_vec(out,r-&gt;mean_x_reg);
<a name="l03542"></a>03542     fwrite_vec(out,r-&gt;var_x_reg);
<a name="l03543"></a>03543     fwrite_vec(out,r-&gt;mean_y);
<a name="l03544"></a>03544     fwrite_vec(out,r-&gt;var_y);
<a name="l03545"></a>03545     fwrite_vec(out,r-&gt;sum_weights);
<a name="l03546"></a>03546     fwrite_vec(out,r-&gt;sum_error);
<a name="l03547"></a>03547     fwrite_vec(out,r-&gt;sum_error_cvi);
<a name="l03548"></a>03548     fwrite_vec(out,r-&gt;n_data);
<a name="l03549"></a>03549     fwrite_vec(out,r-&gt;lambda);
<a name="l03550"></a>03550     fwrite_mat(out,r-&gt;W);
<a name="l03551"></a>03551     fwrite_vec(out,r-&gt;Wnorm);
<a name="l03552"></a>03552     fwrite_mat(out,r-&gt;U);
<a name="l03553"></a>03553     fwrite_mat(out,r-&gt;H);
<a name="l03554"></a>03554     fwrite_vec(out,r-&gt;r);
<a name="l03555"></a>03555     fwrite_mat(out,r-&gt;T);
<a name="l03556"></a>03556     fwrite_mat(out,r-&gt;A);
<a name="l03557"></a>03557     <span class="keywordflow">if</span> (meta) {
<a name="l03558"></a>03558       fwrite_mat(out,r-&gt;b);
<a name="l03559"></a>03559       fwrite_mat(out,r-&gt;h);
<a name="l03560"></a>03560     }
<a name="l03561"></a>03561     fwrite_ivec(out,r-&gt;nn);
<a name="l03562"></a>03562     fwrite_vec(out,r-&gt;nnw);
<a name="l03563"></a>03563     fwrite_vec(out,r-&gt;s);
<a name="l03564"></a>03564 
<a name="l03565"></a>03565     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l03566"></a>03566       fwrite_mat(out,r-&gt;B_2nd);
<a name="l03567"></a>03567       fwrite_mat(out,r-&gt;SXresYres_2nd);
<a name="l03568"></a>03568       fwrite_vec(out,r-&gt;ss2_2nd);
<a name="l03569"></a>03569       fwrite_vec(out,r-&gt;dof_2nd);
<a name="l03570"></a>03570       fwrite_mat(out,r-&gt;SSYres_2nd);
<a name="l03571"></a>03571       fwrite_mat(out,r-&gt;SSXres_2nd);
<a name="l03572"></a>03572       fwrite_vec(out,r-&gt;mean_x_reg_2nd);
<a name="l03573"></a>03573       fwrite_vec(out,r-&gt;var_x_reg_2nd);
<a name="l03574"></a>03574       fwrite_vec(out,r-&gt;mean_y_2nd);
<a name="l03575"></a>03575       fwrite_vec(out,r-&gt;var_y_2nd);
<a name="l03576"></a>03576       fwrite_vec(out,r-&gt;sum_weights_2nd);
<a name="l03577"></a>03577       fwrite_vec(out,r-&gt;sum_error_2nd);
<a name="l03578"></a>03578       fwrite_vec(out,r-&gt;sum_error_cvi_2nd);
<a name="l03579"></a>03579       fwrite_vec(out,r-&gt;n_data_2nd);
<a name="l03580"></a>03580       fwrite_vec(out,r-&gt;lambda_2nd);
<a name="l03581"></a>03581       fwrite_mat(out,r-&gt;W_2nd);
<a name="l03582"></a>03582       fwrite_vec(out,r-&gt;Wnorm_2nd);
<a name="l03583"></a>03583       fwrite_mat(out,r-&gt;U_2nd);
<a name="l03584"></a>03584       fwrite_vec(out,r-&gt;s_2nd);
<a name="l03585"></a>03585     }
<a name="l03586"></a>03586 
<a name="l03587"></a>03587     fflush(out);
<a name="l03588"></a>03588 
<a name="l03589"></a>03589   }
<a name="l03590"></a>03590   
<a name="l03591"></a>03591   fflush(out);
<a name="l03592"></a>03592   fclose(out);
<a name="l03593"></a>03593 
<a name="l03594"></a>03594   printf(<span class="stringliteral">"done\n"</span>);
<a name="l03595"></a>03595   
<a name="l03596"></a>03596   <span class="keywordflow">return</span> TRUE;
<a name="l03597"></a>03597 
<a name="l03598"></a>03598 }
<a name="l03599"></a>03599 
<a name="l03600"></a>03600 <span class="comment">/*!*****************************************************************************</span>
<a name="l03601"></a>03601 <span class="comment"> *******************************************************************************</span>
<a name="l03602"></a>03602 <span class="comment"> \note  readLWPR</span>
<a name="l03603"></a>03603 <span class="comment"> \date  January, 1994</span>
<a name="l03604"></a>03604 <span class="comment"> </span>
<a name="l03605"></a>03605 <span class="comment"> \remarks </span>
<a name="l03606"></a>03606 <span class="comment"> </span>
<a name="l03607"></a>03607 <span class="comment"> reads the lwpr from the given name, by searching for a file name.lwpr,</span>
<a name="l03608"></a>03608 <span class="comment"> and assigns this lwpr to the lwpr with numer ID.</span>
<a name="l03609"></a>03609 <span class="comment"> </span>
<a name="l03610"></a>03610 <span class="comment"> *******************************************************************************</span>
<a name="l03611"></a>03611 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l03612"></a>03612 <span class="comment"> </span>
<a name="l03613"></a>03613 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l03614"></a>03614 <span class="comment"> \param[in]     name   : the name of the LWPR, whose data is expected in the file</span>
<a name="l03615"></a>03615 <span class="comment">             name.lwpr</span>
<a name="l03616"></a>03616 <span class="comment"> </span>
<a name="l03617"></a>03617 <span class="comment"> ******************************************************************************/</span>
<a name="l03618"></a>03618 <span class="keywordtype">int</span>
<a name="l03619"></a><a class="code" href="lwpr_8h.html#446dcd7340add6f05e3ca3519702440e">03619</a> <a class="code" href="lwpr_8c.html#446dcd7340add6f05e3ca3519702440e">readLWPR</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">char</span> *name)
<a name="l03620"></a>03620      
<a name="l03621"></a>03621 {
<a name="l03622"></a>03622 
<a name="l03623"></a>03623   FILE *in;
<a name="l03624"></a>03624   <span class="keywordtype">int</span>   diag_only;
<a name="l03625"></a>03625   <span class="keywordtype">int</span>   n_in_w;
<a name="l03626"></a>03626   <span class="keywordtype">int</span>   n_in_reg;
<a name="l03627"></a>03627   <span class="keywordtype">int</span>   n_out;
<a name="l03628"></a>03628   <span class="keywordtype">int</span>   n_in_reg_2nd;
<a name="l03629"></a>03629   <span class="keywordtype">int</span>   n_out_2nd;
<a name="l03630"></a>03630   <span class="keywordtype">int</span>   n_rf;
<a name="l03631"></a>03631   <span class="keywordtype">int</span>   n_rf_allocated;
<a name="l03632"></a>03632   LWPR  *s,st;
<a name="l03633"></a>03633   <span class="keywordtype">int</span>   i,j,k;
<a name="l03634"></a>03634   <span class="keywordtype">char</span>  <span class="keywordtype">string</span>[100];
<a name="l03635"></a>03635   <span class="keywordtype">int</span>   num;
<a name="l03636"></a>03636   <span class="keywordtype">size_t</span> length, number;
<a name="l03637"></a>03637   RF   *r,rt;
<a name="l03638"></a>03638   <span class="keywordtype">int</span>   init_n_proj;
<a name="l03639"></a>03639 
<a name="l03640"></a>03640   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].lwpr_used) {
<a name="l03641"></a>03641     printf(<span class="stringliteral">"#LWPR=%d already existent!\n"</span>,ID);
<a name="l03642"></a>03642     <span class="keywordflow">return</span> FALSE;
<a name="l03643"></a>03643   }
<a name="l03644"></a>03644 
<a name="l03645"></a>03645   <span class="comment">/* open the file */</span>
<a name="l03646"></a>03646 
<a name="l03647"></a>03647   i = strlen(name);
<a name="l03648"></a>03648   <span class="keywordflow">if</span> (name[i-5] == <span class="charliteral">'.'</span> &amp;&amp; name[i-4] == <span class="charliteral">'l'</span> &amp;&amp; name[i-3] == <span class="charliteral">'w'</span> &amp;&amp;
<a name="l03649"></a>03649       name[i-2] == <span class="charliteral">'p'</span> &amp;&amp; name[i-1] == <span class="charliteral">'r'</span>) {
<a name="l03650"></a>03650     strcpy(<span class="keywordtype">string</span>,name);
<a name="l03651"></a>03651     name[i-5] = <span class="charliteral">'\0'</span>; 
<a name="l03652"></a>03652   } <span class="keywordflow">else</span> {
<a name="l03653"></a>03653     sprintf(<span class="keywordtype">string</span>,<span class="stringliteral">"%s.lwpr"</span>,name);
<a name="l03654"></a>03654   }
<a name="l03655"></a>03655 
<a name="l03656"></a>03656   in = fopen(<span class="keywordtype">string</span>,<span class="stringliteral">"r"</span>);
<a name="l03657"></a>03657   <span class="keywordflow">if</span> (in == NULL) {
<a name="l03658"></a>03658     printf(<span class="stringliteral">"File &gt;%s&lt; not found -- LWPR not read!\n"</span>,name);
<a name="l03659"></a>03659     <span class="keywordflow">return</span> FALSE;
<a name="l03660"></a>03660   }
<a name="l03661"></a>03661 
<a name="l03662"></a>03662   printf(<span class="stringliteral">"Reading file &gt;%s&lt; ..."</span>,<span class="keywordtype">string</span>);
<a name="l03663"></a>03663 
<a name="l03664"></a>03664   <span class="comment">/* read the main structure */</span>
<a name="l03665"></a>03665   <span class="keywordflow">if</span> (fread(&amp;st,<span class="keyword">sizeof</span>(LWPR),1,in)!= 1) {
<a name="l03666"></a>03666     printf( <span class="stringliteral">"cannot fread file.\n"</span> );
<a name="l03667"></a>03667     <span class="keywordflow">return</span> FALSE;
<a name="l03668"></a>03668   }
<a name="l03669"></a>03669 
<a name="l03670"></a>03670 <span class="preprocessor">#ifdef BYTESWAP</span>
<a name="l03671"></a>03671 <span class="preprocessor"></span>  st.n_in_reg            = byteswap_int( st.n_in_reg );
<a name="l03672"></a>03672   st.n_in_reg_2nd        = byteswap_int( st.n_in_reg_2nd );
<a name="l03673"></a>03673   st.n_in_w              = byteswap_int( st.n_in_w );
<a name="l03674"></a>03674   st.n_out               = byteswap_int( st.n_out );
<a name="l03675"></a>03675   st.n_out_2nd           = byteswap_int( st.n_out_2nd );
<a name="l03676"></a>03676   st.n_data              = byteswap_int( st.n_data );
<a name="l03677"></a>03677   st.n_data_2nd          = byteswap_int( st.n_data_2nd );
<a name="l03678"></a>03678   st.w_gen               = byteswap_double( st.w_gen );
<a name="l03679"></a>03679   st.w_prune             = byteswap_double( st.w_prune );
<a name="l03680"></a>03680   st.factor_prune        = byteswap_double( st.factor_prune );
<a name="l03681"></a>03681   st.n_rf                = byteswap_int( st.n_rf );
<a name="l03682"></a>03682   st.n_rf_allocated      = byteswap_int( st.n_rf_allocated );
<a name="l03683"></a>03683   st.lwpr_used           = byteswap_int( st.lwpr_used );
<a name="l03684"></a>03684   st.use_offsets         = byteswap_int( st.use_offsets );
<a name="l03685"></a>03685   st.use_offsets_2nd     = byteswap_int( st.use_offsets_2nd );
<a name="l03686"></a>03686   st.final_lambda        = byteswap_double( st.final_lambda );
<a name="l03687"></a>03687   st.tau_lambda          = byteswap_double( st.tau_lambda );
<a name="l03688"></a>03688   st.init_S2             = byteswap_double( st.init_S2 );
<a name="l03689"></a>03689   st.diag_only           = byteswap_int( st.diag_only );
<a name="l03690"></a>03690   st.penalty             = byteswap_double( st.penalty );
<a name="l03691"></a>03691   st.allow_meta_learning = byteswap_int( st.allow_meta_learning );
<a name="l03692"></a>03692   st.meta_learning_rate  = byteswap_double( st.meta_learning_rate );
<a name="l03693"></a>03693   st.n_pruned_overlap    = byteswap_int( st.n_pruned_overlap );
<a name="l03694"></a>03694   st.n_pruned_error      = byteswap_int( st.n_pruned_error );
<a name="l03695"></a>03695   st.add_threshold       = byteswap_double( st.add_threshold );
<a name="l03696"></a>03696   st.max_rfs             = byteswap_int( st.max_rfs );
<a name="l03697"></a>03697   st.d_noise             = byteswap_double( st.d_noise );
<a name="l03698"></a>03698   st.c_noise             = byteswap_double( st.c_noise );
<a name="l03699"></a>03699   st.allow_d_update      = byteswap_int( st.allow_d_update );
<a name="l03700"></a>03700   st.allow_addDim        = byteswap_int( st.allow_addDim );
<a name="l03701"></a>03701   st.write_rfs           = byteswap_int( st.write_rfs );
<a name="l03702"></a>03702   st.mean_n_proj         = byteswap_double( st.mean_n_proj );
<a name="l03703"></a>03703   st.mean_n_proj_2nd     = byteswap_double( st.mean_n_proj_2nd );
<a name="l03704"></a>03704   st.contrib_n_rf        = byteswap_double( st.contrib_n_rf );
<a name="l03705"></a>03705   st.use_nn              = byteswap_int( st.use_nn );
<a name="l03706"></a>03706   st.max_nn_comp         = byteswap_int( st.max_nn_comp );
<a name="l03707"></a>03707   st.kernel_function     = byteswap_int( st.kernel_function );
<a name="l03708"></a>03708   st.use_reg_2nd         = byteswap_int( st.use_reg_2nd );
<a name="l03709"></a>03709   st.init_n_proj_2nd     = byteswap_int( st.init_n_proj_2nd );
<a name="l03710"></a>03710   st.init_n_proj         = byteswap_int( st.init_n_proj );
<a name="l03711"></a>03711   st.init_alpha          = byteswap_double( st.init_alpha );
<a name="l03712"></a>03712 <span class="preprocessor">#endif</span>
<a name="l03713"></a>03713 <span class="preprocessor"></span>
<a name="l03714"></a>03714 
<a name="l03715"></a>03715   <span class="comment">/* some handy variables */</span>
<a name="l03716"></a>03716   diag_only      = st.diag_only;
<a name="l03717"></a>03717   n_rf           = st.n_rf;
<a name="l03718"></a>03718   n_rf_allocated = st.n_rf_allocated;
<a name="l03719"></a>03719   n_in_w         = st.n_in_w;
<a name="l03720"></a>03720   n_in_reg       = st.n_in_reg;
<a name="l03721"></a>03721   n_out          = st.n_out;
<a name="l03722"></a>03722   n_in_reg_2nd   = st.n_in_reg_2nd;
<a name="l03723"></a>03723   n_out_2nd      = st.n_out_2nd;
<a name="l03724"></a>03724   init_n_proj    = st.init_n_proj;
<a name="l03725"></a>03725 
<a name="l03726"></a>03726   <span class="comment">/* overwrite the lwpr name */</span>
<a name="l03727"></a>03727   strcpy(st.lwpr_name,name);
<a name="l03728"></a>03728 
<a name="l03729"></a>03729   <span class="comment">/* need the matrices init_D and stuff */</span>
<a name="l03730"></a>03730   st.init_D           = my_matrix(1,n_in_w,1,n_in_w);
<a name="l03731"></a>03731   st.norm_in_w        = my_vector(1,n_in_w);
<a name="l03732"></a>03732   st.norm_in_reg      = my_vector(1,n_in_reg);
<a name="l03733"></a>03733   st.norm_out         = my_vector(1,n_out);
<a name="l03734"></a>03734   st.mean_x_w         = my_vector(1,n_in_w);
<a name="l03735"></a>03735   st.var_x_w          = my_vector(1,n_in_w);
<a name="l03736"></a>03736   st.mean_x_reg       = my_vector(1,n_in_reg);
<a name="l03737"></a>03737   st.var_x_reg        = my_vector(1,n_in_reg);
<a name="l03738"></a>03738   <span class="keywordflow">if</span> (st.use_reg_2nd) {
<a name="l03739"></a>03739     st.norm_in_reg_2nd      = my_vector(1,n_in_reg_2nd);
<a name="l03740"></a>03740     st.norm_out_2nd         = my_vector(1,n_out_2nd);
<a name="l03741"></a>03741   }
<a name="l03742"></a>03742 
<a name="l03743"></a>03743   fread_vec(in,st.norm_in_w);
<a name="l03744"></a>03744   fread_vec(in,st.norm_in_reg);
<a name="l03745"></a>03745   fread_vec(in,st.norm_out);
<a name="l03746"></a>03746   fread_mat(in,st.init_D);
<a name="l03747"></a>03747   fread_vec(in,st.mean_x_w);
<a name="l03748"></a>03748   fread_vec(in,st.var_x_w);
<a name="l03749"></a>03749   fread_vec(in,st.mean_x_reg);
<a name="l03750"></a>03750   fread_vec(in,st.var_x_reg);
<a name="l03751"></a>03751   <span class="keywordflow">if</span> (st.use_reg_2nd) {
<a name="l03752"></a>03752     fread_vec(in,st.norm_in_reg_2nd);
<a name="l03753"></a>03753     fread_vec(in,st.norm_out_2nd);
<a name="l03754"></a>03754   }
<a name="l03755"></a>03755 
<a name="l03756"></a>03756   <span class="comment">/* initialize the LWPR */</span>
<a name="l03757"></a>03757 
<a name="l03758"></a>03758   <span class="keywordflow">if</span> (!<a class="code" href="lwpr_8c.html#8237eacf87c2818130f870ca92fa219a">initLWPR</a>(n_in_w, n_in_reg, st.n_in_reg_2nd, 
<a name="l03759"></a>03759                 st.n_out, st.n_out_2nd, diag_only,
<a name="l03760"></a>03760                 st.allow_meta_learning, 
<a name="l03761"></a>03761                 st.meta_learning_rate, st.penalty, 
<a name="l03762"></a>03762                 st.init_alpha,st.norm_in_w,st.norm_in_reg, st.norm_in_reg_2nd, 
<a name="l03763"></a>03763                 st.norm_out, st.norm_out_2nd, st.lwpr_name, ID, &amp;st)) {
<a name="l03764"></a>03764     <span class="keywordflow">return</span> FALSE;
<a name="l03765"></a>03765   }
<a name="l03766"></a>03766 
<a name="l03767"></a>03767   changeLWPRInitD(ID,st.init_D);
<a name="l03768"></a>03768 
<a name="l03769"></a>03769   s = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l03770"></a>03770 
<a name="l03771"></a>03771   vec_equal(st.mean_x_w,s-&gt;mean_x_w);
<a name="l03772"></a>03772   vec_equal(st.var_x_w,s-&gt;var_x_w);
<a name="l03773"></a>03773   vec_equal(st.mean_x_reg,s-&gt;mean_x_reg);
<a name="l03774"></a>03774   vec_equal(st.var_x_reg,s-&gt;var_x_reg);
<a name="l03775"></a>03775 
<a name="l03776"></a>03776 
<a name="l03777"></a>03777   my_free_matrix(st.init_D,1,n_in_w,1,n_in_w);
<a name="l03778"></a>03778   my_free_vector(st.norm_in_w,1,n_in_w);
<a name="l03779"></a>03779   my_free_vector(st.norm_in_reg,1,n_in_reg);
<a name="l03780"></a>03780   my_free_vector(st.norm_out,1,n_out);
<a name="l03781"></a>03781   my_free_vector(st.mean_x_w,1,n_in_w);
<a name="l03782"></a>03782   my_free_vector(st.var_x_w,1,n_in_w);
<a name="l03783"></a>03783   my_free_vector(st.mean_x_reg,1,n_in_reg);
<a name="l03784"></a>03784   my_free_vector(st.var_x_reg,1,n_in_reg);
<a name="l03785"></a>03785   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l03786"></a>03786     my_free_vector(st.norm_in_reg_2nd,1,n_in_reg_2nd);
<a name="l03787"></a>03787     my_free_vector(st.norm_out_2nd,1,n_out_2nd);
<a name="l03788"></a>03788   }
<a name="l03789"></a>03789 
<a name="l03790"></a>03790   <span class="comment">/* add all rf to this structure */</span>
<a name="l03791"></a>03791 
<a name="l03792"></a>03792   <span class="keywordflow">if</span> (n_rf &gt; 0) {
<a name="l03793"></a>03793 
<a name="l03794"></a>03794     length = <span class="keyword">sizeof</span>(RF);
<a name="l03795"></a>03795     number = n_rf_allocated;
<a name="l03796"></a>03796     s-&gt;rfs = (RF *) calloc(number,length);
<a name="l03797"></a>03797     
<a name="l03798"></a>03798     <span class="keywordflow">if</span> (s-&gt;rfs == NULL) {
<a name="l03799"></a>03799       printf(<span class="stringliteral">"No more memory for LWPR -- aborted\n"</span>);
<a name="l03800"></a>03800       <span class="keywordflow">return</span> FALSE;
<a name="l03801"></a>03801     }
<a name="l03802"></a>03802 
<a name="l03803"></a>03803     s-&gt;rfs -= 1;
<a name="l03804"></a>03804   }    
<a name="l03805"></a>03805 
<a name="l03806"></a>03806   s-&gt;n_rf_allocated = n_rf_allocated;
<a name="l03807"></a>03807 
<a name="l03808"></a>03808   <span class="comment">/* read all the rf */</span>
<a name="l03809"></a>03809 
<a name="l03810"></a>03810   <span class="keywordflow">if</span> (n_rf &gt; 0) {
<a name="l03811"></a>03811     <span class="keywordflow">for</span> (i=1; i&lt;=n_rf; ++i) {
<a name="l03812"></a>03812       num = 1;
<a name="l03813"></a>03813       <span class="keywordflow">if</span> (fread(&amp;rt,<span class="keyword">sizeof</span>(RF),num,in)!= num) {
<a name="l03814"></a>03814         printf( <span class="stringliteral">"cannot fread file.\n"</span> );
<a name="l03815"></a>03815         <span class="keywordflow">return</span> FALSE;
<a name="l03816"></a>03816       }
<a name="l03817"></a>03817 <span class="preprocessor">#ifdef BYTESWAP</span>
<a name="l03818"></a>03818 <span class="preprocessor"></span>      rt.w = byteswap_double(rt.w);
<a name="l03819"></a>03819       rt.ww = byteswap_double(rt.ww);
<a name="l03820"></a>03820       rt.n_proj = byteswap_int(rt.n_proj);
<a name="l03821"></a>03821       rt.n_proj_2nd = byteswap_int(rt.n_proj_2nd);
<a name="l03822"></a>03822       rt.trustworthy = byteswap_int(rt.trustworthy);
<a name="l03823"></a>03823       rt.trustworthy_2nd = byteswap_int(rt.trustworthy_2nd);
<a name="l03824"></a>03824       rt.sum_D2 = byteswap_double(rt.sum_D2);
<a name="l03825"></a>03825       rt.sum_error_cv = byteswap_double(rt.sum_error_cv);
<a name="l03826"></a>03826       rt.sum_error_cv_2nd = byteswap_double(rt.sum_error_cv_2nd);
<a name="l03827"></a>03827       rt.n_updates = byteswap_int(rt.n_updates);
<a name="l03828"></a>03828       rt.n_nn = byteswap_int(rt.n_nn);
<a name="l03829"></a>03829       rt.n_nn_allocated = byteswap_int(rt.n_nn_allocated);
<a name="l03830"></a>03830       rt.next_nn_check = byteswap_int(rt.next_nn_check);
<a name="l03831"></a>03831 <span class="preprocessor">#endif</span>
<a name="l03832"></a>03832 <span class="preprocessor"></span>      s-&gt;rfs[i] = rt;
<a name="l03833"></a>03833 
<a name="l03834"></a>03834     }
<a name="l03835"></a>03835   }
<a name="l03836"></a>03836 
<a name="l03837"></a>03837   <span class="comment">/* now add the memory for the rfs; NOTE: this must come after reading the</span>
<a name="l03838"></a>03838 <span class="comment">     rfs since I read invalid pointers  in this step. */</span>
<a name="l03839"></a>03839   
<a name="l03840"></a>03840   s-&gt;n_rf = 0;
<a name="l03841"></a>03841 
<a name="l03842"></a>03842   <span class="keywordflow">for</span> (i=1; i&lt;=n_rf; ++i) {
<a name="l03843"></a>03843     <span class="keywordflow">if</span> (!addRF(ID,s-&gt;rfs[i].n_proj,s-&gt;rfs[i].n_proj_2nd,s-&gt;rfs[i].n_nn_allocated))
<a name="l03844"></a>03844       <span class="keywordflow">return</span> FALSE;
<a name="l03845"></a>03845   }
<a name="l03846"></a>03846 
<a name="l03847"></a>03847   <span class="comment">/* the matrices of the rf */</span>
<a name="l03848"></a>03848 
<a name="l03849"></a>03849   <span class="keywordflow">for</span> (i=1; i&lt;=n_rf; ++i) {
<a name="l03850"></a>03850 
<a name="l03851"></a>03851     r = &amp;s-&gt;rfs[i];
<a name="l03852"></a>03852 
<a name="l03853"></a>03853     fread_mat(in,r-&gt;B);
<a name="l03854"></a>03854     fread_mat(in,r-&gt;D);
<a name="l03855"></a>03855     fread_mat(in,r-&gt;M);
<a name="l03856"></a>03856     fread_vec(in,r-&gt;c);
<a name="l03857"></a>03857     fread_mat(in,r-&gt;SXresYres);
<a name="l03858"></a>03858     fread_vec(in,r-&gt;ss2);
<a name="l03859"></a>03859     fread_vec(in,r-&gt;dof);
<a name="l03860"></a>03860     fread_mat(in,r-&gt;SSYres);
<a name="l03861"></a>03861     fread_mat(in,r-&gt;SSXres);
<a name="l03862"></a>03862     fread_mat(in,r-&gt;alpha);
<a name="l03863"></a>03863     fread_vec(in,r-&gt;mean_x_w);
<a name="l03864"></a>03864     fread_vec(in,r-&gt;var_x_w);
<a name="l03865"></a>03865     fread_vec(in,r-&gt;mean_x_reg);
<a name="l03866"></a>03866     fread_vec(in,r-&gt;var_x_reg);
<a name="l03867"></a>03867     fread_vec(in,r-&gt;mean_y);
<a name="l03868"></a>03868     fread_vec(in,r-&gt;var_y);
<a name="l03869"></a>03869     fread_vec(in,r-&gt;sum_weights);
<a name="l03870"></a>03870     fread_vec(in,r-&gt;sum_error);
<a name="l03871"></a>03871     fread_vec(in,r-&gt;sum_error_cvi);
<a name="l03872"></a>03872     fread_vec(in,r-&gt;n_data);
<a name="l03873"></a>03873     fread_vec(in,r-&gt;lambda);
<a name="l03874"></a>03874     fread_mat(in,r-&gt;W);
<a name="l03875"></a>03875     fread_vec(in,r-&gt;Wnorm);
<a name="l03876"></a>03876     fread_mat(in,r-&gt;U);
<a name="l03877"></a>03877     fread_mat(in,r-&gt;H);
<a name="l03878"></a>03878     fread_vec(in,r-&gt;r);
<a name="l03879"></a>03879     fread_mat(in,r-&gt;T);
<a name="l03880"></a>03880     fread_mat(in,r-&gt;A);
<a name="l03881"></a>03881     <span class="keywordflow">if</span> (st.allow_meta_learning) {
<a name="l03882"></a>03882       fread_mat(in,r-&gt;b);
<a name="l03883"></a>03883       fread_mat(in,r-&gt;h);
<a name="l03884"></a>03884     }
<a name="l03885"></a>03885     fread_ivec(in,r-&gt;nn);
<a name="l03886"></a>03886     fread_vec(in,r-&gt;nnw);
<a name="l03887"></a>03887     fread_vec(in,r-&gt;s);
<a name="l03888"></a>03888 
<a name="l03889"></a>03889     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l03890"></a>03890       fread_mat(in,r-&gt;B_2nd);
<a name="l03891"></a>03891       fread_mat(in,r-&gt;SXresYres_2nd);
<a name="l03892"></a>03892       fread_vec(in,r-&gt;ss2_2nd);
<a name="l03893"></a>03893       fread_vec(in,r-&gt;dof_2nd);
<a name="l03894"></a>03894       fread_mat(in,r-&gt;SSYres_2nd);
<a name="l03895"></a>03895       fread_mat(in,r-&gt;SSXres_2nd);
<a name="l03896"></a>03896       fread_vec(in,r-&gt;mean_x_reg_2nd);
<a name="l03897"></a>03897       fread_vec(in,r-&gt;var_x_reg_2nd);
<a name="l03898"></a>03898       fread_vec(in,r-&gt;mean_y_2nd);
<a name="l03899"></a>03899       fread_vec(in,r-&gt;var_y_2nd);
<a name="l03900"></a>03900       fread_vec(in,r-&gt;sum_weights_2nd);
<a name="l03901"></a>03901       fread_vec(in,r-&gt;sum_error_2nd);
<a name="l03902"></a>03902       fread_vec(in,r-&gt;sum_error_cvi_2nd);
<a name="l03903"></a>03903       fread_vec(in,r-&gt;n_data_2nd);
<a name="l03904"></a>03904       fread_vec(in,r-&gt;lambda_2nd);
<a name="l03905"></a>03905       fread_mat(in,r-&gt;W_2nd);
<a name="l03906"></a>03906       fread_vec(in,r-&gt;Wnorm_2nd);
<a name="l03907"></a>03907       fread_mat(in,r-&gt;U_2nd);
<a name="l03908"></a>03908       fread_vec(in,r-&gt;s_2nd);
<a name="l03909"></a>03909     }
<a name="l03910"></a>03910 
<a name="l03911"></a>03911   }
<a name="l03912"></a>03912   
<a name="l03913"></a>03913   fclose(in);
<a name="l03914"></a>03914 
<a name="l03915"></a>03915   printf(<span class="stringliteral">"done\n"</span>);
<a name="l03916"></a>03916   
<a name="l03917"></a>03917   <span class="keywordflow">return</span> TRUE;
<a name="l03918"></a>03918 
<a name="l03919"></a>03919 
<a name="l03920"></a>03920 }
<a name="l03921"></a>03921 
<a name="l03922"></a>03922 <span class="comment">/*!*****************************************************************************</span>
<a name="l03923"></a>03923 <span class="comment"> *******************************************************************************</span>
<a name="l03924"></a>03924 <span class="comment"> \note  writeRFAscii</span>
<a name="l03925"></a>03925 <span class="comment"> \date  January, 1995</span>
<a name="l03926"></a>03926 <span class="comment"> </span>
<a name="l03927"></a>03927 <span class="comment"> \remarks </span>
<a name="l03928"></a>03928 <span class="comment"> </span>
<a name="l03929"></a>03929 <span class="comment"> writes all data of a RF to an ascii file</span>
<a name="l03930"></a>03930 <span class="comment"> </span>
<a name="l03931"></a>03931 <span class="comment"> *******************************************************************************</span>
<a name="l03932"></a>03932 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l03933"></a>03933 <span class="comment"> </span>
<a name="l03934"></a>03934 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l03935"></a>03935 <span class="comment"> \param[in]     rfID   : the ID of the RF </span>
<a name="l03936"></a>03936 <span class="comment"> \param[in]     silent : print message about writing or not</span>
<a name="l03937"></a>03937 <span class="comment"> \param[in]     string : a message to be written in output</span>
<a name="l03938"></a>03938 <span class="comment"></span>
<a name="l03939"></a>03939 <span class="comment"> ******************************************************************************/</span>
<a name="l03940"></a>03940 <span class="keywordtype">int</span>
<a name="l03941"></a><a class="code" href="lwpr_8h.html#9c159349ffa2c22b1e4d2f26b1a13732">03941</a> <a class="code" href="lwpr_8c.html#9c159349ffa2c22b1e4d2f26b1a13732">writeRFAscii</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> silent, <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l03942"></a>03942      
<a name="l03943"></a>03943 {
<a name="l03944"></a>03944 
<a name="l03945"></a>03945   FILE *out;
<a name="l03946"></a>03946   <span class="keywordtype">int</span>   n_in_w;
<a name="l03947"></a>03947   <span class="keywordtype">int</span>   n_in_reg;
<a name="l03948"></a>03948   <span class="keywordtype">int</span>   n_proj;
<a name="l03949"></a>03949   <span class="keywordtype">int</span>   n_proj_2nd;
<a name="l03950"></a>03950   <span class="keywordtype">int</span>   n_out;
<a name="l03951"></a>03951   <span class="keywordtype">int</span>   diag_only;
<a name="l03952"></a>03952   <span class="keywordtype">int</span>   n_rf;
<a name="l03953"></a>03953   LWPR  *s;
<a name="l03954"></a>03954   <span class="keywordtype">int</span>   i,j,k;
<a name="l03955"></a>03955   <span class="keywordtype">char</span>  name[100];
<a name="l03956"></a>03956   <span class="keywordtype">int</span>   num;
<a name="l03957"></a>03957 
<a name="l03958"></a>03958   <span class="comment">/* some handy variables */</span>
<a name="l03959"></a>03959   
<a name="l03960"></a>03960   n_in_w    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l03961"></a>03961   n_in_reg  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l03962"></a>03962   n_out     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l03963"></a>03963   n_proj    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj;
<a name="l03964"></a>03964   n_proj_2nd= <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_proj_2nd;
<a name="l03965"></a>03965   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l03966"></a>03966   n_rf      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf;
<a name="l03967"></a>03967   s         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l03968"></a>03968 
<a name="l03969"></a>03969   sprintf(name,<span class="stringliteral">"%s.%d.rf"</span>,s-&gt;lwpr_name,rfID);
<a name="l03970"></a>03970   out = fopen(name,<span class="stringliteral">"w"</span>);
<a name="l03971"></a>03971   <span class="keywordflow">if</span> (out == NULL) <span class="keywordflow">return</span> FALSE;
<a name="l03972"></a>03972   
<a name="l03973"></a>03973   <span class="keywordflow">if</span> (!silent) printf(<span class="stringliteral">"Writing to file &gt;%s&lt; ..."</span>,name);
<a name="l03974"></a>03974   fprintf(out,<span class="stringliteral">"Data of RF #%d of LWPR &gt;%s&lt;:\n\n"</span>,rfID,s-&gt;lwpr_name);
<a name="l03975"></a>03975 
<a name="l03976"></a>03976   fprintf(out,<span class="stringliteral">"message             = %s\n"</span>,<span class="keywordtype">string</span>);
<a name="l03977"></a>03977   fprintf(out,<span class="stringliteral">"n_proj              = %d\n"</span>,n_proj);
<a name="l03978"></a>03978   fprintf(out,<span class="stringliteral">"cost                = %f\n"</span>,-999.0);
<a name="l03979"></a>03979   fprintf(out,<span class="stringliteral">"trustworthy         = %d\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].trustworthy);
<a name="l03980"></a>03980   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l03981"></a>03981     fprintf(out,<span class="stringliteral">"n_proj_2n           = %d\n"</span>,n_proj_2nd);
<a name="l03982"></a>03982   }
<a name="l03983"></a>03983 
<a name="l03984"></a>03984   <span class="keywordflow">for</span> (i=1;i&lt;=n_proj; ++i) {
<a name="l03985"></a>03985     fprintf(out,<span class="stringliteral">"%d.sum_weights      = %f\n"</span>,
<a name="l03986"></a>03986             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights[i]);
<a name="l03987"></a>03987     fprintf(out,<span class="stringliteral">"%d.sum_error        = %f\n"</span>,
<a name="l03988"></a>03988             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error[i]);
<a name="l03989"></a>03989     fprintf(out,<span class="stringliteral">"%d.sum_error_cvi    = %f\n"</span>,
<a name="l03990"></a>03990             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi[i]);
<a name="l03991"></a>03991     fprintf(out,<span class="stringliteral">"%d.n_data           = %f\n"</span>,
<a name="l03992"></a>03992             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data[i]);
<a name="l03993"></a>03993     fprintf(out,<span class="stringliteral">"%d.lambda           = %f\n"</span>,
<a name="l03994"></a>03994             i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].lambda[i]);
<a name="l03995"></a>03995 
<a name="l03996"></a>03996     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l03997"></a>03997       fprintf(out,<span class="stringliteral">"%d.sum_weights_2nd  = %f\n"</span>,
<a name="l03998"></a>03998               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_weights_2nd[i]);
<a name="l03999"></a>03999       fprintf(out,<span class="stringliteral">"%d.sum_error_2nd    = %f\n"</span>,
<a name="l04000"></a>04000               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_2nd[i]);
<a name="l04001"></a>04001       fprintf(out,<span class="stringliteral">"%d.sum_error_cvi_2nd= %f\n"</span>,
<a name="l04002"></a>04002               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_error_cvi_2nd[i]);
<a name="l04003"></a>04003       fprintf(out,<span class="stringliteral">"%d.n_data_2nd       = %f\n"</span>,
<a name="l04004"></a>04004               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_data_2nd[i]);
<a name="l04005"></a>04005       fprintf(out,<span class="stringliteral">"%d.lambda_2nd       = %f\n"</span>,
<a name="l04006"></a>04006               i,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].lambda_2nd[i]);
<a name="l04007"></a>04007     }
<a name="l04008"></a>04008   }
<a name="l04009"></a>04009   fprintf(out,<span class="stringliteral">"sum_D2              = %f\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].sum_D2);
<a name="l04010"></a>04010   fprintf(out,<span class="stringliteral">"n_updates           = %ld\n"</span>,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_updates);
<a name="l04011"></a>04011 
<a name="l04012"></a>04012   fflush(out);
<a name="l04013"></a>04013 
<a name="l04014"></a>04014   fprint_vec(out,<span class="stringliteral">"RF-center c"</span>,s-&gt;rfs[rfID].c);
<a name="l04015"></a>04015   fprint_mat(out,<span class="stringliteral">"Regression Coefficients B"</span>,s-&gt;rfs[rfID].B);
<a name="l04016"></a>04016   fprint_mat(out,<span class="stringliteral">"Memory trace H"</span>,s-&gt;rfs[rfID].H);
<a name="l04017"></a>04017   fprint_vec(out,<span class="stringliteral">"Memory trace r"</span>,s-&gt;rfs[rfID].r);
<a name="l04018"></a>04018   fprint_mat(out,<span class="stringliteral">"Distance Metric D"</span>,s-&gt;rfs[rfID].D);
<a name="l04019"></a>04019   fprint_vec(out,<span class="stringliteral">"Mean in Weight Input Space mean_x_w"</span>,s-&gt;rfs[rfID].mean_x_w);  
<a name="l04020"></a>04020   fprint_vec(out,<span class="stringliteral">"Var in Weight Input Space var_x_w"</span>,s-&gt;rfs[rfID].var_x_w);  
<a name="l04021"></a>04021   fprint_vec(out,<span class="stringliteral">"Mean in Regression Input Space mean_x_reg"</span>,s-&gt;rfs[rfID].mean_x_reg);  
<a name="l04022"></a>04022   fprint_vec(out,<span class="stringliteral">"Var in Regression Input Space mean_x_reg"</span>,s-&gt;rfs[rfID].var_x_reg);  
<a name="l04023"></a>04023   fprint_vec(out,<span class="stringliteral">"Mean in Output Space mean_y"</span>,s-&gt;rfs[rfID].mean_y);  
<a name="l04024"></a>04024   fprint_vec(out,<span class="stringliteral">"Var in Output Space var_y"</span>,s-&gt;rfs[rfID].var_y);  
<a name="l04025"></a>04025 
<a name="l04026"></a>04026   fprint_vec(out,<span class="stringliteral">"Weighted Sum of Regression Var ss2"</span>,s-&gt;rfs[rfID].ss2);  
<a name="l04027"></a>04027   fprint_vec(out,<span class="stringliteral">"Local Degree of freedom"</span>,s-&gt;rfs[rfID].dof);  
<a name="l04028"></a>04028   fprint_mat(out,<span class="stringliteral">"Weighted Sum of Regression Cov SXresYres"</span>,
<a name="l04029"></a>04029              s-&gt;rfs[rfID].SXresYres);
<a name="l04030"></a>04030   fprint_mat(out,<span class="stringliteral">"Weighted Sum of Regression Cov SSXres"</span>,
<a name="l04031"></a>04031              s-&gt;rfs[rfID].SSXres);
<a name="l04032"></a>04032   fprint_mat(out,<span class="stringliteral">"Weighted Sum of Regression Cov SSYres"</span>,
<a name="l04033"></a>04033              s-&gt;rfs[rfID].SSYres);
<a name="l04034"></a>04034   fprint_mat(out,<span class="stringliteral">"Distance Metric Learning Rate alpha"</span>,s-&gt;rfs[rfID].alpha);
<a name="l04035"></a>04035   <span class="keywordflow">if</span> (s-&gt;allow_meta_learning) {
<a name="l04036"></a>04036     fprint_mat(out,<span class="stringliteral">"Distance Metric Learning Meta Rate b"</span>,s-&gt;rfs[rfID].b);
<a name="l04037"></a>04037     fprint_mat(out,<span class="stringliteral">"Distance Metric Learning Trace Term h"</span>,s-&gt;rfs[rfID].h);
<a name="l04038"></a>04038   }
<a name="l04039"></a>04039   fprint_mat(out,<span class="stringliteral">"Projections W"</span>,s-&gt;rfs[rfID].W);
<a name="l04040"></a>04040   fprint_mat(out,<span class="stringliteral">"Projections U"</span>,s-&gt;rfs[rfID].U);
<a name="l04041"></a>04041   fprint_ivec(out,<span class="stringliteral">"Nearest Neighbors nn"</span>,s-&gt;rfs[rfID].nn);
<a name="l04042"></a>04042   fprint_vec(out,<span class="stringliteral">"Nearest Neighbors nnw"</span>,s-&gt;rfs[rfID].nnw);
<a name="l04043"></a>04043 
<a name="l04044"></a>04044   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_reg_2nd) {
<a name="l04045"></a>04045     fprint_mat(out,<span class="stringliteral">"Regression Coefficients B_2nd"</span>,s-&gt;rfs[rfID].B_2nd);
<a name="l04046"></a>04046     fprint_vec(out,<span class="stringliteral">"Mean in Regression Input Space mean_x_reg_2nd"</span>,s-&gt;rfs[rfID].mean_x_reg_2nd);
<a name="l04047"></a>04047     fprint_vec(out,<span class="stringliteral">"Var in Regression Input Space mean_x_reg_2nd"</span>,s-&gt;rfs[rfID].var_x_reg_2nd);  
<a name="l04048"></a>04048     fprint_vec(out,<span class="stringliteral">"Mean in Output Space mean_y_2nd"</span>,s-&gt;rfs[rfID].mean_y_2nd);  
<a name="l04049"></a>04049     fprint_vec(out,<span class="stringliteral">"Var in Output Space var_y_2nd"</span>,s-&gt;rfs[rfID].var_y_2nd);  
<a name="l04050"></a>04050     
<a name="l04051"></a>04051     fprint_vec(out,<span class="stringliteral">"Weighted Sum of Regression Var ss2_2nd"</span>,s-&gt;rfs[rfID].ss2_2nd);  
<a name="l04052"></a>04052     fprint_vec(out,<span class="stringliteral">"Local Degree of freedom dof_2nd"</span>,s-&gt;rfs[rfID].dof_2nd);  
<a name="l04053"></a>04053     fprint_mat(out,<span class="stringliteral">"Weighted Sum of Regression Cov SXresYres_2nd"</span>,
<a name="l04054"></a>04054                s-&gt;rfs[rfID].SXresYres_2nd);
<a name="l04055"></a>04055     fprint_mat(out,<span class="stringliteral">"Weighted Sum of Regression Cov SSXres_2nd"</span>,
<a name="l04056"></a>04056                s-&gt;rfs[rfID].SSXres_2nd);
<a name="l04057"></a>04057     fprint_mat(out,<span class="stringliteral">"Weighted Sum of Regression Cov SSYres_2nd"</span>,
<a name="l04058"></a>04058                s-&gt;rfs[rfID].SSYres_2nd);
<a name="l04059"></a>04059     fprint_mat(out,<span class="stringliteral">"Projections W_2nd"</span>,s-&gt;rfs[rfID].W_2nd);
<a name="l04060"></a>04060     fprint_mat(out,<span class="stringliteral">"Projections U_2nd"</span>,s-&gt;rfs[rfID].U_2nd);
<a name="l04061"></a>04061   }
<a name="l04062"></a>04062 
<a name="l04063"></a>04063   fclose(out);
<a name="l04064"></a>04064   
<a name="l04065"></a>04065   <span class="keywordflow">if</span> (!silent) printf(<span class="stringliteral">"done\n"</span>);
<a name="l04066"></a>04066   
<a name="l04067"></a>04067   <span class="keywordflow">return</span> TRUE;
<a name="l04068"></a>04068   
<a name="l04069"></a>04069 
<a name="l04070"></a>04070 } 
<a name="l04071"></a>04071 
<a name="l04072"></a>04072 <span class="comment">/*!*****************************************************************************</span>
<a name="l04073"></a>04073 <span class="comment"> *******************************************************************************</span>
<a name="l04074"></a>04074 <span class="comment">\note  getLWPRDistMetric</span>
<a name="l04075"></a>04075 <span class="comment">\date  Nov 3, 1992</span>
<a name="l04076"></a>04076 <span class="comment"></span>
<a name="l04077"></a>04077 <span class="comment">\remarks </span>
<a name="l04078"></a>04078 <span class="comment"></span>
<a name="l04079"></a>04079 <span class="comment">       returns the distance metric for a specific RF</span>
<a name="l04080"></a>04080 <span class="comment"></span>
<a name="l04081"></a>04081 <span class="comment"></span>
<a name="l04082"></a>04082 <span class="comment"> *******************************************************************************</span>
<a name="l04083"></a>04083 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04084"></a>04084 <span class="comment"></span>
<a name="l04085"></a>04085 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l04086"></a>04086 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l04087"></a>04087 <span class="comment"> \param[out]    D     : the distance metric matrix</span>
<a name="l04088"></a>04088 <span class="comment"></span>
<a name="l04089"></a>04089 <span class="comment"></span>
<a name="l04090"></a>04090 <span class="comment"> ******************************************************************************/</span>
<a name="l04091"></a>04091 <span class="keywordtype">void</span>
<a name="l04092"></a><a class="code" href="lwpr_8c.html#5fb306d23122c90a7b4dcaa7d9f366bd">04092</a> <a class="code" href="lwpr_8c.html#5fb306d23122c90a7b4dcaa7d9f366bd">getLWPRDistMetric</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">double</span> **D)
<a name="l04093"></a>04093 
<a name="l04094"></a>04094 {
<a name="l04095"></a>04095 
<a name="l04096"></a>04096   <span class="keywordtype">int</span>    i,j,k;
<a name="l04097"></a>04097   RF    *rfptr;
<a name="l04098"></a>04098   <span class="keywordtype">int</span>    n_in_w;
<a name="l04099"></a>04099   <span class="keywordtype">int</span>    diag_only;
<a name="l04100"></a>04100   <span class="keywordtype">double</span> aux;
<a name="l04101"></a>04101 
<a name="l04102"></a>04102   <span class="comment">/* handy variables */</span>
<a name="l04103"></a>04103 
<a name="l04104"></a>04104   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04105"></a>04105   n_in_w    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l04106"></a>04106   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l04107"></a>04107   
<a name="l04108"></a>04108 
<a name="l04109"></a>04109   <span class="keywordflow">if</span> (diag_only) {
<a name="l04110"></a>04110     <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l04111"></a>04111       D[i][i] = sqr(rfptr-&gt;M[i][i]);
<a name="l04112"></a>04112     }
<a name="l04113"></a>04113   } <span class="keywordflow">else</span> {
<a name="l04114"></a>04114     <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l04115"></a>04115       <span class="keywordflow">for</span> (j=i; j&lt;=n_in_w; ++j) {
<a name="l04116"></a>04116         D[i][j] = 0.;
<a name="l04117"></a>04117         <span class="keywordflow">for</span> (k=1; k&lt;=i; ++k) {
<a name="l04118"></a>04118           D[i][j] += rfptr-&gt;M[k][i]*rfptr-&gt;M[k][j];
<a name="l04119"></a>04119         }
<a name="l04120"></a>04120         D[j][i] = D[i][j];
<a name="l04121"></a>04121       }
<a name="l04122"></a>04122     }
<a name="l04123"></a>04123   }
<a name="l04124"></a>04124 
<a name="l04125"></a>04125 }
<a name="l04126"></a>04126 
<a name="l04127"></a>04127 <span class="comment">/*!*****************************************************************************</span>
<a name="l04128"></a>04128 <span class="comment"> *******************************************************************************</span>
<a name="l04129"></a>04129 <span class="comment"> \note  addDimension</span>
<a name="l04130"></a>04130 <span class="comment"> \date  January, 1994</span>
<a name="l04131"></a>04131 <span class="comment"> </span>
<a name="l04132"></a>04132 <span class="comment"> \remarks </span>
<a name="l04133"></a>04133 <span class="comment"> </span>
<a name="l04134"></a>04134 <span class="comment"> add a regression dimensions to the current receptive field</span>
<a name="l04135"></a>04135 <span class="comment"> </span>
<a name="l04136"></a>04136 <span class="comment"> *******************************************************************************</span>
<a name="l04137"></a>04137 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04138"></a>04138 <span class="comment"> </span>
<a name="l04139"></a>04139 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l04140"></a>04140 <span class="comment"> \param[in]     rfID   : the ID of the receptive field</span>
<a name="l04141"></a>04141 <span class="comment"> </span>
<a name="l04142"></a>04142 <span class="comment"> ******************************************************************************/</span>
<a name="l04143"></a>04143 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04144"></a>04144 addDimension(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l04145"></a>04145 
<a name="l04146"></a>04146 {
<a name="l04147"></a>04147   <span class="keywordtype">int</span>    i,j,m;
<a name="l04148"></a>04148   RF    *rfptr;
<a name="l04149"></a>04149   <span class="keywordtype">int</span>    n_in_w;
<a name="l04150"></a>04150   <span class="keywordtype">int</span>    n_in_reg;
<a name="l04151"></a>04151   <span class="keywordtype">int</span>    n_proj;
<a name="l04152"></a>04152   <span class="keywordtype">int</span>    n_out;
<a name="l04153"></a>04153 
<a name="l04154"></a>04154   
<a name="l04155"></a>04155   n_out      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l04156"></a>04156   n_in_w     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l04157"></a>04157   n_in_reg   = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l04158"></a>04158   rfptr      = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04159"></a>04159   n_proj      = rfptr-&gt;n_proj;
<a name="l04160"></a>04160 
<a name="l04161"></a>04161   <span class="keywordflow">if</span> (n_proj == n_in_reg) {
<a name="l04162"></a>04162     <span class="keywordflow">if</span> (DEBUG_FLAG) printf(<span class="stringliteral">"Max.dimensions reached\n"</span>);
<a name="l04163"></a>04163     <span class="keywordflow">return</span> FALSE;
<a name="l04164"></a>04164   }
<a name="l04165"></a>04165 
<a name="l04166"></a>04166   mat_add_shape(&amp;(rfptr-&gt;B),1,0);
<a name="l04167"></a>04167   vec_add_shape(&amp;(rfptr-&gt;ss2),1);
<a name="l04168"></a>04168   rfptr-&gt;ss2[n_proj+1]=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_S2;
<a name="l04169"></a>04169   vec_add_shape(&amp;(rfptr-&gt;dof),1);
<a name="l04170"></a>04170   mat_add_shape(&amp;(rfptr-&gt;SSYres),1,0);
<a name="l04171"></a>04171   mat_add_shape(&amp;(rfptr-&gt;SSXres),1,0);
<a name="l04172"></a>04172   mat_add_shape(&amp;(rfptr-&gt;SXresYres),1,0);
<a name="l04173"></a>04173 
<a name="l04174"></a>04174   mat_add_shape(&amp;(rfptr-&gt;W),1,0);
<a name="l04175"></a>04175   rfptr-&gt;W[n_proj+1][n_proj+1]=1.0;
<a name="l04176"></a>04176   vec_add_shape(&amp;(rfptr-&gt;Wnorm),1);
<a name="l04177"></a>04177 
<a name="l04178"></a>04178   mat_add_shape(&amp;(rfptr-&gt;U),1,0);
<a name="l04179"></a>04179   mat_add_shape(&amp;(rfptr-&gt;H),1,0);
<a name="l04180"></a>04180   vec_add_shape(&amp;(rfptr-&gt;r),1);
<a name="l04181"></a>04181 
<a name="l04182"></a>04182   vec_add_shape(&amp;(rfptr-&gt;sum_weights),1);
<a name="l04183"></a>04183   rfptr-&gt;sum_weights[n_proj+1] = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l04184"></a>04184   vec_add_shape(&amp;(rfptr-&gt;sum_error),1);
<a name="l04185"></a>04185   vec_add_shape(&amp;(rfptr-&gt;sum_error_cvi),1);
<a name="l04186"></a>04186   vec_add_shape(&amp;(rfptr-&gt;n_data),1);
<a name="l04187"></a>04187   vec_add_shape(&amp;(rfptr-&gt;lambda),1);
<a name="l04188"></a>04188   rfptr-&gt;lambda[n_proj+1]=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_lambda;
<a name="l04189"></a>04189   vec_add_shape(&amp;(rfptr-&gt;s),1);
<a name="l04190"></a>04190   
<a name="l04191"></a>04191   ++rfptr-&gt;n_proj;
<a name="l04192"></a>04192 
<a name="l04193"></a>04193   <span class="keywordflow">return</span> TRUE;
<a name="l04194"></a>04194 
<a name="l04195"></a>04195 }
<a name="l04196"></a>04196 
<a name="l04197"></a>04197 <span class="comment">/*!*****************************************************************************</span>
<a name="l04198"></a>04198 <span class="comment"> *******************************************************************************</span>
<a name="l04199"></a>04199 <span class="comment"> \note  checkAddDim</span>
<a name="l04200"></a>04200 <span class="comment"> \date  May 1999</span>
<a name="l04201"></a>04201 <span class="comment"> </span>
<a name="l04202"></a>04202 <span class="comment"> \remarks </span>
<a name="l04203"></a>04203 <span class="comment"> </span>
<a name="l04204"></a>04204 <span class="comment"> checks whether to add dimensions to the regression</span>
<a name="l04205"></a>04205 <span class="comment"> </span>
<a name="l04206"></a>04206 <span class="comment"> *******************************************************************************</span>
<a name="l04207"></a>04207 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04208"></a>04208 <span class="comment"> </span>
<a name="l04209"></a>04209 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l04210"></a>04210 <span class="comment"> \param[in]     rfID   : the ID of the receptive field</span>
<a name="l04211"></a>04211 <span class="comment"></span>
<a name="l04212"></a>04212 <span class="comment"> returns TRUE if dimension should be increased else returns FALSE</span>
<a name="l04213"></a>04213 <span class="comment"> </span>
<a name="l04214"></a>04214 <span class="comment"> ******************************************************************************/</span>
<a name="l04215"></a>04215 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04216"></a>04216 checkAddDim(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l04217"></a>04217 
<a name="l04218"></a>04218 {
<a name="l04219"></a>04219 
<a name="l04220"></a>04220   <span class="keywordtype">int</span>    i,j,m;
<a name="l04221"></a>04221   RF    *rfptr;
<a name="l04222"></a>04222   <span class="keywordtype">int</span>    n_in_w;
<a name="l04223"></a>04223   <span class="keywordtype">int</span>    n_in_reg;
<a name="l04224"></a>04224   <span class="keywordtype">int</span>    n_out;
<a name="l04225"></a>04225   <span class="keywordtype">int</span>    n_proj;
<a name="l04226"></a>04226   <span class="keywordtype">double</span> t;
<a name="l04227"></a>04227   <span class="keywordtype">double</span> prob;
<a name="l04228"></a>04228   <span class="keywordtype">double</span> mse_n_proj;
<a name="l04229"></a>04229   <span class="keywordtype">double</span> mse_n_proj_1;
<a name="l04230"></a>04230 
<a name="l04231"></a>04231   n_in_w    = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l04232"></a>04232   n_in_reg  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l04233"></a>04233   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04234"></a>04234   n_proj    = rfptr-&gt;n_proj;
<a name="l04235"></a>04235 
<a name="l04236"></a>04236   <span class="keywordflow">if</span> (n_proj &gt;= n_in_reg)
<a name="l04237"></a>04237     <span class="keywordflow">return</span> FALSE;
<a name="l04238"></a>04238 
<a name="l04239"></a>04239   <span class="comment">/* this is an attempt to use a t-test as a termination criterion */</span>
<a name="l04240"></a>04240   
<a name="l04241"></a>04241   <span class="comment">/*</span>
<a name="l04242"></a>04242 <span class="comment">  t = rfptr-&gt;B[n_proj][1] * sqrt(rfptr-&gt;ss2[n_proj]) </span>
<a name="l04243"></a>04243 <span class="comment">    / (sqrt(rfptr-&gt;sum_error[n_proj]/rfptr-&gt;sum_weights[n_proj])+TINY_NUMBER);</span>
<a name="l04244"></a>04244 <span class="comment"></span>
<a name="l04245"></a>04245 <span class="comment">  prob = 1.-prob_t(t,rfptr-&gt;sum_weights[n_proj]-rfptr-&gt;dof[n_proj]);</span>
<a name="l04246"></a>04246 <span class="comment"></span>
<a name="l04247"></a>04247 <span class="comment">  if (prob &lt; 0.001) </span>
<a name="l04248"></a>04248 <span class="comment">    return TRUE;</span>
<a name="l04249"></a>04249 <span class="comment"></span>
<a name="l04250"></a>04250 <span class="comment">    */</span>
<a name="l04251"></a>04251 
<a name="l04252"></a>04252   <span class="comment">/* here, the mean squared error of the current regression dimension</span>
<a name="l04253"></a>04253 <span class="comment">     is compared against the previous one. Only if there is a signficant</span>
<a name="l04254"></a>04254 <span class="comment">     improvement in MSE, another dimension gets added. Some additional</span>
<a name="l04255"></a>04255 <span class="comment">     heuristics had to be added to ensure that the MSE decision is </span>
<a name="l04256"></a>04256 <span class="comment">     based on sufficient data */</span>
<a name="l04257"></a>04257 
<a name="l04258"></a>04258 
<a name="l04259"></a>04259   mse_n_proj   = rfptr-&gt;sum_error_cvi[n_proj]  / rfptr-&gt;sum_weights[n_proj];
<a name="l04260"></a>04260   mse_n_proj_1 = rfptr-&gt;sum_error_cvi[n_proj-1]/ rfptr-&gt;sum_weights[n_proj-1];
<a name="l04261"></a>04261  
<a name="l04262"></a>04262   <span class="keywordflow">if</span> (mse_n_proj/mse_n_proj_1 &lt; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].add_threshold  &amp;&amp; 
<a name="l04263"></a>04263       rfptr-&gt;n_data[n_proj]/rfptr-&gt;n_data[n_proj-11] &gt; 0.5 &amp;&amp; 
<a name="l04264"></a>04264         rfptr-&gt;n_data[n_proj]*(1.-rfptr-&gt;lambda[n_proj]) &gt; 0.5) {
<a name="l04265"></a>04265     <span class="comment">/*</span>
<a name="l04266"></a>04266 <span class="comment">    printf("%f %f %f\n",mse_n_proj/mse_n_proj_1,</span>
<a name="l04267"></a>04267 <span class="comment">           rfptr-&gt;n_data[n_proj]/rfptr-&gt;n_data[1],</span>
<a name="l04268"></a>04268 <span class="comment">           rfptr-&gt;n_data[n_proj]*(1.-rfptr-&gt;lambda[n_proj]));</span>
<a name="l04269"></a>04269 <span class="comment">           */</span>
<a name="l04270"></a>04270     <span class="keywordflow">return</span> TRUE;
<a name="l04271"></a>04271   }
<a name="l04272"></a>04272 
<a name="l04273"></a>04273   <span class="keywordflow">return</span> FALSE;
<a name="l04274"></a>04274      
<a name="l04275"></a>04275 }
<a name="l04276"></a>04276 
<a name="l04277"></a>04277 <span class="comment">/*!*****************************************************************************</span>
<a name="l04278"></a>04278 <span class="comment"> *******************************************************************************</span>
<a name="l04279"></a>04279 <span class="comment"> \note  updateDistanceMetric</span>
<a name="l04280"></a>04280 <span class="comment"> \date  April 1999</span>
<a name="l04281"></a>04281 <span class="comment"> </span>
<a name="l04282"></a>04282 <span class="comment"> \remarks </span>
<a name="l04283"></a>04283 <span class="comment"> </span>
<a name="l04284"></a>04284 <span class="comment"> updates the distance metric of a receptive field. Appropriate variables</span>
<a name="l04285"></a>04285 <span class="comment"> must have been assigned before in the structure of the receptive field</span>
<a name="l04286"></a>04286 <span class="comment"> </span>
<a name="l04287"></a>04287 <span class="comment"> *******************************************************************************</span>
<a name="l04288"></a>04288 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04289"></a>04289 <span class="comment"> </span>
<a name="l04290"></a>04290 <span class="comment"> \param[in]     ID       : the ID of the LWPR</span>
<a name="l04291"></a>04291 <span class="comment"> \param[in]     rfID     : the receptive field ID</span>
<a name="l04292"></a>04292 <span class="comment"> \param[in]     x_w      : the input vector in weight space (only normalized)</span>
<a name="l04293"></a>04293 <span class="comment"> \param[in]     x_mz     : the mean zero input vector</span>
<a name="l04294"></a>04294 <span class="comment"> </span>
<a name="l04295"></a>04295 <span class="comment"> ******************************************************************************/</span>
<a name="l04296"></a>04296 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04297"></a>04297 updateDistanceMetric(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_w, Vector x_mz)
<a name="l04298"></a>04298 
<a name="l04299"></a>04299 {
<a name="l04300"></a>04300   RF       *rfptr;
<a name="l04301"></a>04301   <span class="keywordtype">int</span>       n_in_w, n_in_reg, n_out;
<a name="l04302"></a>04302   <span class="keywordtype">int</span>       i, j, k, n, m;
<a name="l04303"></a>04303   <span class="keywordtype">int</span>       n_proj;
<a name="l04304"></a>04304   <span class="keywordtype">double</span>   *s;
<a name="l04305"></a>04305   <span class="keywordtype">double</span>    w;
<a name="l04306"></a>04306   <span class="keywordtype">double</span>  **error_cv;
<a name="l04307"></a>04307   <span class="keywordtype">double</span>  **error;
<a name="l04308"></a>04308   <span class="keywordtype">double</span>    dJdw = 0;
<a name="l04309"></a>04309   <span class="keywordtype">double</span>    dSdw = 0;
<a name="l04310"></a>04310   LWPR     *l;
<a name="l04311"></a>04311   <span class="keywordtype">double</span>    aux;
<a name="l04312"></a>04312   <span class="keywordtype">double</span>    penalty;
<a name="l04313"></a>04313   <span class="keywordtype">double</span>    max_M;
<a name="l04314"></a>04314   Matrix    dwdM;
<a name="l04315"></a>04315   Matrix    dpdM;
<a name="l04316"></a>04316   Matrix    dwwdMdM;
<a name="l04317"></a>04317   Matrix    dppdMdM;
<a name="l04318"></a>04318   <span class="keywordtype">int</span>       diag_only;
<a name="l04319"></a>04319   <span class="keywordtype">double</span>    dJdM;
<a name="l04320"></a>04320   <span class="keywordtype">int</span>      *derivatives_ok;
<a name="l04321"></a>04321   <span class="keywordtype">double</span>    ecv2;
<a name="l04322"></a>04322   <span class="keywordtype">double</span>    e2;
<a name="l04323"></a>04323   <span class="keywordtype">double</span>    eH;
<a name="l04324"></a>04324   <span class="keywordtype">double</span>    ecvb;
<a name="l04325"></a>04325   <span class="keywordtype">double</span>    ucr;
<a name="l04326"></a>04326   <span class="keywordtype">double</span>    transient_multiplier=0;
<a name="l04327"></a>04327   Vector    Ps;
<a name="l04328"></a>04328   <span class="keywordtype">double</span>    PseH=0;
<a name="l04329"></a>04329   <span class="keywordtype">double</span>    Ps2r=0;
<a name="l04330"></a>04330   <span class="keywordtype">double</span>    sPs=0;
<a name="l04331"></a>04331   <span class="keywordtype">double</span>    W;
<a name="l04332"></a>04332   
<a name="l04333"></a>04333   rfptr    = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04334"></a>04334   l        = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l04335"></a>04335   n_in_w   =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l04336"></a>04336   n_in_reg =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg;
<a name="l04337"></a>04337   diag_only=  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l04338"></a>04338   n_out    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out;
<a name="l04339"></a>04339   error_cv =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv;
<a name="l04340"></a>04340   error    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error;
<a name="l04341"></a>04341   s        =  rfptr-&gt;s;
<a name="l04342"></a>04342   n_proj   =  rfptr-&gt;n_proj;
<a name="l04343"></a>04343   w        =  rfptr-&gt;w;
<a name="l04344"></a>04344   Ps       =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_tempp;
<a name="l04345"></a>04345   penalty  =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].penalty;
<a name="l04346"></a>04346   dwdM     =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dwdM;
<a name="l04347"></a>04347   dpdM     =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dpdM;
<a name="l04348"></a>04348   dwwdMdM  =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dwwdMdM;
<a name="l04349"></a>04349   dppdMdM  =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].dppdMdM;
<a name="l04350"></a>04350   derivatives_ok = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].derivatives_ok;
<a name="l04351"></a>04351 
<a name="l04352"></a>04352   <span class="comment">/* first I need to calculate dJ/dw, which is the sum of these </span>
<a name="l04353"></a>04353 <span class="comment">     derivatives over all regression dimension. The update is very</span>
<a name="l04354"></a>04354 <span class="comment">     cheap since almost all calculations are scalar */</span>
<a name="l04355"></a>04355 
<a name="l04356"></a>04356   <span class="comment">/* check in which dimensions we trust the derivatives */</span>
<a name="l04357"></a>04357   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) 
<a name="l04358"></a>04358     derivatives_ok[i] = 
<a name="l04359"></a>04359       rfptr-&gt;n_data[i] &gt; 0.1/(1.-rfptr-&gt;lambda[i]) &amp;&amp; rfptr-&gt;trustworthy;
<a name="l04360"></a>04360 
<a name="l04361"></a>04361   <span class="keywordflow">if</span> (!<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_d_update || !derivatives_ok[1]) {
<a name="l04362"></a>04362     transient_multiplier=0;
<a name="l04363"></a>04363     <span class="keywordflow">return</span>;
<a name="l04364"></a>04364   }
<a name="l04365"></a>04365 
<a name="l04366"></a>04366   <span class="comment">/* precompute useful variables */</span>
<a name="l04367"></a>04367   ecv2 = vec_mult_inner_size(l-&gt;error_cv[n_proj],l-&gt;error_cv[n_proj],n_out);
<a name="l04368"></a>04368   e2   = vec_mult_inner_size(l-&gt;error[n_proj],l-&gt;error[n_proj],n_out);
<a name="l04369"></a>04369   W    = rfptr-&gt;sum_weights[1];
<a name="l04370"></a>04370 
<a name="l04371"></a>04371   transient_multiplier = sqr(sqr(e2/(ecv2+1.e-10))); <span class="comment">/* this is a numerical safety heuristic */</span>
<a name="l04372"></a>04372   <span class="keywordflow">if</span> (transient_multiplier &gt; 1)
<a name="l04373"></a>04373     transient_multiplier = 1;
<a name="l04374"></a>04374 
<a name="l04375"></a>04375   sPs = 0;
<a name="l04376"></a>04376   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) {
<a name="l04377"></a>04377     Ps[i] = s[i]/rfptr-&gt;ss2[i]*derivatives_ok[i];
<a name="l04378"></a>04378     sPs += Ps[i]*s[i];
<a name="l04379"></a>04379   }
<a name="l04380"></a>04380 
<a name="l04381"></a>04381   PseH = 0;
<a name="l04382"></a>04382   Ps2r = 0;
<a name="l04383"></a>04383   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) {
<a name="l04384"></a>04384     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j) {
<a name="l04385"></a>04385       PseH += Ps[i]*error[n_proj][j]*rfptr-&gt;H[i][j];
<a name="l04386"></a>04386     }
<a name="l04387"></a>04387     Ps2r += sqr(Ps[i])*rfptr-&gt;r[i];
<a name="l04388"></a>04388   }
<a name="l04389"></a>04389 
<a name="l04390"></a>04390   dJdw = (ecv2   
<a name="l04391"></a>04391           - rfptr-&gt;sum_error_cv/W
<a name="l04392"></a>04392           - 2. * Ps2r
<a name="l04393"></a>04393           - 2. * PseH ) / W;
<a name="l04394"></a>04394 
<a name="l04395"></a>04395   <span class="comment">/* if required, calculated the second derivatives */</span>
<a name="l04396"></a>04396   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l04397"></a>04397     
<a name="l04398"></a>04398     <span class="comment">/* second derivatives */</span>
<a name="l04399"></a>04399     dSdw =
<a name="l04400"></a>04400       (-ecv2/W
<a name="l04401"></a>04401        -2.*(-1./W-2.*sPs)*PseH
<a name="l04402"></a>04402        +2*e2*sPs
<a name="l04403"></a>04403       -(ecv2-2.*PseH)/W
<a name="l04404"></a>04404        +2.*rfptr-&gt;sum_error_cv/sqr(W)) / W;
<a name="l04405"></a>04405   }
<a name="l04406"></a>04406   
<a name="l04407"></a>04407   <span class="comment">/* the memory traces are updated last */</span>
<a name="l04408"></a>04408   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj; ++i) {
<a name="l04409"></a>04409         
<a name="l04410"></a>04410     <span class="keywordflow">if</span> (derivatives_ok[i])
<a name="l04411"></a>04411       rfptr-&gt;r[i] = rfptr-&gt;r[i] * <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) + 
<a name="l04412"></a>04412         sqr(w*s[i])*ecv2/(1.-w*sPs)*transient_multiplier;
<a name="l04413"></a>04413         
<a name="l04414"></a>04414     aux = w*s[i]/(1.-w*sPs);
<a name="l04415"></a>04415     <span class="keywordflow">for</span> (j=1; j&lt;=n_out; ++j)
<a name="l04416"></a>04416       <span class="keywordflow">if</span> (derivatives_ok[i])
<a name="l04417"></a>04417         rfptr-&gt;H[i][j] = 
<a name="l04418"></a>04418           rfptr-&gt;H[i][j]*<a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) + 
<a name="l04419"></a>04419           aux * l-&gt;error_cv[n_proj][j] * transient_multiplier;
<a name="l04420"></a>04420         
<a name="l04421"></a>04421     
<a name="l04422"></a>04422     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj == 1) { <span class="comment">/* the special one-projection case */</span>
<a name="l04423"></a>04423       
<a name="l04424"></a>04424       ecvb = vec_mult_inner_size(l-&gt;error_cv[i],rfptr-&gt;B[i],n_out);
<a name="l04425"></a>04425       
<a name="l04426"></a>04426       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l04427"></a>04427         
<a name="l04428"></a>04428         rfptr-&gt;T[i][j] = 
<a name="l04429"></a>04429           rfptr-&gt;T[i][j]*<a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w) + 
<a name="l04430"></a>04430           w*(2.*w*ecv2*Ps[i]-ecvb)*x_mz[j]/(1.-w*sPs)*
<a name="l04431"></a>04431           transient_multiplier* derivatives_ok[1];
<a name="l04432"></a>04432         
<a name="l04433"></a>04433         rfptr-&gt;A[i][j] = 
<a name="l04434"></a>04434           rfptr-&gt;A[i][j]*<a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda[i],w)+w*s[i]*x_mz[j]*
<a name="l04435"></a>04435           transient_multiplier* derivatives_ok[1];
<a name="l04436"></a>04436         
<a name="l04437"></a>04437       }
<a name="l04438"></a>04438     }
<a name="l04439"></a>04439   }
<a name="l04440"></a>04440 
<a name="l04441"></a>04441   <span class="comment">/* adjust the derivative in case of the special one-projection case */</span>
<a name="l04442"></a>04442   
<a name="l04443"></a>04443   <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_n_proj == 1) { 
<a name="l04444"></a>04444     ucr = vec_mult_inner_size(rfptr-&gt;W[1],l-&gt;cr,n_in_reg);
<a name="l04445"></a>04445     aux = 0.0;
<a name="l04446"></a>04446     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg; ++j) {
<a name="l04447"></a>04447       aux += (l-&gt;cr[j] - rfptr-&gt;W[1][j]*ucr) * 
<a name="l04448"></a>04448         (rfptr-&gt;T[1][j] - rfptr-&gt;r[1]/rfptr-&gt;ss2[1]*rfptr-&gt;A[1][j]);
<a name="l04449"></a>04449     }
<a name="l04450"></a>04450     dJdw += aux / W / rfptr-&gt;Wnorm[1];
<a name="l04451"></a>04451   }
<a name="l04452"></a>04452   
<a name="l04453"></a>04453   <span class="comment">/* dividing the penalty by the number of inputs tries to</span>
<a name="l04454"></a>04454 <span class="comment">     compensate for the change of penalty due to very many inputs --</span>
<a name="l04455"></a>04455 <span class="comment">     despite the inputs don't matter, the system get penalized for</span>
<a name="l04456"></a>04456 <span class="comment">     those extra inputs -- this tries to avoid this effect */</span>
<a name="l04457"></a>04457   penalty *= w/W/(double)n_in_w;
<a name="l04458"></a>04458   
<a name="l04459"></a>04459   <span class="comment">/* divide dJdw and dSdw by the number of outputs to normalize for the </span>
<a name="l04460"></a>04460 <span class="comment">     number of outputs */</span>
<a name="l04461"></a>04461   dJdw /= (double)n_out;
<a name="l04462"></a>04462   dSdw /= (double)n_out;
<a name="l04463"></a>04463 
<a name="l04464"></a>04464 
<a name="l04465"></a>04465   <span class="comment">/* calculate derivatives of weight w.r.t. to distance metric */</span>
<a name="l04466"></a>04466   calculateDWDM(ID, rfID, x_w, penalty, dwdM, dpdM, dppdMdM, dwwdMdM, &amp;max_M);
<a name="l04467"></a>04467 
<a name="l04468"></a>04468   <span class="comment">/*****************************************************************/</span>
<a name="l04469"></a>04469   <span class="comment">/* update the meta learning rate, learning rate, distance metric */</span>  
<a name="l04470"></a>04470   <span class="comment">/* and h-term in meta learning rate                              */</span>
<a name="l04471"></a>04471   <span class="comment">/*****************************************************************/</span>
<a name="l04472"></a>04472   
<a name="l04473"></a>04473   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w &amp;&amp; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_d_update; ++i) {
<a name="l04474"></a>04474     <span class="keywordflow">for</span> (j=i; j&lt;=n_in_w; ++j) {
<a name="l04475"></a>04475       
<a name="l04476"></a>04476       <span class="comment">/* the second part of the if statment allows us to use a bias</span>
<a name="l04477"></a>04477 <span class="comment">         on D and set known elements to zero -- i.e., no weighting in</span>
<a name="l04478"></a>04478 <span class="comment">         this direction -- numerical problems require that D be not</span>
<a name="l04479"></a>04479 <span class="comment">         zero, thus the TINY_NUMBER stuff */</span>
<a name="l04480"></a>04480       <span class="keywordflow">if</span> ((!diag_only || i==j) &amp;&amp; 
<a name="l04481"></a>04481           rfptr-&gt;D[i][i]&gt;=2.*<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a> &amp;&amp; rfptr-&gt;D[j][j]&gt;=2.*<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) {
<a name="l04482"></a>04482         
<a name="l04483"></a>04483         <span class="comment">/*****************************************************************/</span>
<a name="l04484"></a>04484         <span class="comment">/* update the distance metric: M = M - alpha * (dJdw*dwdM +      */</span>
<a name="l04485"></a>04485         <span class="comment">/* dpdM)                                                         */</span>
<a name="l04486"></a>04486         <span class="comment">/*****************************************************************/</span>
<a name="l04487"></a>04487         
<a name="l04488"></a>04488         dJdM =  
<a name="l04489"></a>04489           (dJdw * dwdM[i][j] + dpdM[i][j]);
<a name="l04490"></a>04490 
<a name="l04491"></a>04491         <span class="comment">/************************************************/</span>
<a name="l04492"></a>04492         <span class="comment">/* second order learning schemes are tried here */</span>
<a name="l04493"></a>04493         <span class="comment">/************************************************/</span>
<a name="l04494"></a>04494         
<a name="l04495"></a>04495         <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l04496"></a>04496           
<a name="l04497"></a>04497           <span class="comment">/* the meta learning rate and the real learning rate */</span>
<a name="l04498"></a>04498           <span class="comment">/* b = b - META_LEARNING_RATE * dJdM * h             */</span>
<a name="l04499"></a>04499           <span class="comment">/* alpha = exp(b)                                    */</span>
<a name="l04500"></a>04500           <span class="comment">/* and also update the memory term h:                */</span>
<a name="l04501"></a>04501           <span class="comment">/* h = (1-alpha dJJdMdM) h - alpha dJdM              */</span>
<a name="l04502"></a>04502           
<a name="l04503"></a>04503           aux = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].meta_learning_rate * rfptr-&gt;h[i][j] * 
<a name="l04504"></a>04504             dJdM * transient_multiplier;
<a name="l04505"></a>04505           
<a name="l04506"></a>04506           <span class="comment">/* prevent too large steps */</span>
<a name="l04507"></a>04507           
<a name="l04508"></a>04508           <span class="keywordflow">if</span> (fabs(aux) &gt; .1) aux = macro_sign(aux) * .1;
<a name="l04509"></a>04509           rfptr-&gt;b[i][j] -= aux;
<a name="l04510"></a>04510           
<a name="l04511"></a>04511           <span class="comment">/* prevent numerical underflow and overflow*/</span>
<a name="l04512"></a>04512           
<a name="l04513"></a>04513           <span class="keywordflow">if</span> (rfptr-&gt;b[i][j] &lt; -10) rfptr-&gt;b[i][j] = -10.;
<a name="l04514"></a>04514           <span class="keywordflow">if</span> (rfptr-&gt;b[i][j] &gt;  10) rfptr-&gt;b[i][j] =  10.;
<a name="l04515"></a>04515           
<a name="l04516"></a>04516           <span class="comment">/* the new learning rate becomes */</span>
<a name="l04517"></a>04517           
<a name="l04518"></a>04518           rfptr-&gt;alpha[i][j] = myExp(rfptr-&gt;b[i][j],FALSE);
<a name="l04519"></a>04519           
<a name="l04520"></a>04520           <span class="comment">/* update the memory trace (note: S = dJdw */</span>
<a name="l04521"></a>04521           
<a name="l04522"></a>04522           aux = 1. - rfptr-&gt;alpha[i][j]  *
<a name="l04523"></a>04523             (dSdw * sqr(dwdM[i][j]) + dJdw * dwwdMdM[i][j] +
<a name="l04524"></a>04524              dppdMdM[i][j]) * transient_multiplier;
<a name="l04525"></a>04525           <span class="keywordflow">if</span> (aux &lt; 0.0) aux = 0.0;
<a name="l04526"></a>04526           
<a name="l04527"></a>04527           rfptr-&gt;h[i][j] = rfptr-&gt;h[i][j] * aux - 
<a name="l04528"></a>04528             rfptr-&gt;alpha[i][j] * dJdM * transient_multiplier;
<a name="l04529"></a>04529           
<a name="l04530"></a>04530         }
<a name="l04531"></a>04531         
<a name="l04532"></a>04532         
<a name="l04533"></a>04533         <span class="comment">/* the final update of the distance metric */</span>
<a name="l04534"></a>04534         
<a name="l04535"></a>04535         aux = rfptr-&gt;alpha[i][j] * dJdM * transient_multiplier;
<a name="l04536"></a>04536         
<a name="l04537"></a>04537         <span class="comment">/* limit the update to be not more than a fraction of</span>
<a name="l04538"></a>04538 <span class="comment">           the magnitude of the max O matrix coefficient */</span>
<a name="l04539"></a>04539         
<a name="l04540"></a>04540         <span class="keywordflow">if</span> (fabs(aux) &gt; 0.1*max_M) {
<a name="l04541"></a>04541           
<a name="l04542"></a>04542           <span class="comment">/* as experience shows that such fast updates are really bad</span>
<a name="l04543"></a>04543 <span class="comment">             I significantly limit the update under such a warning */</span>
<a name="l04544"></a>04544           
<a name="l04545"></a>04545           <span class="comment">/* reduce the learning rate */</span>
<a name="l04546"></a>04546           
<a name="l04547"></a>04547           rfptr-&gt;alpha[i][j] /= 2.0;
<a name="l04548"></a>04548           aux = 0.0;
<a name="l04549"></a>04549           
<a name="l04550"></a>04550           <span class="comment">/* zero the trace terms for meta learning */</span>
<a name="l04551"></a>04551           <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l04552"></a>04552             rfptr-&gt;h[i][j] = 0.0;
<a name="l04553"></a>04553             rfptr-&gt;b[i][j] = log( rfptr-&gt;alpha[i][j]);
<a name="l04554"></a>04554           }
<a name="l04555"></a>04555 
<a name="l04556"></a>04556           <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].write_rfs)
<a name="l04557"></a>04557             printf(<span class="stringliteral">"WARNING:Large M[%d][%d]-Update: ID=%d rfID=%d n_data=%f\n"</span>,
<a name="l04558"></a>04558                    i,j,ID,rfID,rfptr-&gt;n_data[n_proj]);
<a name="l04559"></a>04559         }
<a name="l04560"></a>04560 
<a name="l04561"></a>04561         <span class="keywordflow">if</span> (i==j &amp;&amp; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j]==0) 
<a name="l04562"></a>04562           ;
<a name="l04563"></a>04563         <span class="keywordflow">else</span>
<a name="l04564"></a>04564           rfptr-&gt;M[i][j] -= aux;
<a name="l04565"></a>04565 
<a name="l04566"></a>04566         <span class="keywordflow">if</span> (my_isnan(rfptr-&gt;M[i][j])) {
<a name="l04567"></a>04567           <a class="code" href="lwpr_8c.html#9c159349ffa2c22b1e4d2f26b1a13732">writeRFAscii</a>(ID,rfID,FALSE,<span class="stringliteral">"NaN in M"</span>);
<a name="l04568"></a>04568           printf(<span class="stringliteral">"rfptr-&gt;M[%d][%d]=%f\n"</span>,i,j,rfptr-&gt;M[i][j]);
<a name="l04569"></a>04569           printf(<span class="stringliteral">"%f %f\n"</span>,rfptr-&gt;alpha[i][j] ,dJdM);
<a name="l04570"></a>04570           exit(-1);
<a name="l04571"></a>04571           rfptr-&gt;M[i][j] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_M[i][j];
<a name="l04572"></a>04572         }
<a name="l04573"></a>04573         <span class="keywordflow">if</span> (i==j &amp;&amp; rfptr-&gt;M[i][j] &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) rfptr-&gt;M[i][j]=<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l04574"></a>04574         <span class="keywordflow">if</span> (rfptr-&gt;M[i][j] &gt; <a class="code" href="lwpr_8h.html#903291dbeb9127355bff6edc348567ca">BIG_NUMBER</a>) rfptr-&gt;M[i][j]=<a class="code" href="lwpr_8h.html#903291dbeb9127355bff6edc348567ca">BIG_NUMBER</a>;
<a name="l04575"></a>04575         
<a name="l04576"></a>04576       }
<a name="l04577"></a>04577     }
<a name="l04578"></a>04578   }
<a name="l04579"></a>04579 
<a name="l04580"></a>04580   <span class="comment">/* update the distance metric from the decomposed distance metric */</span>
<a name="l04581"></a>04581   <a class="code" href="lwpr_8c.html#5fb306d23122c90a7b4dcaa7d9f366bd">getLWPRDistMetric</a>(ID,rfID,rfptr-&gt;D);
<a name="l04582"></a>04582   
<a name="l04583"></a>04583 }
<a name="l04584"></a>04584 
<a name="l04585"></a>04585 <span class="comment">/*!*****************************************************************************</span>
<a name="l04586"></a>04586 <span class="comment"> *******************************************************************************</span>
<a name="l04587"></a>04587 <span class="comment">\note  calculateWeightp</span>
<a name="l04588"></a>04588 <span class="comment">\date  Nov 3, 1992</span>
<a name="l04589"></a>04589 <span class="comment"></span>
<a name="l04590"></a>04590 <span class="comment">\remarks </span>
<a name="l04591"></a>04591 <span class="comment"></span>
<a name="l04592"></a>04592 <span class="comment">       calculates the activation of a given rf for a given input vector</span>
<a name="l04593"></a>04593 <span class="comment">       note: special function to void multiple process clash</span>
<a name="l04594"></a>04594 <span class="comment"></span>
<a name="l04595"></a>04595 <span class="comment"> *******************************************************************************</span>
<a name="l04596"></a>04596 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04597"></a>04597 <span class="comment"></span>
<a name="l04598"></a>04598 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l04599"></a>04599 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l04600"></a>04600 <span class="comment"> \param[in]     x     : the input vector</span>
<a name="l04601"></a>04601 <span class="comment"></span>
<a name="l04602"></a>04602 <span class="comment"> ******************************************************************************/</span>
<a name="l04603"></a>04603 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l04604"></a>04604 calculateWeightp(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x)
<a name="l04605"></a>04605 
<a name="l04606"></a>04606 {
<a name="l04607"></a>04607 
<a name="l04608"></a>04608   <span class="keywordtype">int</span>    i,j,k;
<a name="l04609"></a>04609   <span class="keywordtype">double</span> mahal;
<a name="l04610"></a>04610   <span class="keywordtype">double</span> aux;
<a name="l04611"></a>04611 
<a name="l04612"></a>04612 
<a name="l04613"></a>04613   <span class="comment">/* get the mahalanobis distance */</span>
<a name="l04614"></a>04614 
<a name="l04615"></a>04615   mahal = calculateMahalp(ID, rfID, x);
<a name="l04616"></a>04616 
<a name="l04617"></a>04617   <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l04618"></a>04618 
<a name="l04619"></a>04619   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#d751f1b6909c0124a4ca151036b28a0e">GAUSSIAN</a>:
<a name="l04620"></a>04620   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#3b712283b9c65c3898ae8872bf3ad7db">VONMISES</a>:
<a name="l04621"></a>04621   
<a name="l04622"></a>04622     <span class="keywordflow">return</span> (myExp(-0.5*mahal,USE_EXP_LOOKUP));
<a name="l04623"></a>04623 
<a name="l04624"></a>04624   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#f375534d17d8af44b0573ce6698cc8f0">BISQUARE</a>:
<a name="l04625"></a>04625 
<a name="l04626"></a>04626     <span class="keywordflow">if</span> (mahal &gt; 1.0) {
<a name="l04627"></a>04627       <span class="keywordflow">return</span> (0.0);
<a name="l04628"></a>04628     } <span class="keywordflow">else</span> {
<a name="l04629"></a>04629       aux = 1.- mahal;
<a name="l04630"></a>04630       <span class="keywordflow">return</span> (aux * aux);
<a name="l04631"></a>04631     }
<a name="l04632"></a>04632 
<a name="l04633"></a>04633   }
<a name="l04634"></a>04634 
<a name="l04635"></a>04635   <span class="keywordflow">return</span> FALSE;
<a name="l04636"></a>04636 
<a name="l04637"></a>04637 }
<a name="l04638"></a>04638 
<a name="l04639"></a>04639 <span class="comment">/*!*****************************************************************************</span>
<a name="l04640"></a>04640 <span class="comment"> *******************************************************************************</span>
<a name="l04641"></a>04641 <span class="comment">\note  calculateMahalp</span>
<a name="l04642"></a>04642 <span class="comment">\date  Nov 3, 1992</span>
<a name="l04643"></a>04643 <span class="comment"></span>
<a name="l04644"></a>04644 <span class="comment">\remarks </span>
<a name="l04645"></a>04645 <span class="comment"></span>
<a name="l04646"></a>04646 <span class="comment">       calculates the mahalanobis distance</span>
<a name="l04647"></a>04647 <span class="comment">       note: special function to void multiple process clash</span>
<a name="l04648"></a>04648 <span class="comment"></span>
<a name="l04649"></a>04649 <span class="comment"> *******************************************************************************</span>
<a name="l04650"></a>04650 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04651"></a>04651 <span class="comment"></span>
<a name="l04652"></a>04652 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l04653"></a>04653 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l04654"></a>04654 <span class="comment"> \param[in]     x     : the input vector</span>
<a name="l04655"></a>04655 <span class="comment"></span>
<a name="l04656"></a>04656 <span class="comment"> ******************************************************************************/</span>
<a name="l04657"></a>04657 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l04658"></a>04658 calculateMahalp(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x)
<a name="l04659"></a>04659 
<a name="l04660"></a>04660 {
<a name="l04661"></a>04661 
<a name="l04662"></a>04662   <span class="keywordtype">int</span>    i,j,k;
<a name="l04663"></a>04663   RF    *rfptr;
<a name="l04664"></a>04664   <span class="keywordtype">int</span>    diag_only;
<a name="l04665"></a>04665   <span class="keywordtype">double</span> mahal;
<a name="l04666"></a>04666   <span class="keywordtype">double</span> aux;
<a name="l04667"></a>04667   Vector delta;
<a name="l04668"></a>04668   <span class="keywordtype">int</span>    iaux;
<a name="l04669"></a>04669 
<a name="l04670"></a>04670   <span class="comment">/* hand variables */</span>
<a name="l04671"></a>04671 
<a name="l04672"></a>04672   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04673"></a>04673   diag_only = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l04674"></a>04674   delta     = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].delta2;
<a name="l04675"></a>04675   
<a name="l04676"></a>04676   <span class="comment">/* the distance from the center */</span>
<a name="l04677"></a>04677   vec_sub(x,rfptr-&gt;c,delta);
<a name="l04678"></a>04678 
<a name="l04679"></a>04679   <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l04680"></a>04680   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#3b712283b9c65c3898ae8872bf3ad7db">VONMISES</a>:
<a name="l04681"></a>04681     <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w; ++i) {
<a name="l04682"></a>04682       delta[i] = sqrt(1.-cos(delta[i]));
<a name="l04683"></a>04683     }
<a name="l04684"></a>04684     mahal = mat_mahal(rfptr-&gt;D,delta);
<a name="l04685"></a>04685     <span class="keywordflow">break</span>;
<a name="l04686"></a>04686 
<a name="l04687"></a>04687   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#d751f1b6909c0124a4ca151036b28a0e">GAUSSIAN</a>:
<a name="l04688"></a>04688   <span class="keywordflow">default</span>:
<a name="l04689"></a>04689     <span class="comment">/* the mahalanobis distance */</span>
<a name="l04690"></a>04690     mahal = mat_mahal(rfptr-&gt;D,delta);
<a name="l04691"></a>04691     <span class="keywordflow">break</span>;
<a name="l04692"></a>04692   }
<a name="l04693"></a>04693 
<a name="l04694"></a>04694 
<a name="l04695"></a>04695   <span class="keywordflow">return</span> mahal;
<a name="l04696"></a>04696 
<a name="l04697"></a>04697 }
<a name="l04698"></a>04698 
<a name="l04699"></a>04699 
<a name="l04700"></a>04700 <span class="comment">/*!*****************************************************************************</span>
<a name="l04701"></a>04701 <span class="comment"> *******************************************************************************</span>
<a name="l04702"></a>04702 <span class="comment"> \note  checkNeighborhood</span>
<a name="l04703"></a>04703 <span class="comment"> \date  June, 1995</span>
<a name="l04704"></a>04704 <span class="comment"> </span>
<a name="l04705"></a>04705 <span class="comment"> \remarks </span>
<a name="l04706"></a>04706 <span class="comment"> checks whether two receptive fields overlap according to the cutoff </span>
<a name="l04707"></a>04707 <span class="comment"> threshold</span>
<a name="l04708"></a>04708 <span class="comment">  </span>
<a name="l04709"></a>04709 <span class="comment"> *******************************************************************************</span>
<a name="l04710"></a>04710 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04711"></a>04711 <span class="comment"> </span>
<a name="l04712"></a>04712 <span class="comment"> \param[in]     ID     : the ID of the model</span>
<a name="l04713"></a>04713 <span class="comment"> \param[in]     rfID1  : ID of the one RF</span>
<a name="l04714"></a>04714 <span class="comment"> \param[in]     rfID2  : ID of other RF</span>
<a name="l04715"></a>04715 <span class="comment"></span>
<a name="l04716"></a>04716 <span class="comment"> returns the maximal common activation between the two RFs</span>
<a name="l04717"></a>04717 <span class="comment"> </span>
<a name="l04718"></a>04718 <span class="comment"> ******************************************************************************/</span>
<a name="l04719"></a>04719 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l04720"></a>04720 checkNeighborhood(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID1, <span class="keywordtype">int</span> rfID2) 
<a name="l04721"></a>04721 
<a name="l04722"></a>04722 {
<a name="l04723"></a>04723 
<a name="l04724"></a>04724   <span class="keywordtype">int</span>     i,j,k;
<a name="l04725"></a>04725   <span class="keywordtype">int</span>     n_in_w;
<a name="l04726"></a>04726   <span class="keywordtype">int</span>     n_nn;
<a name="l04727"></a>04727   RF     *rfptr1,*rfptr2;
<a name="l04728"></a>04728   <span class="keywordtype">int</span>    *nn;
<a name="l04729"></a>04729   <span class="keywordtype">double</span>  mahal=0;
<a name="l04730"></a>04730   <span class="keywordtype">double</span>  aux;
<a name="l04731"></a>04731   <span class="keywordtype">double</span>  w;
<a name="l04732"></a>04732 
<a name="l04733"></a>04733 
<a name="l04734"></a>04734   <span class="keywordflow">if</span> (rfID1 == rfID2 || rfID2 &lt; 1 || rfID1 &lt; 1) 
<a name="l04735"></a>04735     <span class="keywordflow">return</span> 0.0;
<a name="l04736"></a>04736 
<a name="l04737"></a>04737   rfptr1 = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID1];
<a name="l04738"></a>04738   rfptr2 = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID2];
<a name="l04739"></a>04739   n_in_w = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l04740"></a>04740 
<a name="l04741"></a>04741   <span class="comment">/* compute the point of nearest distance between the receptive fields,</span>
<a name="l04742"></a>04742 <span class="comment">     but only from the diagonal distance metric */</span>
<a name="l04743"></a>04743 
<a name="l04744"></a>04744   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i) {
<a name="l04745"></a>04745     aux = (rfptr1-&gt;D[i][i]*rfptr1-&gt;c[i] + rfptr2-&gt;D[i][i]*rfptr2-&gt;c[i])/
<a name="l04746"></a>04746       (rfptr1-&gt;D[i][i] + rfptr2-&gt;D[i][i] + <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) - rfptr1-&gt;c[i];
<a name="l04747"></a>04747     mahal += sqr(aux)*rfptr1-&gt;D[i][i];
<a name="l04748"></a>04748   }
<a name="l04749"></a>04749 
<a name="l04750"></a>04750   w = myExp(-0.5*mahal,USE_EXP_LOOKUP);
<a name="l04751"></a>04751 
<a name="l04752"></a>04752   <span class="keywordflow">if</span> (w &gt; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].w_gen) {
<a name="l04753"></a>04753     <span class="keywordflow">if</span> (addNNToRF(ID,rfID1,rfID2,w))
<a name="l04754"></a>04754       addNNToRF(ID,rfID2,rfID1,w);
<a name="l04755"></a>04755   } <span class="keywordflow">else</span> {
<a name="l04756"></a>04756     <span class="keywordflow">if</span> (deleteNNFromRF(ID,rfID1,rfID2))
<a name="l04757"></a>04757       deleteNNFromRF(ID,rfID2,rfID1);
<a name="l04758"></a>04758   }
<a name="l04759"></a>04759 
<a name="l04760"></a>04760   <span class="keywordflow">return</span> w;
<a name="l04761"></a>04761 }
<a name="l04762"></a>04762 
<a name="l04763"></a>04763 <span class="comment">/*!*****************************************************************************</span>
<a name="l04764"></a>04764 <span class="comment"> *******************************************************************************</span>
<a name="l04765"></a>04765 <span class="comment"> \note  addNNToRF</span>
<a name="l04766"></a>04766 <span class="comment"> \date  June, 1995</span>
<a name="l04767"></a>04767 <span class="comment"> </span>
<a name="l04768"></a>04768 <span class="comment"> \remarks </span>
<a name="l04769"></a>04769 <span class="comment"> </span>
<a name="l04770"></a>04770 <span class="comment"> adds a NN ID to a RF</span>
<a name="l04771"></a>04771 <span class="comment"> </span>
<a name="l04772"></a>04772 <span class="comment"> *******************************************************************************</span>
<a name="l04773"></a>04773 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04774"></a>04774 <span class="comment"> </span>
<a name="l04775"></a>04775 <span class="comment"> \param[in]     ID       : the ID of the SDC</span>
<a name="l04776"></a>04776 <span class="comment"> \param[in]     rfID     : ID of the RF to which we want to add the ID</span>
<a name="l04777"></a>04777 <span class="comment"> \param[in]     add_rfID : the ID to be added</span>
<a name="l04778"></a>04778 <span class="comment"> \param[in]     w        : the weight of neighborhood</span>
<a name="l04779"></a>04779 <span class="comment"> </span>
<a name="l04780"></a>04780 <span class="comment"> ******************************************************************************/</span>
<a name="l04781"></a>04781 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04782"></a>04782 addNNToRF(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> add_rfID, <span class="keywordtype">double</span> w) 
<a name="l04783"></a>04783 
<a name="l04784"></a>04784 {
<a name="l04785"></a>04785 
<a name="l04786"></a>04786   <span class="keywordtype">int</span>      i,j,k;
<a name="l04787"></a>04787   <span class="keywordtype">int</span>      n_nn;
<a name="l04788"></a>04788   RF      *rfptr;
<a name="l04789"></a>04789   iVector  nn;
<a name="l04790"></a>04790   Vector   nnw;
<a name="l04791"></a>04791 
<a name="l04792"></a>04792   <span class="keywordflow">if</span> (rfID == add_rfID)
<a name="l04793"></a>04793     <span class="keywordflow">return</span> FALSE;
<a name="l04794"></a>04794 
<a name="l04795"></a>04795   n_nn = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID].n_nn;
<a name="l04796"></a>04796   rfptr = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04797"></a>04797 
<a name="l04798"></a>04798   <span class="comment">/* is the add_rfID already present? */</span>
<a name="l04799"></a>04799   <span class="keywordflow">for</span> (i=1; i&lt;=n_nn; ++i) 
<a name="l04800"></a>04800     <span class="keywordflow">if</span> (rfptr-&gt;nn[i] == add_rfID) 
<a name="l04801"></a>04801       <span class="keywordflow">return</span> FALSE;
<a name="l04802"></a>04802 
<a name="l04803"></a>04803   <span class="comment">/* do we need more memory? */</span>
<a name="l04804"></a>04804   <span class="keywordflow">if</span> (n_nn+1 &gt; rfptr-&gt;n_nn_allocated) {
<a name="l04805"></a>04805     ivec_add_shape(&amp;(rfptr-&gt;nn),<a class="code" href="lwpr_8h.html#6b96ba77d08e0d538a0e114fba48c167">NN_BLOCK</a>);
<a name="l04806"></a>04806     vec_add_shape(&amp;(rfptr-&gt;nnw),<a class="code" href="lwpr_8h.html#6b96ba77d08e0d538a0e114fba48c167">NN_BLOCK</a>);
<a name="l04807"></a>04807     rfptr-&gt;n_nn_allocated += <a class="code" href="lwpr_8h.html#6b96ba77d08e0d538a0e114fba48c167">NN_BLOCK</a>;
<a name="l04808"></a>04808   }
<a name="l04809"></a>04809 
<a name="l04810"></a>04810   <span class="keywordflow">if</span> (n_nn == 0 ) {
<a name="l04811"></a>04811 
<a name="l04812"></a>04812     rfptr-&gt;nn[1]  = add_rfID;
<a name="l04813"></a>04813     rfptr-&gt;nnw[1] = w;
<a name="l04814"></a>04814 
<a name="l04815"></a>04815   } <span class="keywordflow">else</span> {
<a name="l04816"></a>04816     
<a name="l04817"></a>04817     <span class="comment">/* add the new neighbor in ascending distance */</span>
<a name="l04818"></a>04818     <span class="keywordflow">for</span> (i=n_nn; i &gt;= 1; --i) {
<a name="l04819"></a>04819       <span class="keywordflow">if</span> (w &gt; rfptr-&gt;nnw[i]) {
<a name="l04820"></a>04820         rfptr-&gt;nn[i+1]  = rfptr-&gt;nn[i];
<a name="l04821"></a>04821         rfptr-&gt;nnw[i+1] = rfptr-&gt;nnw[i];
<a name="l04822"></a>04822         <span class="keywordflow">if</span> (i==1) {
<a name="l04823"></a>04823           rfptr-&gt;nn[i]  = add_rfID;
<a name="l04824"></a>04824           rfptr-&gt;nnw[i] = w;
<a name="l04825"></a>04825         }
<a name="l04826"></a>04826       } <span class="keywordflow">else</span> {
<a name="l04827"></a>04827         rfptr-&gt;nn[i+1]  = add_rfID;
<a name="l04828"></a>04828         rfptr-&gt;nnw[i+1] = w;
<a name="l04829"></a>04829         <span class="keywordflow">break</span>;
<a name="l04830"></a>04830       }
<a name="l04831"></a>04831     }
<a name="l04832"></a>04832 
<a name="l04833"></a>04833   }
<a name="l04834"></a>04834 
<a name="l04835"></a>04835   ++rfptr-&gt;n_nn;
<a name="l04836"></a>04836 
<a name="l04837"></a>04837   <span class="keywordflow">return</span> TRUE;
<a name="l04838"></a>04838 
<a name="l04839"></a>04839 }
<a name="l04840"></a>04840 
<a name="l04841"></a>04841 <span class="comment">/*!*****************************************************************************</span>
<a name="l04842"></a>04842 <span class="comment"> *******************************************************************************</span>
<a name="l04843"></a>04843 <span class="comment"> \note  deleteNNFromRF</span>
<a name="l04844"></a>04844 <span class="comment"> \date  June, 1995</span>
<a name="l04845"></a>04845 <span class="comment"> </span>
<a name="l04846"></a>04846 <span class="comment"> \remarks </span>
<a name="l04847"></a>04847 <span class="comment"> </span>
<a name="l04848"></a>04848 <span class="comment"> deletes a NN from a rf</span>
<a name="l04849"></a>04849 <span class="comment"> </span>
<a name="l04850"></a>04850 <span class="comment"> *******************************************************************************</span>
<a name="l04851"></a>04851 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04852"></a>04852 <span class="comment"> </span>
<a name="l04853"></a>04853 <span class="comment"> \param[in]     ID       : the ID of the SDC</span>
<a name="l04854"></a>04854 <span class="comment"> \param[in]     rfID     : ID of the RF from which we want to delete the ID</span>
<a name="l04855"></a>04855 <span class="comment"> \param[in]     del_rfID : the ID to be deleted</span>
<a name="l04856"></a>04856 <span class="comment"> </span>
<a name="l04857"></a>04857 <span class="comment"> ******************************************************************************/</span>
<a name="l04858"></a>04858 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04859"></a>04859 deleteNNFromRF(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> del_rfID) 
<a name="l04860"></a>04860 
<a name="l04861"></a>04861 {
<a name="l04862"></a>04862 
<a name="l04863"></a>04863   <span class="keywordtype">int</span>  i,j,k;
<a name="l04864"></a>04864   RF  *rfptr;
<a name="l04865"></a>04865   <span class="keywordtype">int</span> *nn;
<a name="l04866"></a>04866 
<a name="l04867"></a>04867   <span class="keywordflow">if</span> (rfID == del_rfID)
<a name="l04868"></a>04868     <span class="keywordflow">return</span> FALSE;
<a name="l04869"></a>04869 
<a name="l04870"></a>04870   rfptr = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04871"></a>04871 
<a name="l04872"></a>04872   <span class="keywordflow">for</span> (i=1; i&lt;=rfptr-&gt;n_nn; ++i) {
<a name="l04873"></a>04873     <span class="keywordflow">if</span> (rfptr-&gt;nn[i] == del_rfID) {
<a name="l04874"></a>04874       <span class="keywordflow">for</span> (j=i; j &lt; rfptr-&gt;n_nn; ++j) {
<a name="l04875"></a>04875         rfptr-&gt;nn[j]  = rfptr-&gt;nn[j+1];
<a name="l04876"></a>04876         rfptr-&gt;nnw[j] = rfptr-&gt;nnw[j+1];
<a name="l04877"></a>04877       }
<a name="l04878"></a>04878       rfptr-&gt;nn[j] = 0;
<a name="l04879"></a>04879       rfptr-&gt;nnw[j] = 0;
<a name="l04880"></a>04880       --rfptr-&gt;n_nn;
<a name="l04881"></a>04881       <span class="keywordflow">return</span> TRUE;
<a name="l04882"></a>04882     }
<a name="l04883"></a>04883   }
<a name="l04884"></a>04884 
<a name="l04885"></a>04885   <span class="keywordflow">return</span> FALSE;
<a name="l04886"></a>04886   
<a name="l04887"></a>04887 }
<a name="l04888"></a>04888 
<a name="l04889"></a>04889 <span class="comment">/*!*****************************************************************************</span>
<a name="l04890"></a>04890 <span class="comment"> *******************************************************************************</span>
<a name="l04891"></a>04891 <span class="comment"> \note  swapNNID</span>
<a name="l04892"></a>04892 <span class="comment"> \date  June, 1995</span>
<a name="l04893"></a>04893 <span class="comment"> </span>
<a name="l04894"></a>04894 <span class="comment"> \remarks </span>
<a name="l04895"></a>04895 <span class="comment"> </span>
<a name="l04896"></a>04896 <span class="comment"> replaces a NN ID with another NN ID</span>
<a name="l04897"></a>04897 <span class="comment"> </span>
<a name="l04898"></a>04898 <span class="comment"> *******************************************************************************</span>
<a name="l04899"></a>04899 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04900"></a>04900 <span class="comment"> </span>
<a name="l04901"></a>04901 <span class="comment"> \param[in]     ID       : the ID of the SDC</span>
<a name="l04902"></a>04902 <span class="comment"> \param[in]     rfID     : ID of the RF from which we want to delete the ID</span>
<a name="l04903"></a>04903 <span class="comment"> \param[in]     old_rfID : the ID to be swapped</span>
<a name="l04904"></a>04904 <span class="comment"> \param[in]     new_rfID : the new ID to be swapped in</span>
<a name="l04905"></a>04905 <span class="comment"> </span>
<a name="l04906"></a>04906 <span class="comment"> ******************************************************************************/</span>
<a name="l04907"></a>04907 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04908"></a>04908 swapNNID(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, <span class="keywordtype">int</span> old_rfID, <span class="keywordtype">int</span> new_rfID) 
<a name="l04909"></a>04909 
<a name="l04910"></a>04910 {
<a name="l04911"></a>04911 
<a name="l04912"></a>04912   <span class="keywordtype">int</span>  i,j,k;
<a name="l04913"></a>04913   RF  *rfptr;
<a name="l04914"></a>04914   <span class="keywordtype">int</span> *nn;
<a name="l04915"></a>04915 
<a name="l04916"></a>04916   <span class="keywordflow">if</span> (old_rfID == new_rfID)
<a name="l04917"></a>04917     <span class="keywordflow">return</span> FALSE;
<a name="l04918"></a>04918 
<a name="l04919"></a>04919   rfptr = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l04920"></a>04920 
<a name="l04921"></a>04921   <span class="keywordflow">for</span> (i=1; i&lt;=rfptr-&gt;n_nn; ++i) {
<a name="l04922"></a>04922     <span class="keywordflow">if</span> (rfptr-&gt;nn[i] == old_rfID) {
<a name="l04923"></a>04923       rfptr-&gt;nn[i] = new_rfID;
<a name="l04924"></a>04924       <span class="keywordflow">return</span> TRUE;
<a name="l04925"></a>04925     }
<a name="l04926"></a>04926   }
<a name="l04927"></a>04927 
<a name="l04928"></a>04928   <span class="keywordflow">return</span> FALSE;
<a name="l04929"></a>04929   
<a name="l04930"></a>04930 }
<a name="l04931"></a>04931 
<a name="l04932"></a>04932 <span class="comment">/*!*****************************************************************************</span>
<a name="l04933"></a>04933 <span class="comment"> *******************************************************************************</span>
<a name="l04934"></a>04934 <span class="comment"> \note  checkLWPRNN</span>
<a name="l04935"></a>04935 <span class="comment"> \date  June 2000</span>
<a name="l04936"></a>04936 <span class="comment"> </span>
<a name="l04937"></a>04937 <span class="comment"> \remarks </span>
<a name="l04938"></a>04938 <span class="comment"> </span>
<a name="l04939"></a>04939 <span class="comment"> exhaustively updates the entire NN structure</span>
<a name="l04940"></a>04940 <span class="comment"> </span>
<a name="l04941"></a>04941 <span class="comment"> *******************************************************************************</span>
<a name="l04942"></a>04942 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l04943"></a>04943 <span class="comment"> </span>
<a name="l04944"></a>04944 <span class="comment"> \param[in]     ID       : the ID of the SDC</span>
<a name="l04945"></a>04945 <span class="comment"> </span>
<a name="l04946"></a>04946 <span class="comment"> ******************************************************************************/</span>
<a name="l04947"></a>04947 <span class="keywordtype">int</span>
<a name="l04948"></a><a class="code" href="lwpr_8h.html#0a0845649c5d307cab16e3c11721e94b">04948</a> <a class="code" href="lwpr_8c.html#0a0845649c5d307cab16e3c11721e94b">checkLWPRNN</a>(<span class="keywordtype">int</span> ID) 
<a name="l04949"></a>04949 
<a name="l04950"></a>04950 {
<a name="l04951"></a>04951 
<a name="l04952"></a>04952   <span class="keywordtype">int</span>    i,j,k;
<a name="l04953"></a>04953   <span class="keywordtype">double</span> w;
<a name="l04954"></a>04954   <span class="keywordtype">double</span> aux, aux1;
<a name="l04955"></a>04955   <span class="keywordtype">int</span>    index_prune;
<a name="l04956"></a>04956   <span class="keywordtype">int</span>    index_non_prune;
<a name="l04957"></a>04957   <span class="keywordtype">char</span>   stmp[100];
<a name="l04958"></a>04958   <span class="keywordtype">int</span>   *pruneIDs;
<a name="l04959"></a>04959 
<a name="l04960"></a>04960   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l04961"></a>04961     <span class="keywordflow">return</span> FALSE;
<a name="l04962"></a>04962 
<a name="l04963"></a>04963   <span class="keywordflow">if</span> (!<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_nn)
<a name="l04964"></a>04964     <span class="keywordflow">return</span> FALSE;
<a name="l04965"></a>04965 
<a name="l04966"></a>04966   pruneIDs = my_ivector(1,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf);
<a name="l04967"></a>04967 
<a name="l04968"></a>04968   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf; ++i) {
<a name="l04969"></a>04969     <span class="keywordflow">for</span> (j=1; j&lt;=i-1; ++j) {
<a name="l04970"></a>04970 
<a name="l04971"></a>04971       w = checkNeighborhood(ID,i,j);
<a name="l04972"></a>04972 
<a name="l04973"></a>04973       <span class="comment">/* pruning if co-activation is too much */</span>
<a name="l04974"></a>04974       <span class="keywordflow">if</span> (w &gt; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].w_prune) {
<a name="l04975"></a>04975         index_prune = j;
<a name="l04976"></a>04976         index_non_prune = i;
<a name="l04977"></a>04977         aux  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[i].sum_error_cv;
<a name="l04978"></a>04978         aux1 = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[j].sum_error_cv;
<a name="l04979"></a>04979         <span class="keywordflow">if</span> (aux &gt; aux1) {
<a name="l04980"></a>04980           index_prune = i;
<a name="l04981"></a>04981           index_non_prune = j;
<a name="l04982"></a>04982         }
<a name="l04983"></a>04983         pruneIDs[index_prune]=index_non_prune;
<a name="l04984"></a>04984         printf(<span class="stringliteral">"Prune: %d (overlap with %d) -- activation = %f\n"</span>,index_prune,index_non_prune,w);
<a name="l04985"></a>04985       }
<a name="l04986"></a>04986 
<a name="l04987"></a>04987     }
<a name="l04988"></a>04988     <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[i].next_nn_check = i-1;
<a name="l04989"></a>04989   }
<a name="l04990"></a>04990 
<a name="l04991"></a>04991   <span class="comment">/* prune RFs if necessary */</span>
<a name="l04992"></a>04992   <span class="keywordflow">for</span> (i=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf; i&gt;=1; --i) {
<a name="l04993"></a>04993 
<a name="l04994"></a>04994     <span class="keywordflow">if</span> (pruneIDs[i] == 0)
<a name="l04995"></a>04995       <span class="keywordflow">continue</span>;
<a name="l04996"></a>04996 
<a name="l04997"></a>04997     sprintf(stmp,<span class="stringliteral">"overlap prune due to %d"</span>,pruneIDs[i]);
<a name="l04998"></a>04998     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].write_rfs) 
<a name="l04999"></a>04999       <a class="code" href="lwpr_8c.html#9c159349ffa2c22b1e4d2f26b1a13732">writeRFAscii</a>(ID,i,TRUE,stmp);
<a name="l05000"></a>05000     sprintf(stmp,<span class="stringliteral">"this RF caused overlap prune of %d"</span>,i);
<a name="l05001"></a>05001     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].write_rfs) 
<a name="l05002"></a>05002       <a class="code" href="lwpr_8c.html#9c159349ffa2c22b1e4d2f26b1a13732">writeRFAscii</a>(ID,pruneIDs[i],TRUE,stmp);
<a name="l05003"></a>05003     <a class="code" href="lwpr_8c.html#1a9c86129044ef0a65a68684926c456a">deleteRF</a>(ID,i);
<a name="l05004"></a>05004     ++<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_pruned_overlap;
<a name="l05005"></a>05005   }
<a name="l05006"></a>05006 
<a name="l05007"></a>05007   my_free_ivector(pruneIDs,1,<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_rf);
<a name="l05008"></a>05008 
<a name="l05009"></a>05009   <span class="keywordflow">return</span> TRUE;
<a name="l05010"></a>05010   
<a name="l05011"></a>05011 }
<a name="l05012"></a>05012 
<a name="l05013"></a>05013 <span class="comment">/*!*****************************************************************************</span>
<a name="l05014"></a>05014 <span class="comment"> *******************************************************************************</span>
<a name="l05015"></a>05015 <span class="comment"> \note  addRFManual</span>
<a name="l05016"></a>05016 <span class="comment"> \date  January, 1994</span>
<a name="l05017"></a>05017 <span class="comment"> </span>
<a name="l05018"></a>05018 <span class="comment"> \remarks </span>
<a name="l05019"></a>05019 <span class="comment"> </span>
<a name="l05020"></a>05020 <span class="comment"> adds a receptive field to the given LWPR due to manual user request</span>
<a name="l05021"></a>05021 <span class="comment"> </span>
<a name="l05022"></a>05022 <span class="comment"> *******************************************************************************</span>
<a name="l05023"></a>05023 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05024"></a>05024 <span class="comment"> </span>
<a name="l05025"></a>05025 <span class="comment"> \param[in]     ID        : the ID of the LWPR</span>
<a name="l05026"></a>05026 <span class="comment"> \param[in]     x         : the location where to add the center</span>
<a name="l05027"></a>05027 <span class="comment"> \param[in]     D         : the distance metric to be assigned</span>
<a name="l05028"></a>05028 <span class="comment"> </span>
<a name="l05029"></a>05029 <span class="comment"> ******************************************************************************/</span>
<a name="l05030"></a>05030 <span class="keywordtype">int</span> 
<a name="l05031"></a><a class="code" href="lwpr_8h.html#6d0c416bbca5a5e119368b4a499ac12b">05031</a> <a class="code" href="lwpr_8c.html#6d0c416bbca5a5e119368b4a499ac12b">addRFManual</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> **D)
<a name="l05032"></a>05032 {
<a name="l05033"></a>05033 
<a name="l05034"></a>05034   <span class="keywordtype">int</span>       i,j;
<a name="l05035"></a>05035   LWPR     *s;
<a name="l05036"></a>05036   <span class="keywordtype">int</span>       rfIDaux;
<a name="l05037"></a>05037   Vector    temp;  
<a name="l05038"></a>05038   Matrix    M;
<a name="l05039"></a>05039 
<a name="l05040"></a>05040   s = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l05041"></a>05041 
<a name="l05042"></a>05042   <span class="comment">/**********************************************/</span>
<a name="l05043"></a>05043   <span class="comment">/* normalize the input                        */</span>
<a name="l05044"></a>05044   <span class="comment">/**********************************************/</span>
<a name="l05045"></a>05045 
<a name="l05046"></a>05046   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_w; ++i) {
<a name="l05047"></a>05047     s-&gt;x[i] = x[i]/s-&gt;norm_in_w[i];
<a name="l05048"></a>05048   }
<a name="l05049"></a>05049 
<a name="l05050"></a>05050   <span class="comment">/* get the initial distance metric M by cholesky decomposition */</span>
<a name="l05051"></a>05051   temp = my_vector(1,s-&gt;n_in_w);
<a name="l05052"></a>05052   M    = my_matrix(1,s-&gt;n_in_w,1,s-&gt;n_in_w);
<a name="l05053"></a>05053   mat_equal_size(D,s-&gt;n_in_w,s-&gt;n_in_w,M);
<a name="l05054"></a>05054 
<a name="l05055"></a>05055   <span class="keywordflow">if</span> (!my_choldc(M,s-&gt;n_in_w,temp)) {
<a name="l05056"></a>05056 
<a name="l05057"></a>05057     printf(<span class="stringliteral">"ERROR: Matrix is not positive definite\n"</span>);
<a name="l05058"></a>05058     <span class="keywordflow">return</span> FALSE;
<a name="l05059"></a>05059 
<a name="l05060"></a>05060   } <span class="keywordflow">else</span> {
<a name="l05061"></a>05061 
<a name="l05062"></a>05062     <span class="comment">/* since choldc returns the M matrix as lower triangular matrix</span>
<a name="l05063"></a>05063 <span class="comment">       in M, and the diagonal elements in temp, I have</span>
<a name="l05064"></a>05064 <span class="comment">       to fix this nonsense */</span>
<a name="l05065"></a>05065 
<a name="l05066"></a>05066     <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_w; ++i) {
<a name="l05067"></a>05067       <span class="keywordflow">for</span> (j=1; j&lt;=s-&gt;n_in_w; ++j) {
<a name="l05068"></a>05068         M[i][j] = M[j][i];
<a name="l05069"></a>05069         <span class="keywordflow">if</span> (i==j) {
<a name="l05070"></a>05070           M[i][j] = temp[i];
<a name="l05071"></a>05071         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i&gt;j) {
<a name="l05072"></a>05072           M[i][j] = 0.0;
<a name="l05073"></a>05073         }
<a name="l05074"></a>05074       }
<a name="l05075"></a>05075     }
<a name="l05076"></a>05076 
<a name="l05077"></a>05077   }
<a name="l05078"></a>05078 
<a name="l05079"></a>05079   <span class="comment">// the add the RF </span>
<a name="l05080"></a>05080   rfIDaux = 
<a name="l05081"></a>05081     addRF(ID,s-&gt;init_n_proj,s-&gt;init_n_proj_2nd,<a class="code" href="lwpr_8h.html#6b96ba77d08e0d538a0e114fba48c167">NN_BLOCK</a>);
<a name="l05082"></a>05082   
<a name="l05083"></a>05083   <span class="keywordflow">if</span> (rfIDaux != FALSE) {
<a name="l05084"></a>05084     initRF(ID, rfIDaux, s-&gt;x, M);
<a name="l05085"></a>05085   }
<a name="l05086"></a>05086 
<a name="l05087"></a>05087   my_free_vector(temp,1,s-&gt;n_in_w);
<a name="l05088"></a>05088   my_free_matrix(M,1,s-&gt;n_in_w,1,s-&gt;n_in_w);
<a name="l05089"></a>05089 
<a name="l05090"></a>05090   <span class="keywordflow">return</span> TRUE;
<a name="l05091"></a>05091 
<a name="l05092"></a>05092 }
<a name="l05093"></a>05093 
<a name="l05094"></a>05094 
<a name="l05095"></a>05095 <span class="comment">/*!*****************************************************************************</span>
<a name="l05096"></a>05096 <span class="comment"> *******************************************************************************</span>
<a name="l05097"></a>05097 <span class="comment"> \note  calculateDWDM</span>
<a name="l05098"></a>05098 <span class="comment"> \date  December, 2004</span>
<a name="l05099"></a>05099 <span class="comment"> </span>
<a name="l05100"></a>05100 <span class="comment"> \remarks </span>
<a name="l05101"></a>05101 <span class="comment"> </span>
<a name="l05102"></a>05102 <span class="comment"> calculate first and second derivates of the kernel weight w.r.t. the distance</span>
<a name="l05103"></a>05103 <span class="comment"> metric</span>
<a name="l05104"></a>05104 <span class="comment"> </span>
<a name="l05105"></a>05105 <span class="comment"> *******************************************************************************</span>
<a name="l05106"></a>05106 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05107"></a>05107 <span class="comment"> </span>
<a name="l05108"></a>05108 <span class="comment"> \param[in]     ID        : the ID of the LWPR</span>
<a name="l05109"></a>05109 <span class="comment"> \param[in]     x         : the location where to add the center</span>
<a name="l05110"></a>05110 <span class="comment"> \param[in]     D         : the distance metric to be assigned</span>
<a name="l05111"></a>05111 <span class="comment"> </span>
<a name="l05112"></a>05112 <span class="comment"> ******************************************************************************/</span>
<a name="l05113"></a>05113 <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l05114"></a>05114 calculateDWDM(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_w, <span class="keywordtype">double</span> penalty, Matrix dwdM, Matrix dpdM,
<a name="l05115"></a>05115               Matrix dppdMdM, Matrix dwwdMdM, <span class="keywordtype">double</span> *max_M)
<a name="l05116"></a>05116 
<a name="l05117"></a>05117 {
<a name="l05118"></a>05118 
<a name="l05119"></a>05119   RF       *rfptr;
<a name="l05120"></a>05120   <span class="keywordtype">int</span>       n_in_w;
<a name="l05121"></a>05121   <span class="keywordtype">int</span>       i, j, k, n, m;
<a name="l05122"></a>05122   <span class="keywordtype">double</span>    aux;
<a name="l05123"></a>05123   <span class="keywordtype">double</span>   *xx;
<a name="l05124"></a>05124   <span class="keywordtype">double</span>    sum_aux,sum_aux1=0;
<a name="l05125"></a>05125   <span class="keywordtype">int</span>       diag_only;
<a name="l05126"></a>05126   <span class="keywordtype">double</span>    w;
<a name="l05127"></a>05127   
<a name="l05128"></a>05128   rfptr    = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l05129"></a>05129   xx       =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].x_temp_w;
<a name="l05130"></a>05130   n_in_w   =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l05131"></a>05131   diag_only=  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].diag_only;
<a name="l05132"></a>05132   w        =  rfptr-&gt;w;
<a name="l05133"></a>05133 
<a name="l05134"></a>05134   <span class="comment">/* calculate the dwdM, the derivative of the weights with respect</span>
<a name="l05135"></a>05135 <span class="comment">     to the distance metric coefficients. For this, I first have to</span>
<a name="l05136"></a>05136 <span class="comment">     calculate the derivative dDdM */</span>
<a name="l05137"></a>05137   <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l05138"></a>05138   <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#3b712283b9c65c3898ae8872bf3ad7db">VONMISES</a>:
<a name="l05139"></a>05139     <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i)
<a name="l05140"></a>05140       xx[i] = sqrt(1.-cos(x_w[i] - rfptr-&gt;c[i]));
<a name="l05141"></a>05141     <span class="keywordflow">break</span>;
<a name="l05142"></a>05142   <span class="keywordflow">default</span>:
<a name="l05143"></a>05143     <span class="keywordflow">for</span> (i=1; i&lt;=n_in_w; ++i)
<a name="l05144"></a>05144       xx[i] = x_w[i] - rfptr-&gt;c[i];
<a name="l05145"></a>05145   }
<a name="l05146"></a>05146     
<a name="l05147"></a>05147   <span class="comment">/* dD_ijdM_nm = M_im * kron_nj + M_jm * kron_ni */</span>
<a name="l05148"></a>05148   
<a name="l05149"></a>05149   *max_M = 0.0;
<a name="l05150"></a>05150 
<a name="l05151"></a>05151   <span class="keywordflow">for</span> (n=1; n&lt;=n_in_w; ++n) {
<a name="l05152"></a>05152     <span class="keywordflow">for</span> (m=n; m&lt;=n_in_w; ++m) {
<a name="l05153"></a>05153 
<a name="l05154"></a>05154       dwdM[n][m] = 0.;
<a name="l05155"></a>05155       dpdM[n][m] = 0.;
<a name="l05156"></a>05156       sum_aux    = 0.;
<a name="l05157"></a>05157       
<a name="l05158"></a>05158       <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l05159"></a>05159         sum_aux1   = 0.;
<a name="l05160"></a>05160         dppdMdM[n][m] = 0.0;
<a name="l05161"></a>05161       }
<a name="l05162"></a>05162       
<a name="l05163"></a>05163       <span class="comment">/* now take the derivative of D with respect to nm_th element of M */</span>
<a name="l05164"></a>05164       
<a name="l05165"></a>05165       <span class="keywordflow">if</span> (diag_only &amp;&amp; n==m) {
<a name="l05166"></a>05166         
<a name="l05167"></a>05167         <span class="keywordflow">if</span> (fabs(rfptr-&gt;M[n][m]) &gt; *max_M) *max_M = fabs(rfptr-&gt;M[n][m]);
<a name="l05168"></a>05168         
<a name="l05169"></a>05169         aux = rfptr-&gt;M[n][n] * 2.;
<a name="l05170"></a>05170         dwdM[n][n] = xx[n] * xx[n] * aux;
<a name="l05171"></a>05171         sum_aux = rfptr-&gt;D[n][n]*aux;
<a name="l05172"></a>05172         <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) sum_aux1+= sqr(aux);
<a name="l05173"></a>05173           
<a name="l05174"></a>05174       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!diag_only){
<a name="l05175"></a>05175           
<a name="l05176"></a>05176         <span class="keywordflow">if</span> (fabs(rfptr-&gt;M[n][m]) &gt; *max_M) *max_M = fabs(rfptr-&gt;M[n][m]);
<a name="l05177"></a>05177         
<a name="l05178"></a>05178         <span class="keywordflow">for</span> (i=n; i&lt;=n_in_w; ++i) {
<a name="l05179"></a>05179           
<a name="l05180"></a>05180           <span class="comment">/* aux corresponds to the in_th (= ni_th) element of dDdM_nm */</span>
<a name="l05181"></a>05181           <span class="comment">/* this is directly processed for dwdM and dpenaltydo        */</span>
<a name="l05182"></a>05182           
<a name="l05183"></a>05183           <span class="keywordflow">if</span> (i == m) {
<a name="l05184"></a>05184             aux = rfptr-&gt;M[n][i] * 2.;
<a name="l05185"></a>05185             dwdM[n][m] += xx[i] * xx[m] * aux;
<a name="l05186"></a>05186             sum_aux += rfptr-&gt;D[i][m]*aux;
<a name="l05187"></a>05187             <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) sum_aux1+= sqr(aux);
<a name="l05188"></a>05188           } <span class="keywordflow">else</span> {
<a name="l05189"></a>05189             aux = rfptr-&gt;M[n][i];
<a name="l05190"></a>05190             dwdM[n][m] += 2. * xx[i] * xx[m] * aux;
<a name="l05191"></a>05191             sum_aux += 2.*rfptr-&gt;D[i][m]*aux;
<a name="l05192"></a>05192             <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) sum_aux1+= 2.*sqr(aux);
<a name="l05193"></a>05193           }
<a name="l05194"></a>05194           
<a name="l05195"></a>05195         }
<a name="l05196"></a>05196         
<a name="l05197"></a>05197       }   
<a name="l05198"></a>05198 
<a name="l05199"></a>05199       <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l05200"></a>05200       <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#f375534d17d8af44b0573ce6698cc8f0">BISQUARE</a>:
<a name="l05201"></a>05201         dwdM[n][m] *= -sqrt(w);
<a name="l05202"></a>05202         <span class="keywordflow">break</span>;
<a name="l05203"></a>05203       <span class="keywordflow">default</span>:
<a name="l05204"></a>05204         dwdM[n][m] *= -0.5*w;
<a name="l05205"></a>05205       }
<a name="l05206"></a>05206       
<a name="l05207"></a>05207       dpdM[n][m]  = 2.*penalty*sum_aux;
<a name="l05208"></a>05208 
<a name="l05209"></a>05209       
<a name="l05210"></a>05210       <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].allow_meta_learning) {
<a name="l05211"></a>05211         dppdMdM[n][m] = 2. * penalty * ( 2* rfptr-&gt;D[m][m] + sum_aux1 );
<a name="l05212"></a>05212         dppdMdM[m][n] = dppdMdM[n][m];
<a name="l05213"></a>05213 
<a name="l05214"></a>05214         <span class="keywordflow">switch</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].kernel_function) {
<a name="l05215"></a>05215         <span class="keywordflow">case</span> <a class="code" href="lwpr_8h.html#f375534d17d8af44b0573ce6698cc8f0">BISQUARE</a>:
<a name="l05216"></a>05216           dwwdMdM[n][m]   = sqr(dwdM[n][m])/w/2.0 - 2*sqrt(w)*sqr(xx[m]);
<a name="l05217"></a>05217           <span class="keywordflow">break</span>;
<a name="l05218"></a>05218         <span class="keywordflow">default</span>:
<a name="l05219"></a>05219           dwwdMdM[n][m] = sqr(dwdM[n][m])/w - w*sqr(xx[m]);
<a name="l05220"></a>05220         }
<a name="l05221"></a>05221         dwwdMdM[m][n] = dwwdMdM[n][m];
<a name="l05222"></a>05222       }
<a name="l05223"></a>05223       
<a name="l05224"></a>05224     }
<a name="l05225"></a>05225   }
<a name="l05226"></a>05226     
<a name="l05227"></a>05227 }
<a name="l05228"></a>05228 
<a name="l05229"></a>05229 <span class="comment">/*!*****************************************************************************</span>
<a name="l05230"></a>05230 <span class="comment"> *******************************************************************************</span>
<a name="l05231"></a>05231 <span class="comment"> \note  addDataToLWPRReg2nd</span>
<a name="l05232"></a>05232 <span class="comment"> \date  March 1999</span>
<a name="l05233"></a>05233 <span class="comment"> </span>
<a name="l05234"></a>05234 <span class="comment"> \remarks </span>
<a name="l05235"></a>05235 <span class="comment"> </span>
<a name="l05236"></a>05236 <span class="comment"> Adds a data point to the 2nd regression model</span>
<a name="l05237"></a>05237 <span class="comment"> </span>
<a name="l05238"></a>05238 <span class="comment"> *******************************************************************************</span>
<a name="l05239"></a>05239 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05240"></a>05240 <span class="comment"> </span>
<a name="l05241"></a>05241 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l05242"></a>05242 <span class="comment"> \param[in]     x_w    : the input vector for the weights</span>
<a name="l05243"></a>05243 <span class="comment"> \param[in]     x      : the input vector for the regression</span>
<a name="l05244"></a>05244 <span class="comment"> \param[in]     y      : the output vector for the regression</span>
<a name="l05245"></a>05245 <span class="comment"> \param[in]     w_misc : additional weight for weighted regression</span>
<a name="l05246"></a>05246 <span class="comment"> \param[in]     flag   : FALSE if y is an output, TRUE if y is an error</span>
<a name="l05247"></a>05247 <span class="comment"> \param[in,out] rfID   : neighborhood rfID for input, max activated rfID for output</span>
<a name="l05248"></a>05248 <span class="comment"> </span>
<a name="l05249"></a>05249 <span class="comment"> ******************************************************************************/</span>
<a name="l05250"></a>05250 <span class="keywordtype">int</span> 
<a name="l05251"></a><a class="code" href="lwpr_8h.html#f6946c02c183446e688108322397f65b">05251</a> <a class="code" href="lwpr_8c.html#f6946c02c183446e688108322397f65b">addDataToLWPRReg2ndPredictConf</a>(<span class="keywordtype">int</span> ID, 
<a name="l05252"></a>05252                                Vector x_w, 
<a name="l05253"></a>05253                                Vector x, 
<a name="l05254"></a>05254                                Vector y, 
<a name="l05255"></a>05255                                <span class="keywordtype">double</span> w_misc,
<a name="l05256"></a>05256                                <span class="keywordtype">int</span> flag, 
<a name="l05257"></a>05257                                <span class="keywordtype">int</span> *rfID, 
<a name="l05258"></a>05258                                Vector y_pred, 
<a name="l05259"></a>05259                                Vector conf)
<a name="l05260"></a>05260 {
<a name="l05261"></a>05261   <span class="keywordtype">int</span> i,rc;
<a name="l05262"></a>05262   <span class="keywordtype">double</span> aux=0;
<a name="l05263"></a>05263 
<a name="l05264"></a>05264   rc = addDataToLWPRReg2nd(ID,x_w,x,y,w_misc,flag,rfID);
<a name="l05265"></a>05265 
<a name="l05266"></a>05266   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd; ++i) {
<a name="l05267"></a>05267     y_pred[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted_2nd[i];
<a name="l05268"></a>05268     conf[i]   = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_conf_2nd[i];
<a name="l05269"></a>05269     aux += y_pred[i];
<a name="l05270"></a>05270   }
<a name="l05271"></a>05271 
<a name="l05272"></a>05272   <span class="keywordflow">if</span> (aux != 0.0)
<a name="l05273"></a>05273     <span class="keywordflow">return</span> rc;
<a name="l05274"></a>05274   <span class="keywordflow">else</span>
<a name="l05275"></a>05275     <span class="keywordflow">return</span> FALSE;
<a name="l05276"></a>05276 
<a name="l05277"></a>05277 }
<a name="l05278"></a>05278 
<a name="l05279"></a>05279 <span class="keywordtype">int</span> 
<a name="l05280"></a>05280 addDataToLWPRReg2ndPredict(<span class="keywordtype">int</span> ID, 
<a name="l05281"></a>05281                            Vector x_w, 
<a name="l05282"></a>05282                            Vector x, 
<a name="l05283"></a>05283                            Vector y, 
<a name="l05284"></a>05284                            <span class="keywordtype">double</span> w_misc,
<a name="l05285"></a>05285                            <span class="keywordtype">int</span> flag, 
<a name="l05286"></a>05286                            <span class="keywordtype">int</span> *rfID, 
<a name="l05287"></a>05287                            Vector y_pred)
<a name="l05288"></a>05288 {
<a name="l05289"></a>05289   <span class="keywordtype">int</span> i,rc;
<a name="l05290"></a>05290   <span class="keywordtype">double</span> aux=0;
<a name="l05291"></a>05291 
<a name="l05292"></a>05292   rc = addDataToLWPRReg2nd(ID,x_w, x,y,w_misc,flag,rfID);
<a name="l05293"></a>05293 
<a name="l05294"></a>05294   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd; ++i) {
<a name="l05295"></a>05295     y_pred[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].sum_y_predicted_2nd[i];
<a name="l05296"></a>05296     aux += y_pred[i];
<a name="l05297"></a>05297   }
<a name="l05298"></a>05298 
<a name="l05299"></a>05299   <span class="keywordflow">if</span> (aux != 0.0)
<a name="l05300"></a>05300     <span class="keywordflow">return</span> rc;
<a name="l05301"></a>05301   <span class="keywordflow">else</span>
<a name="l05302"></a>05302     <span class="keywordflow">return</span> FALSE;
<a name="l05303"></a>05303 
<a name="l05304"></a>05304 }
<a name="l05305"></a>05305 
<a name="l05306"></a>05306 <span class="keywordtype">int</span> 
<a name="l05307"></a>05307 addDataToLWPRReg2nd(<span class="keywordtype">int</span> ID, 
<a name="l05308"></a>05308                     Vector x_w, 
<a name="l05309"></a>05309                     Vector x, 
<a name="l05310"></a>05310                     Vector y, 
<a name="l05311"></a>05311                     <span class="keywordtype">double</span> w_misc,
<a name="l05312"></a>05312                     <span class="keywordtype">int</span> flag, 
<a name="l05313"></a>05313                     <span class="keywordtype">int</span> *rfID)
<a name="l05314"></a>05314 {
<a name="l05315"></a>05315   <span class="keywordtype">int</span>      i,j,k,r;
<a name="l05316"></a>05316   <span class="keywordtype">double</span>   max_activation=0;
<a name="l05317"></a>05317   <span class="keywordtype">int</span>      index_max;
<a name="l05318"></a>05318   <span class="keywordtype">double</span>   activation;
<a name="l05319"></a>05319   <span class="keywordtype">int</span>      rfIDaux;
<a name="l05320"></a>05320   <span class="keywordtype">double</span>   aux,aux1;
<a name="l05321"></a>05321   LWPR     *s;
<a name="l05322"></a>05322   <span class="keywordtype">char</span>     stmp[100];
<a name="l05323"></a>05323   <span class="keywordtype">double</span>   dofs;
<a name="l05324"></a>05324 
<a name="l05325"></a>05325   <span class="keyword">static</span> <span class="keywordtype">int</span> count_updates = -1;
<a name="l05326"></a>05326 
<a name="l05327"></a>05327   s = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l05328"></a>05328 
<a name="l05329"></a>05329   <span class="comment">/**********************************************/</span>
<a name="l05330"></a>05330   <span class="comment">/* normalize the inputs and outputs           */</span>
<a name="l05331"></a>05331   <span class="comment">/**********************************************/</span>
<a name="l05332"></a>05332 
<a name="l05333"></a>05333   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_reg_2nd; ++i) {
<a name="l05334"></a>05334     s-&gt;x_2nd[i] = x[i]/s-&gt;norm_in_reg_2nd[i];
<a name="l05335"></a>05335   }
<a name="l05336"></a>05336 
<a name="l05337"></a>05337   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_in_w; ++i) {
<a name="l05338"></a>05338     s-&gt;x_w[i] = x_w[i]/s-&gt;norm_in_w[i];
<a name="l05339"></a>05339   }
<a name="l05340"></a>05340 
<a name="l05341"></a>05341   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_out_2nd; ++i) {
<a name="l05342"></a>05342     s-&gt;y_2nd[i] = y[i]/s-&gt;norm_out_2nd[i];
<a name="l05343"></a>05343   }
<a name="l05344"></a>05344 
<a name="l05345"></a>05345   <span class="comment">/*****************************************************************/</span>
<a name="l05346"></a>05346   <span class="comment">/* Run through all receptive fields and update their             */</span>
<a name="l05347"></a>05347   <span class="comment">/* parameters appropriately                                      */</span>
<a name="l05348"></a>05348   <span class="comment">/*****************************************************************/</span>
<a name="l05349"></a>05349      
<a name="l05350"></a>05350   sum_activation      = 0;
<a name="l05351"></a>05351   max_activation      = 0;
<a name="l05352"></a>05352   index_max           = 0;
<a name="l05353"></a>05353   s-&gt;mean_n_proj_2nd  = 0.0;
<a name="l05354"></a>05354   s-&gt;contrib_n_rf     = 0.0;
<a name="l05355"></a>05355   
<a name="l05356"></a>05356   <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_out_2nd; ++i) {
<a name="l05357"></a>05357     s-&gt;sum_y_predicted_2nd[i]  =0.0;
<a name="l05358"></a>05358     s-&gt;sum_y_predicted2_2nd[i] =0.0;
<a name="l05359"></a>05359     s-&gt;sum_y_conf_2nd[i]       =0.0;
<a name="l05360"></a>05360   }
<a name="l05361"></a>05361 
<a name="l05362"></a>05362   <span class="keywordflow">for</span> (r=1; r&lt;=s-&gt;n_rf; ++r) {
<a name="l05363"></a>05363 
<a name="l05364"></a>05364     <span class="comment">/* zero the weight to recognize which RF was updated */</span>
<a name="l05365"></a>05365     s-&gt;rfs[i].w = 0;
<a name="l05366"></a>05366 
<a name="l05367"></a>05367     <span class="comment">/* fudge in the nearest neighbor add */</span>
<a name="l05368"></a>05368     <span class="keywordflow">if</span> (s-&gt;use_nn &amp;&amp; *rfID &gt; 0 &amp;&amp; *rfID &lt;= s-&gt;n_rf) {
<a name="l05369"></a>05369       <span class="keywordflow">if</span> ( (r &gt; s-&gt;max_nn_comp &amp;&amp; max_activation &gt; s-&gt;w_gen) || 
<a name="l05370"></a>05370            r &gt; s-&gt;rfs[*rfID].n_nn)
<a name="l05371"></a>05371         <span class="keywordflow">break</span>;
<a name="l05372"></a>05372       i = s-&gt;rfs[*rfID].nn[r];
<a name="l05373"></a>05373     } <span class="keywordflow">else</span> {
<a name="l05374"></a>05374       i = r;
<a name="l05375"></a>05375     }
<a name="l05376"></a>05376 
<a name="l05377"></a>05377     s-&gt;mean_n_proj_2nd  += (double) s-&gt;rfs[i].n_proj_2nd;
<a name="l05378"></a>05378 
<a name="l05379"></a>05379     <span class="comment">/* get the activation weight */</span>
<a name="l05380"></a>05380     activation = s-&gt;rfs[i].w = calculateWeight(ID,i,s-&gt;x_w);
<a name="l05381"></a>05381  
<a name="l05382"></a>05382     <span class="comment">/* should we update this local model ? */</span>
<a name="l05383"></a>05383     <span class="keywordflow">if</span> (activation &lt; <a class="code" href="lwpr_8h.html#b04f685e26a29b32fd50369b1b15dfec">ACTIVATION_THRESHOLD</a>) {
<a name="l05384"></a>05384       s-&gt;rfs[i].w = 0;
<a name="l05385"></a>05385       <span class="keywordflow">continue</span>;
<a name="l05386"></a>05386     } 
<a name="l05387"></a>05387 
<a name="l05388"></a>05388     <span class="comment">/* yes, we are going to update now */</span>
<a name="l05389"></a>05389 
<a name="l05390"></a>05390    <span class="comment">/* update the mean and variance, return the mean subtracted input for</span>
<a name="l05391"></a>05391 <span class="comment">      regression */</span>
<a name="l05392"></a>05392     updateMeanVar2nd(ID,i,s-&gt;x_2nd,s-&gt;x_mz_2nd);
<a name="l05393"></a>05393 
<a name="l05394"></a>05394     <span class="keywordflow">if</span> (DEBUG_FLAG) {
<a name="l05395"></a>05395       printf(<span class="stringliteral">"w=%f\n"</span>,activation);
<a name="l05396"></a>05396       print_vec(<span class="stringliteral">"x_mz_2nd"</span>,s-&gt;x_mz_2nd);
<a name="l05397"></a>05397     }
<a name="l05398"></a>05398 
<a name="l05399"></a>05399     <span class="comment">/* create a fake training point if error-based learning is on */</span>
<a name="l05400"></a>05400     createFakeTarget2nd(ID,i,s-&gt;x_mz_2nd,s-&gt;y_2nd,flag,s-&gt;y_mz_2nd);
<a name="l05401"></a>05401     
<a name="l05402"></a>05402     <span class="comment">/* update the mean and variance of the outputs, return the mean </span>
<a name="l05403"></a>05403 <span class="comment">       subtracted output */</span>
<a name="l05404"></a>05404     updateRegMeanVar2nd(ID,i,s-&gt;y_mz_2nd,s-&gt;y_mz_2nd);
<a name="l05405"></a>05405 
<a name="l05406"></a>05406 
<a name="l05407"></a>05407     <span class="keywordflow">if</span> (DEBUG_FLAG) {
<a name="l05408"></a>05408       print_vec(<span class="stringliteral">"y_mz_2nd"</span>,s-&gt;y_mz_2nd);
<a name="l05409"></a>05409       getchar();
<a name="l05410"></a>05410     }
<a name="l05411"></a>05411 
<a name="l05412"></a>05412     <span class="comment">/* calculate regression update */</span>
<a name="l05413"></a>05413     calculateRegression2nd(ID,i,s-&gt;x_mz_2nd,s-&gt;y_mz_2nd);
<a name="l05414"></a>05414     
<a name="l05415"></a>05415     <span class="comment">/* update adminstrative variables */</span>
<a name="l05416"></a>05416     updateAdmVars2nd(ID,i);
<a name="l05417"></a>05417 
<a name="l05418"></a>05418     <span class="comment">/* accumulate the sum of predictions */</span>
<a name="l05419"></a>05419     <span class="keywordflow">if</span> (s-&gt;rfs[i].trustworthy) {
<a name="l05420"></a>05420       sum_activation += activation;
<a name="l05421"></a>05421       <span class="keywordflow">for</span> (j=1; j&lt;=s-&gt;n_out; ++j) {
<a name="l05422"></a>05422         s-&gt;sum_y_predicted_2nd[j]  += s-&gt;ypred_2nd[j]*activation;
<a name="l05423"></a>05423         s-&gt;sum_y_predicted2_2nd[j] += sqr(s-&gt;ypred_2nd[j])*activation;
<a name="l05424"></a>05424         dofs = s-&gt;rfs[i].sum_weights_2nd[1];
<a name="l05425"></a>05425         aux  = 1;
<a name="l05426"></a>05426         <span class="keywordflow">for</span> (k=1; k&lt;=s-&gt;rfs[i].n_proj_2nd; ++k) {
<a name="l05427"></a>05427           dofs -= s-&gt;rfs[i].dof_2nd[k];
<a name="l05428"></a>05428           aux  += sqr(s-&gt;rfs[i].s_2nd[k])/s-&gt;rfs[i].ss2_2nd[k]*activation;
<a name="l05429"></a>05429         }
<a name="l05430"></a>05430         <span class="keywordflow">if</span> (dofs &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>)
<a name="l05431"></a>05431           dofs = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l05432"></a>05432         s-&gt;sum_y_conf_2nd[j] += activation*s-&gt;rfs[i].sum_error_2nd[s-&gt;rfs[i].n_proj_2nd]/
<a name="l05433"></a>05433           dofs*aux;
<a name="l05434"></a>05434       }
<a name="l05435"></a>05435     } <span class="keywordflow">else</span> {
<a name="l05436"></a>05436       <span class="comment">/* indicate that this RF did not contribute to predictions */</span>
<a name="l05437"></a>05437       s-&gt;rfs[i].w = 0;
<a name="l05438"></a>05438     }
<a name="l05439"></a>05439 
<a name="l05440"></a>05440     <span class="comment">/* check if another dimension has to be added */</span>
<a name="l05441"></a>05441     <span class="keywordflow">if</span> (s-&gt;allow_addDim) {
<a name="l05442"></a>05442       <span class="keywordflow">if</span> (checkAddDim2nd(ID,i)){
<a name="l05443"></a>05443         addDimension2nd(ID,i);
<a name="l05444"></a>05444       }
<a name="l05445"></a>05445     }
<a name="l05446"></a>05446 
<a name="l05447"></a>05447     <span class="comment">/* I have to keep track of the largestactivation */</span>
<a name="l05448"></a>05448     
<a name="l05449"></a>05449     <span class="keywordflow">if</span> (activation &gt; max_activation) {
<a name="l05450"></a>05450       max_activation = activation;
<a name="l05451"></a>05451       index_max      = i;
<a name="l05452"></a>05452     }
<a name="l05453"></a>05453 
<a name="l05454"></a>05454  
<a name="l05455"></a>05455   }
<a name="l05456"></a>05456 
<a name="l05457"></a>05457   <span class="comment">/* finish some statistics */</span>
<a name="l05458"></a>05458 
<a name="l05459"></a>05459   --r;
<a name="l05460"></a>05460   <span class="keywordflow">if</span> (r &gt; 0) {
<a name="l05461"></a>05461     s-&gt;mean_n_proj_2nd  /= (double) r;
<a name="l05462"></a>05462   }
<a name="l05463"></a>05463   s-&gt;contrib_n_rf = r;
<a name="l05464"></a>05464 
<a name="l05465"></a>05465   <span class="comment">/* this is the current prediction for the newly added data point,</span>
<a name="l05466"></a>05466 <span class="comment">     AFTER the RFs have been updated */</span>
<a name="l05467"></a>05467 
<a name="l05468"></a>05468   <span class="keywordflow">if</span> (sum_activation &gt; 0) {
<a name="l05469"></a>05469     <span class="keywordflow">for</span> (i=1; i&lt;=s-&gt;n_out_2nd; ++i) {
<a name="l05470"></a>05470       <span class="comment">/* first computations without taking the output normalization into account */</span>
<a name="l05471"></a>05471       s-&gt;sum_y_predicted_2nd[i] = 
<a name="l05472"></a>05472         s-&gt;sum_y_predicted_2nd[i]/sum_activation;
<a name="l05473"></a>05473       aux = fabs(s-&gt;sum_y_predicted2_2nd[i]/sum_activation - 
<a name="l05474"></a>05474              sqr(s-&gt;sum_y_predicted_2nd[i]))/sum_activation;
<a name="l05475"></a>05475       s-&gt;sum_y_conf_2nd[i] = sqrt(s-&gt;sum_y_conf_2nd[i]/sqr(sum_activation)+aux);
<a name="l05476"></a>05476 
<a name="l05477"></a>05477       <span class="comment">/* now add the correction for output normalization */</span>
<a name="l05478"></a>05478       s-&gt;sum_y_predicted_2nd[i] *= s-&gt;norm_out_2nd[i];
<a name="l05479"></a>05479       s-&gt;sum_y_conf_2nd[i] *= s-&gt;norm_out_2nd[i];
<a name="l05480"></a>05480 
<a name="l05481"></a>05481     }
<a name="l05482"></a>05482   }
<a name="l05483"></a>05483 
<a name="l05484"></a>05484   *rfID = index_max;
<a name="l05485"></a>05485 
<a name="l05486"></a>05486   <span class="keywordflow">return</span> TRUE;
<a name="l05487"></a>05487   
<a name="l05488"></a>05488 }
<a name="l05489"></a>05489 
<a name="l05490"></a>05490 <span class="comment">/*!*****************************************************************************</span>
<a name="l05491"></a>05491 <span class="comment"> *******************************************************************************</span>
<a name="l05492"></a>05492 <span class="comment">\note  updateMeanVar2nd</span>
<a name="l05493"></a>05493 <span class="comment">\date  Sept, 1996</span>
<a name="l05494"></a>05494 <span class="comment"></span>
<a name="l05495"></a>05495 <span class="comment">\remarks </span>
<a name="l05496"></a>05496 <span class="comment"></span>
<a name="l05497"></a>05497 <span class="comment">       update the weighted mean and variance of the 2nd model of </span>
<a name="l05498"></a>05498 <span class="comment">       an RF and return a centered input vector for regression</span>
<a name="l05499"></a>05499 <span class="comment">            </span>
<a name="l05500"></a>05500 <span class="comment">        </span>
<a name="l05501"></a>05501 <span class="comment">       NOTE: the weight w must be assigned in the RF structure already</span>
<a name="l05502"></a>05502 <span class="comment"></span>
<a name="l05503"></a>05503 <span class="comment"> *******************************************************************************</span>
<a name="l05504"></a>05504 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05505"></a>05505 <span class="comment"></span>
<a name="l05506"></a>05506 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l05507"></a>05507 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l05508"></a>05508 <span class="comment"> \param[in]     x     : the input vector for regression</span>
<a name="l05509"></a>05509 <span class="comment"> \param[out]    xmz   : x-mean_x</span>
<a name="l05510"></a>05510 <span class="comment"></span>
<a name="l05511"></a>05511 <span class="comment"> ******************************************************************************/</span>
<a name="l05512"></a>05512 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05513"></a>05513 updateMeanVar2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x, Vector xmz)
<a name="l05514"></a>05514 {
<a name="l05515"></a>05515 
<a name="l05516"></a>05516   <span class="keywordtype">int</span>    i,j,k;
<a name="l05517"></a>05517   RF    *rfptr;
<a name="l05518"></a>05518   <span class="keywordtype">int</span>    n_in_reg_2nd;
<a name="l05519"></a>05519   <span class="keywordtype">double</span> w, lambda_2nd;
<a name="l05520"></a>05520 
<a name="l05521"></a>05521   <span class="comment">/* handy variables */</span>
<a name="l05522"></a>05522 
<a name="l05523"></a>05523   rfptr         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l05524"></a>05524   w             = rfptr-&gt;w;
<a name="l05525"></a>05525   lambda_2nd    = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[1],w);
<a name="l05526"></a>05526   n_in_reg_2nd  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l05527"></a>05527   
<a name="l05528"></a>05528   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_reg_2nd; ++i) {
<a name="l05529"></a>05529 
<a name="l05530"></a>05530     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets_2nd) {
<a name="l05531"></a>05531       rfptr-&gt;mean_x_reg_2nd[i] = 
<a name="l05532"></a>05532         (rfptr-&gt;sum_weights_2nd[1] * rfptr-&gt;mean_x_reg_2nd[i] * lambda_2nd + x[i]*w) /
<a name="l05533"></a>05533         (rfptr-&gt;sum_weights_2nd[1] *lambda_2nd + w);
<a name="l05534"></a>05534     }
<a name="l05535"></a>05535       
<a name="l05536"></a>05536     rfptr-&gt;var_x_reg_2nd[i] = 
<a name="l05537"></a>05537       (rfptr-&gt;sum_weights_2nd[1] * rfptr-&gt;var_x_reg_2nd[i] * lambda_2nd  + 
<a name="l05538"></a>05538                    sqr(x[i]-rfptr-&gt;mean_x_reg_2nd[i])*w)/
<a name="l05539"></a>05539       (rfptr-&gt;sum_weights_2nd[1]  * lambda_2nd + w);
<a name="l05540"></a>05540 
<a name="l05541"></a>05541     xmz[i] = (x[i] - rfptr-&gt;mean_x_reg_2nd[i]);
<a name="l05542"></a>05542 
<a name="l05543"></a>05543   }
<a name="l05544"></a>05544 
<a name="l05545"></a>05545 }
<a name="l05546"></a>05546 
<a name="l05547"></a>05547 <span class="comment">/*!*****************************************************************************</span>
<a name="l05548"></a>05548 <span class="comment"> *******************************************************************************</span>
<a name="l05549"></a>05549 <span class="comment"> \note  createFakeTarget2nd</span>
<a name="l05550"></a>05550 <span class="comment"> \date  June 1999</span>
<a name="l05551"></a>05551 <span class="comment"> </span>
<a name="l05552"></a>05552 <span class="comment"> \remarks </span>
<a name="l05553"></a>05553 <span class="comment"> </span>
<a name="l05554"></a>05554 <span class="comment"> creates a fake target form an error based learning input for the second </span>
<a name="l05555"></a>05555 <span class="comment"> model</span>
<a name="l05556"></a>05556 <span class="comment"> </span>
<a name="l05557"></a>05557 <span class="comment"> *******************************************************************************</span>
<a name="l05558"></a>05558 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05559"></a>05559 <span class="comment"> </span>
<a name="l05560"></a>05560 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l05561"></a>05561 <span class="comment"> \param[in]     rfID   : the receptive field ID</span>
<a name="l05562"></a>05562 <span class="comment"> \param[in]     xmz    : mean zero input</span>
<a name="l05563"></a>05563 <span class="comment"> \param[in]     err    : error</span>
<a name="l05564"></a>05564 <span class="comment"> \param[in]     flag   : TRUE if this is an error</span>
<a name="l05565"></a>05565 <span class="comment"> \param[out]    yfake  : faked output</span>
<a name="l05566"></a>05566 <span class="comment"></span>
<a name="l05567"></a>05567 <span class="comment"> this function assumes that various quantities have been pre-computed</span>
<a name="l05568"></a>05568 <span class="comment"> </span>
<a name="l05569"></a>05569 <span class="comment"> ******************************************************************************/</span>
<a name="l05570"></a>05570 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05571"></a>05571 createFakeTarget2nd(<span class="keywordtype">int</span> ID,<span class="keywordtype">int</span> rfID, Vector xmz, Vector err,<span class="keywordtype">int</span> flag, 
<a name="l05572"></a>05572                     Vector yfake)
<a name="l05573"></a>05573      
<a name="l05574"></a>05574 {
<a name="l05575"></a>05575 
<a name="l05576"></a>05576   <span class="keywordtype">int</span>     j,k,n;
<a name="l05577"></a>05577   <span class="keywordtype">int</span>     n_in_reg_2nd;
<a name="l05578"></a>05578   <span class="keywordtype">int</span>     n_proj_2nd;
<a name="l05579"></a>05579   <span class="keywordtype">int</span>     n_out_2nd;
<a name="l05580"></a>05580   RF     *rfptr;
<a name="l05581"></a>05581   LWPR    *s;
<a name="l05582"></a>05582   <span class="keywordtype">double</span>  x_proj;
<a name="l05583"></a>05583   <span class="keywordtype">double</span>  w;
<a name="l05584"></a>05584 
<a name="l05585"></a>05585   s             = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l05586"></a>05586   n_in_reg_2nd  = s-&gt;n_in_reg_2nd;
<a name="l05587"></a>05587   n_out_2nd     = s-&gt;n_out_2nd;
<a name="l05588"></a>05588 
<a name="l05589"></a>05589   rfptr      = &amp;s-&gt;rfs[rfID];
<a name="l05590"></a>05590   n_proj_2nd = rfptr-&gt;n_proj_2nd;
<a name="l05591"></a>05591   
<a name="l05592"></a>05592   w = rfptr-&gt;w;
<a name="l05593"></a>05593 
<a name="l05594"></a>05594   <span class="comment">/* the constant part */</span>
<a name="l05595"></a>05595   <span class="keywordflow">if</span> (!flag) {
<a name="l05596"></a>05596     <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) 
<a name="l05597"></a>05597       yfake[j] = err[j];
<a name="l05598"></a>05598     <span class="keywordflow">return</span>;
<a name="l05599"></a>05599   }
<a name="l05600"></a>05600 
<a name="l05601"></a>05601   <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) 
<a name="l05602"></a>05602     yfake[j] = rfptr-&gt;mean_y_2nd[j]+err[j];
<a name="l05603"></a>05603   
<a name="l05604"></a>05604   for (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l05605"></a>05605 <span class="preprocessor">#if SPHERING</span>
<a name="l05606"></a>05606 <span class="preprocessor"></span>    s-&gt;x_temp_2nd[j] = xmz[j]/(sqrt(rfptr-&gt;var_x_reg_2nd[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l05607"></a>05607 <span class="preprocessor">#else</span>
<a name="l05608"></a>05608 <span class="preprocessor"></span>    s-&gt;x_temp_2nd[j] = xmz[j];
<a name="l05609"></a>05609 <span class="preprocessor">#endif</span>
<a name="l05610"></a>05610 <span class="preprocessor"></span>  }
<a name="l05611"></a>05611 
<a name="l05612"></a>05612   <span class="keywordflow">for</span> (k=1; k&lt;=n_proj_2nd; ++k) {
<a name="l05613"></a>05613     
<a name="l05614"></a>05614     <span class="comment">/* project the input onto the current projection */</span>
<a name="l05615"></a>05615     x_proj = vec_mult_inner_size(s-&gt;x_temp_2nd,rfptr-&gt;W_2nd[k],n_in_reg_2nd);
<a name="l05616"></a>05616     
<a name="l05617"></a>05617     <span class="comment">/* do single variate prediction */</span>
<a name="l05618"></a>05618     <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l05619"></a>05619       yfake[j] += x_proj * rfptr-&gt;B_2nd[k][j];
<a name="l05620"></a>05620     }
<a name="l05621"></a>05621     
<a name="l05622"></a>05622     <span class="comment">/* adjust the input data */</span>
<a name="l05623"></a>05623     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l05624"></a>05624       s-&gt;x_temp_2nd[j] -= x_proj * rfptr-&gt;U_2nd[k][j];
<a name="l05625"></a>05625     }
<a name="l05626"></a>05626     
<a name="l05627"></a>05627   }
<a name="l05628"></a>05628 
<a name="l05629"></a>05629   <span class="keywordflow">return</span>;
<a name="l05630"></a>05630 
<a name="l05631"></a>05631 }
<a name="l05632"></a>05632 
<a name="l05633"></a>05633 <span class="comment">/*!*****************************************************************************</span>
<a name="l05634"></a>05634 <span class="comment"> *******************************************************************************</span>
<a name="l05635"></a>05635 <span class="comment">\note  updateRegMeanVar2nd</span>
<a name="l05636"></a>05636 <span class="comment">\date  Sept, 1996</span>
<a name="l05637"></a>05637 <span class="comment"></span>
<a name="l05638"></a>05638 <span class="comment">\remarks </span>
<a name="l05639"></a>05639 <span class="comment"></span>
<a name="l05640"></a>05640 <span class="comment">       update the weighted mean and variance of a RF for the </span>
<a name="l05641"></a>05641 <span class="comment">       dependent variables for the 2nd model</span>
<a name="l05642"></a>05642 <span class="comment">        </span>
<a name="l05643"></a>05643 <span class="comment">       NOTE: the weight w must be assigned in the RF structure already</span>
<a name="l05644"></a>05644 <span class="comment"></span>
<a name="l05645"></a>05645 <span class="comment"> *******************************************************************************</span>
<a name="l05646"></a>05646 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05647"></a>05647 <span class="comment"></span>
<a name="l05648"></a>05648 <span class="comment"> \param[in]     ID    : lwpr ID</span>
<a name="l05649"></a>05649 <span class="comment"> \param[in]     rfID  : the rfID</span>
<a name="l05650"></a>05650 <span class="comment"> \param[in]     y     : the output vector</span>
<a name="l05651"></a>05651 <span class="comment"> \param[out]    ymz   : y-mean_y</span>
<a name="l05652"></a>05652 <span class="comment"></span>
<a name="l05653"></a>05653 <span class="comment"> ******************************************************************************/</span>
<a name="l05654"></a>05654 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05655"></a>05655 updateRegMeanVar2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector y, Vector ymz)
<a name="l05656"></a>05656 
<a name="l05657"></a>05657 {
<a name="l05658"></a>05658 
<a name="l05659"></a>05659   <span class="keywordtype">int</span>    i,j,k;
<a name="l05660"></a>05660   RF    *rfptr;
<a name="l05661"></a>05661   <span class="keywordtype">int</span>    n_out_2nd;
<a name="l05662"></a>05662   <span class="keywordtype">double</span> w;
<a name="l05663"></a>05663   <span class="keywordtype">double</span> lambda_2nd;
<a name="l05664"></a>05664 
<a name="l05665"></a>05665   <span class="comment">/* handy variables */</span>
<a name="l05666"></a>05666 
<a name="l05667"></a>05667   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l05668"></a>05668   n_out_2nd = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd;
<a name="l05669"></a>05669   w         = rfptr-&gt;w;
<a name="l05670"></a>05670   lambda_2nd= <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[1],w);
<a name="l05671"></a>05671   
<a name="l05672"></a>05672   <span class="keywordflow">for</span> (i=1; i&lt;=n_out_2nd; ++i) {
<a name="l05673"></a>05673 
<a name="l05674"></a>05674     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].use_offsets_2nd) {
<a name="l05675"></a>05675       rfptr-&gt;mean_y_2nd[i] = 
<a name="l05676"></a>05676         (rfptr-&gt;sum_weights_2nd[1] * rfptr-&gt;mean_y_2nd[i] * lambda_2nd + y[i]*w) /
<a name="l05677"></a>05677         (rfptr-&gt;sum_weights_2nd[1] * lambda_2nd + w);
<a name="l05678"></a>05678     }
<a name="l05679"></a>05679 
<a name="l05680"></a>05680     rfptr-&gt;var_y_2nd[i] = 
<a name="l05681"></a>05681       (rfptr-&gt;sum_weights_2nd[1] * rfptr-&gt;var_y_2nd[i] * lambda_2nd  + 
<a name="l05682"></a>05682                    sqr(y[i]-rfptr-&gt;mean_y_2nd[i])*w)/
<a name="l05683"></a>05683       (rfptr-&gt;sum_weights_2nd[1]  * lambda_2nd + w);
<a name="l05684"></a>05684 
<a name="l05685"></a>05685     ymz[i] = (y[i] - rfptr-&gt;mean_y_2nd[i]);
<a name="l05686"></a>05686 
<a name="l05687"></a>05687   }
<a name="l05688"></a>05688 
<a name="l05689"></a>05689 
<a name="l05690"></a>05690 }
<a name="l05691"></a>05691 
<a name="l05692"></a>05692 
<a name="l05693"></a>05693 <span class="comment">/*!*****************************************************************************</span>
<a name="l05694"></a>05694 <span class="comment"> *******************************************************************************</span>
<a name="l05695"></a>05695 <span class="comment"> \note  calculateRegression2nd</span>
<a name="l05696"></a>05696 <span class="comment"> \date  April 1999</span>
<a name="l05697"></a>05697 <span class="comment"> </span>
<a name="l05698"></a>05698 <span class="comment"> \remarks </span>
<a name="l05699"></a>05699 <span class="comment"> </span>
<a name="l05700"></a>05700 <span class="comment"> recursively calculates the regressions in all directions of the 2nd model</span>
<a name="l05701"></a>05701 <span class="comment"> </span>
<a name="l05702"></a>05702 <span class="comment"> *******************************************************************************</span>
<a name="l05703"></a>05703 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05704"></a>05704 <span class="comment"> </span>
<a name="l05705"></a>05705 <span class="comment"> \param[in]     ID       : the ID of the LWPR</span>
<a name="l05706"></a>05706 <span class="comment"> \param[in]     rfID     : the receptive field ID</span>
<a name="l05707"></a>05707 <span class="comment"> \param[in]     x_mz : the input vector (zero mean)</span>
<a name="l05708"></a>05708 <span class="comment"> \param[in]     y_mz     : the output vector (mean zero)</span>
<a name="l05709"></a>05709 <span class="comment"> </span>
<a name="l05710"></a>05710 <span class="comment"> ******************************************************************************/</span>
<a name="l05711"></a>05711 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05712"></a>05712 calculateRegression2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID, Vector x_mz, Vector y_mz)
<a name="l05713"></a>05713 
<a name="l05714"></a>05714 {
<a name="l05715"></a>05715   RF       *rfptr;
<a name="l05716"></a>05716   <span class="keywordtype">int</span>       n_in_reg_2nd, n_out_2nd;
<a name="l05717"></a>05717   <span class="keywordtype">int</span>       i, j, k;
<a name="l05718"></a>05718   <span class="keywordtype">int</span>       n_proj_2nd;
<a name="l05719"></a>05719   <span class="keywordtype">double</span>    aux;
<a name="l05720"></a>05720   <span class="keywordtype">double</span>    sum_val;
<a name="l05721"></a>05721   <span class="keywordtype">double</span>   *xres_2nd;
<a name="l05722"></a>05722   <span class="keywordtype">double</span>   *yres_2nd;
<a name="l05723"></a>05723   <span class="keywordtype">double</span>    s;
<a name="l05724"></a>05724   <span class="keywordtype">double</span>   *ypred_2nd;
<a name="l05725"></a>05725   <span class="keywordtype">double</span>    w;
<a name="l05726"></a>05726   <span class="keywordtype">double</span>    y_partial;
<a name="l05727"></a>05727   <span class="keywordtype">double</span>  **error_cv_2nd;
<a name="l05728"></a>05728   <span class="keywordtype">double</span>  **error_2nd;
<a name="l05729"></a>05729   <span class="keywordtype">double</span>   *xproj_2nd;
<a name="l05730"></a>05730   Vector    cr_2nd;
<a name="l05731"></a>05731 
<a name="l05732"></a>05732   rfptr        = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l05733"></a>05733   n_in_reg_2nd =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l05734"></a>05734   n_out_2nd    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd;
<a name="l05735"></a>05735   n_proj_2nd   =  rfptr-&gt;n_proj_2nd;
<a name="l05736"></a>05736   xres_2nd     =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].xres_2nd;
<a name="l05737"></a>05737   yres_2nd     =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].yres_2nd;
<a name="l05738"></a>05738   w            =  rfptr-&gt;w;
<a name="l05739"></a>05739   ypred_2nd    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].ypred_2nd;
<a name="l05740"></a>05740   error_cv_2nd =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_cv_2nd;
<a name="l05741"></a>05741   error_2nd    =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].error_2nd;
<a name="l05742"></a>05742   xproj_2nd    =  rfptr-&gt;s_2nd;
<a name="l05743"></a>05743   cr_2nd       =  <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].cr_2nd;
<a name="l05744"></a>05744 
<a name="l05745"></a>05745   <span class="comment">/* prepare residual variables */</span>
<a name="l05746"></a>05746 
<a name="l05747"></a>05747   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_reg_2nd; ++i)
<a name="l05748"></a>05748 #<span class="keywordflow">if</span> <a class="code" href="lwpr_8c.html#959b3abf0f46a44251fd75b173360097" title="sphering of local model distribution TRUE/FALSE">SPHERING</a>
<a name="l05749"></a>05749     xres_2nd[i] = x_mz[i]/(sqrt(rfptr-&gt;var_x_reg_2nd[i])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l05750"></a>05750 <span class="preprocessor">#else</span>
<a name="l05751"></a>05751 <span class="preprocessor"></span>    xres_2nd[i] = x_mz[i];
<a name="l05752"></a>05752 <span class="preprocessor">#endif</span>
<a name="l05753"></a>05753 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=1; i&lt;=n_out_2nd; ++i) {
<a name="l05754"></a>05754     yres_2nd[i]  = y_mz[i];
<a name="l05755"></a>05755     ypred_2nd[i] = rfptr-&gt;mean_y_2nd[i];
<a name="l05756"></a>05756   }
<a name="l05757"></a>05757 
<a name="l05758"></a>05758   <span class="comment">/* loop over all regression outputs, find the projections, and update</span>
<a name="l05759"></a>05759 <span class="comment">     the regression parameters */</span>
<a name="l05760"></a>05760   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj_2nd; ++i) {
<a name="l05761"></a>05761 
<a name="l05762"></a>05762     <span class="comment">/* project the input onto the projection vector *before* updating the</span>
<a name="l05763"></a>05763 <span class="comment">       projections: this is like "synchronous" update for PLS while </span>
<a name="l05764"></a>05764 <span class="comment">       classical PLS is asynchonous -- but synchronous updates keep</span>
<a name="l05765"></a>05765 <span class="comment">       cross validation for PLS cleaner */</span>
<a name="l05766"></a>05766     s=0.0;
<a name="l05767"></a>05767     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j)
<a name="l05768"></a>05768       s += rfptr-&gt;W_2nd[i][j]*xres_2nd[j];
<a name="l05769"></a>05769 
<a name="l05770"></a>05770     <span class="comment">/* update the projection direction; NOTE: this is not the proper</span>
<a name="l05771"></a>05771 <span class="comment">       version for multivariate outputs, but rather a quick and dirty</span>
<a name="l05772"></a>05772 <span class="comment">       version. Multivariate outputs are not recommended in any of the </span>
<a name="l05773"></a>05773 <span class="comment">       LWPR methods, and in particular not in PLS */</span>
<a name="l05774"></a>05774 
<a name="l05775"></a>05775     sum_val = 0.0;
<a name="l05776"></a>05776     for (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l05777"></a>05777       cr_2nd[j] = 0.0;
<a name="l05778"></a>05778       <span class="keywordflow">for</span> (k=1; k&lt;=n_out_2nd; ++k) {
<a name="l05779"></a>05779         cr_2nd[j] += xres_2nd[j]*yres_2nd[k];
<a name="l05780"></a>05780       }
<a name="l05781"></a>05781       <span class="comment">/* NOTE: for nonstationary learning problems, it turns out to be</span>
<a name="l05782"></a>05782 <span class="comment">         useful if the projections change a bit more slowly than the</span>
<a name="l05783"></a>05783 <span class="comment">         regression -- thus the weird formula below for lambda */</span>
<a name="l05784"></a>05784       rfptr-&gt;SXresYres_2nd[i][j] = 
<a name="l05785"></a>05785         <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>((1.-(1.-rfptr-&gt;lambda_2nd[i])/10.),w)*rfptr-&gt;SXresYres_2nd[i][j] + w*cr_2nd[j];
<a name="l05786"></a>05786       sum_val += sqr(rfptr-&gt;SXresYres_2nd[i][j]);
<a name="l05787"></a>05787     }
<a name="l05788"></a>05788     sum_val = sqrt(sum_val)+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l05789"></a>05789     rfptr-&gt;Wnorm_2nd[i] = sum_val;
<a name="l05790"></a>05790 
<a name="l05791"></a>05791     <span class="comment">/* normalize this direction */</span>
<a name="l05792"></a>05792     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j)
<a name="l05793"></a>05793       rfptr-&gt;W_2nd[i][j] = rfptr-&gt;SXresYres_2nd[i][j]/sum_val;
<a name="l05794"></a>05794 
<a name="l05795"></a>05795     <span class="comment">/* update sufficient statistics for regression based on this projection */</span>
<a name="l05796"></a>05796     rfptr-&gt;ss2_2nd[i] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],w) * rfptr-&gt;ss2_2nd[i] + sqr(s) * w;
<a name="l05797"></a>05797     <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l05798"></a>05798       rfptr-&gt;SSYres_2nd[i][j] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],w) * rfptr-&gt;SSYres_2nd[i][j] +  
<a name="l05799"></a>05799         w * yres_2nd[j] * s;
<a name="l05800"></a>05800     }
<a name="l05801"></a>05801 
<a name="l05802"></a>05802     <span class="comment">/* update the regression parameters for this dimension and predict</span>
<a name="l05803"></a>05803 <span class="comment">       the outputs */</span>
<a name="l05804"></a>05804     aux = 0;
<a name="l05805"></a>05805     <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l05806"></a>05806 
<a name="l05807"></a>05807       <span class="comment">/* the cross validation error at this regression stage */</span>
<a name="l05808"></a>05808       y_partial          = rfptr-&gt;B_2nd[i][j]*s;
<a name="l05809"></a>05809       error_cv_2nd[i][j] = yres_2nd[j] - y_partial;
<a name="l05810"></a>05810       ypred_2nd[j]      += y_partial;
<a name="l05811"></a>05811       yres_2nd[j]       -= y_partial;
<a name="l05812"></a>05812       aux               += sqr(error_cv_2nd[i][j]);
<a name="l05813"></a>05813 
<a name="l05814"></a>05814       <span class="comment">/* update the local model */</span>
<a name="l05815"></a>05815       rfptr-&gt;B_2nd[i][j] = rfptr-&gt;SSYres_2nd[i][j]/rfptr-&gt;ss2_2nd[i];
<a name="l05816"></a>05816 
<a name="l05817"></a>05817 
<a name="l05818"></a>05818     }
<a name="l05819"></a>05819     aux /= (double)n_out_2nd;  <span class="comment">/* the mean squared cv error accross all outputs */</span>
<a name="l05820"></a>05820 
<a name="l05821"></a>05821     <span class="comment">/* update the sum_error term: this is a sum of CV terms */</span>
<a name="l05822"></a>05822     rfptr-&gt;sum_error_cvi_2nd[i]   = rfptr-&gt;sum_error_cvi_2nd[i] * 
<a name="l05823"></a>05823       <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],w) + w * aux;
<a name="l05824"></a>05824 
<a name="l05825"></a>05825     <span class="comment">/* the total CV error of the RF needs to be accumulated separately as</span>
<a name="l05826"></a>05826 <span class="comment">       individual projections have different life times */</span>
<a name="l05827"></a>05827     <span class="keywordflow">if</span> (i==n_proj_2nd)
<a name="l05828"></a>05828       rfptr-&gt;sum_error_cv_2nd   = rfptr-&gt;sum_error_cv_2nd * <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[1],w) 
<a name="l05829"></a>05829         + w * aux;
<a name="l05830"></a>05830 
<a name="l05831"></a>05831     <span class="comment">/* the regression parameters on the inputs variables and</span>
<a name="l05832"></a>05832 <span class="comment">       prepare the variables for the next iteration */</span>
<a name="l05833"></a>05833     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l05834"></a>05834       rfptr-&gt;SSXres_2nd[i][j] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],w) * rfptr-&gt;SSXres_2nd[i][j] +  
<a name="l05835"></a>05835         w * xres_2nd[j] * s;
<a name="l05836"></a>05836       xres_2nd[j] -= rfptr-&gt;U_2nd[i][j]*s;
<a name="l05837"></a>05837       rfptr-&gt;U_2nd[i][j] = rfptr-&gt;SSXres_2nd[i][j]/rfptr-&gt;ss2_2nd[i];
<a name="l05838"></a>05838     }
<a name="l05839"></a>05839     
<a name="l05840"></a>05840   }
<a name="l05841"></a>05841 
<a name="l05842"></a>05842   <span class="comment">/* finally calulate the predicted regression output *after* updating */</span>
<a name="l05843"></a>05843   <span class="keywordflow">for</span> (i=1; i&lt;=n_out_2nd; ++i) {
<a name="l05844"></a>05844     yres_2nd[i]  = y_mz[i];
<a name="l05845"></a>05845     ypred_2nd[i] = rfptr-&gt;mean_y_2nd[i];
<a name="l05846"></a>05846   }
<a name="l05847"></a>05847   <span class="keywordflow">for</span> (i=1; i&lt;=n_in_reg_2nd; ++i)
<a name="l05848"></a>05848 #<span class="keywordflow">if</span> <a class="code" href="lwpr_8c.html#959b3abf0f46a44251fd75b173360097" title="sphering of local model distribution TRUE/FALSE">SPHERING</a>
<a name="l05849"></a>05849     xres_2nd[i] = x_mz[i]/(sqrt(rfptr-&gt;var_x_reg_2nd[i])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l05850"></a>05850 <span class="preprocessor">#else</span>
<a name="l05851"></a>05851 <span class="preprocessor"></span>    xres_2nd[i] = x_mz[i];
<a name="l05852"></a>05852 <span class="preprocessor">#endif</span>
<a name="l05853"></a>05853 <span class="preprocessor"></span>
<a name="l05854"></a>05854   <span class="keywordflow">for</span> (i=1; i&lt;=n_proj_2nd; ++i) {
<a name="l05855"></a>05855 
<a name="l05856"></a>05856     s=0.0;
<a name="l05857"></a>05857     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j)
<a name="l05858"></a>05858       s += rfptr-&gt;W_2nd[i][j]*xres_2nd[j];
<a name="l05859"></a>05859 
<a name="l05860"></a>05860     xproj_2nd[i] = s;
<a name="l05861"></a>05861 
<a name="l05862"></a>05862     <span class="comment">/* update the local degree of freedoms */</span>
<a name="l05863"></a>05863     rfptr-&gt;dof_2nd[i] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],w) * rfptr-&gt;dof_2nd[i] + 
<a name="l05864"></a>05864       sqr(w)*sqr(s)/rfptr-&gt;ss2_2nd[i];
<a name="l05865"></a>05865 
<a name="l05866"></a>05866     <span class="comment">/* compute the predicted output */</span>
<a name="l05867"></a>05867     aux = 0;
<a name="l05868"></a>05868     <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l05869"></a>05869       <span class="comment">/* the non-CV error at this regression stage */</span>
<a name="l05870"></a>05870       y_partial   = rfptr-&gt;B_2nd[i][j]*s;
<a name="l05871"></a>05871       error_2nd[i][j] = yres_2nd[j] - y_partial;
<a name="l05872"></a>05872       ypred_2nd[j]   += y_partial;
<a name="l05873"></a>05873       yres_2nd[j]    -= y_partial;
<a name="l05874"></a>05874       aux        += sqr(error_2nd[i][j]);
<a name="l05875"></a>05875     }
<a name="l05876"></a>05876     aux /= (double)n_out_2nd;  <span class="comment">/* the mean squared error accross all outputs */</span>
<a name="l05877"></a>05877 
<a name="l05878"></a>05878     <span class="comment">/* update the sum_error term: this is a sum of NON-CV terms */</span>
<a name="l05879"></a>05879     rfptr-&gt;sum_error_2nd[i]   = rfptr-&gt;sum_error_2nd[i] * <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],w) 
<a name="l05880"></a>05880       + w * aux;
<a name="l05881"></a>05881 
<a name="l05882"></a>05882     <span class="comment">/* update the residual input for the next iteration */</span>
<a name="l05883"></a>05883     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l05884"></a>05884       xres_2nd[j] -= rfptr-&gt;U_2nd[i][j]*s;
<a name="l05885"></a>05885     }
<a name="l05886"></a>05886 
<a name="l05887"></a>05887   }
<a name="l05888"></a>05888 
<a name="l05889"></a>05889   <span class="keywordflow">if</span> (rfptr-&gt;n_data_2nd[1] &gt; 2*n_in_reg_2nd)
<a name="l05890"></a>05890     rfptr-&gt;trustworthy_2nd = TRUE; 
<a name="l05891"></a>05891 
<a name="l05892"></a>05892 
<a name="l05893"></a>05893 }
<a name="l05894"></a>05894 
<a name="l05895"></a>05895 <span class="comment">/*!*****************************************************************************</span>
<a name="l05896"></a>05896 <span class="comment"> *******************************************************************************</span>
<a name="l05897"></a>05897 <span class="comment"> \note  predictLWPROutput2nd</span>
<a name="l05898"></a>05898 <span class="comment"> \date  January, 2006</span>
<a name="l05899"></a>05899 <span class="comment"> </span>
<a name="l05900"></a>05900 <span class="comment"> \remarks </span>
<a name="l05901"></a>05901 <span class="comment"> </span>
<a name="l05902"></a>05902 <span class="comment"> generates a prediction from a given input for the 2nd regression model</span>
<a name="l05903"></a>05903 <span class="comment"> </span>
<a name="l05904"></a>05904 <span class="comment"> *******************************************************************************</span>
<a name="l05905"></a>05905 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l05906"></a>05906 <span class="comment"> </span>
<a name="l05907"></a>05907 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l05908"></a>05908 <span class="comment"> \param[in]     x_w    : the input vector for weights</span>
<a name="l05909"></a>05909 <span class="comment"> \param[in]     x      : the input vector for regression</span>
<a name="l05910"></a>05910 <span class="comment"> \param[in]     cutoff : a number between [0,1] which indicates at which threshold</span>
<a name="l05911"></a>05911 <span class="comment">             a receptive field is not used for averaging anymore</span>
<a name="l05912"></a>05912 <span class="comment"> \param[in]     blend  : blend predictions or use max only </span>
<a name="l05913"></a>05913 <span class="comment"> \param[out]    y      : the output vector</span>
<a name="l05914"></a>05914 <span class="comment"> \param[in,out] rfID   : the rf for the neighborhood for input, returns the max activated rf </span>
<a name="l05915"></a>05915 <span class="comment"></span>
<a name="l05916"></a>05916 <span class="comment"> returns the max activation contributing to this output</span>
<a name="l05917"></a>05917 <span class="comment"> </span>
<a name="l05918"></a>05918 <span class="comment"> ******************************************************************************/</span>
<a name="l05919"></a>05919 <span class="keywordtype">double</span>
<a name="l05920"></a><a class="code" href="lwpr_8h.html#712b6491f2e59d0f480c44abd4499eae">05920</a> <a class="code" href="lwpr_8c.html#712b6491f2e59d0f480c44abd4499eae">predictLWPROutputConf2nd</a>(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x_w, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> cutoff, 
<a name="l05921"></a>05921                          <span class="keywordtype">int</span> blend, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> *rfID, <span class="keywordtype">double</span> *conf)
<a name="l05922"></a>05922 {
<a name="l05923"></a>05923   <span class="keywordtype">int</span> i;
<a name="l05924"></a>05924   <span class="keywordtype">double</span> rc;
<a name="l05925"></a>05925 
<a name="l05926"></a>05926   rc = predictLWPROutput2nd(ID, x_w, x, cutoff, blend, y, rfID);
<a name="l05927"></a>05927   <span class="keywordflow">for</span> (i=1; i&lt;=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd; ++i)
<a name="l05928"></a>05928     conf[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].y_conf_2nd[i];
<a name="l05929"></a>05929   
<a name="l05930"></a>05930   <span class="keywordflow">return</span> rc;
<a name="l05931"></a>05931 
<a name="l05932"></a>05932 }
<a name="l05933"></a>05933 
<a name="l05934"></a>05934 <span class="keywordtype">double</span>
<a name="l05935"></a>05935 predictLWPROutput2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">double</span> *x_w, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> cutoff, 
<a name="l05936"></a>05936                      <span class="keywordtype">int</span> blend, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> *rfID)
<a name="l05937"></a>05937      
<a name="l05938"></a>05938 {
<a name="l05939"></a>05939   
<a name="l05940"></a>05940   <span class="keywordtype">int</span>     i,j,k,n,r;
<a name="l05941"></a>05941   <span class="keywordtype">double</span>  max_activation = 0;
<a name="l05942"></a>05942   <span class="keywordtype">double</span>  sum_w = 0;
<a name="l05943"></a>05943   <span class="keywordtype">double</span>  w=0.;
<a name="l05944"></a>05944   <span class="keywordtype">int</span>     n_in_w;
<a name="l05945"></a>05945   <span class="keywordtype">int</span>     n_in_reg_2nd;
<a name="l05946"></a>05946   <span class="keywordtype">int</span>     n_proj_2nd;
<a name="l05947"></a>05947   <span class="keywordtype">int</span>     n_rf;
<a name="l05948"></a>05948   <span class="keywordtype">int</span>     n_out_2nd;
<a name="l05949"></a>05949   <span class="keywordtype">int</span>     index_max= -999;
<a name="l05950"></a>05950   RF     *rfptr;
<a name="l05951"></a>05951   <span class="keywordtype">int</span>     count_rf=0;
<a name="l05952"></a>05952   LWPR    *s;
<a name="l05953"></a>05953   <span class="keywordtype">double</span>  x_proj;
<a name="l05954"></a>05954   Vector  xres_2nd;
<a name="l05955"></a>05955   <span class="keywordtype">double</span>  aux;
<a name="l05956"></a>05956   <span class="keywordtype">double</span>  dofs_2nd;
<a name="l05957"></a>05957 
<a name="l05958"></a>05958   <span class="keywordflow">if</span> (!checkLWPRExists(ID)) 
<a name="l05959"></a>05959     <span class="keywordflow">return</span> FALSE;
<a name="l05960"></a>05960 
<a name="l05961"></a>05961   s             = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID];
<a name="l05962"></a>05962   n_in_w        = s-&gt;n_in_w;
<a name="l05963"></a>05963   n_in_reg_2nd  = s-&gt;n_in_reg_2nd;
<a name="l05964"></a>05964   n_out_2nd     = s-&gt;n_out_2nd;
<a name="l05965"></a>05965   n_rf          = s-&gt;n_rf;
<a name="l05966"></a>05966   xres_2nd      = s-&gt;x_tempp_2nd;
<a name="l05967"></a>05967 
<a name="l05968"></a>05968   <span class="comment">/* normalize the query point */</span>
<a name="l05969"></a>05969   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l05970"></a>05970     s-&gt;xp_2nd[j] = x[j]/s-&gt;norm_in_reg_2nd[j];
<a name="l05971"></a>05971   }
<a name="l05972"></a>05972 
<a name="l05973"></a>05973   <span class="keywordflow">for</span> (j=1; j&lt;=n_in_w; ++j) {
<a name="l05974"></a>05974     s-&gt;xp_w[j] = x_w[j]/s-&gt;norm_in_w[j];
<a name="l05975"></a>05975   }
<a name="l05976"></a>05976 
<a name="l05977"></a>05977   <span class="comment">/* reset the y[j] here since we sum over them */</span>
<a name="l05978"></a>05978   <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l05979"></a>05979     y[j] = 0.0;
<a name="l05980"></a>05980     s-&gt;y_predicted_2nd[j]  = 0.0;
<a name="l05981"></a>05981     s-&gt;y_predicted2_2nd[j] = 0.0;
<a name="l05982"></a>05982     s-&gt;y_conf_2nd[j] = 0.0;
<a name="l05983"></a>05983   }
<a name="l05984"></a>05984 
<a name="l05985"></a>05985   <span class="comment">/* if there are no receptive fields */</span>
<a name="l05986"></a>05986   <span class="keywordflow">if</span> (n_rf == 0)
<a name="l05987"></a>05987     <span class="keywordflow">return</span> max_activation;
<a name="l05988"></a>05988   
<a name="l05989"></a>05989   <span class="comment">/* scan the receptive fields */</span>
<a name="l05990"></a>05990 
<a name="l05991"></a>05991   <span class="keywordflow">for</span> (r=1; r&lt;=n_rf; ++r) {
<a name="l05992"></a>05992 
<a name="l05993"></a>05993     <span class="comment">/* fudge in the nearest neighbor lookup */</span>
<a name="l05994"></a>05994     <span class="keywordflow">if</span> (s-&gt;use_nn &amp;&amp; *rfID &gt; 0 &amp;&amp; *rfID &lt;= n_rf) {
<a name="l05995"></a>05995       <span class="keywordflow">if</span> ( (r &gt; s-&gt;max_nn_comp &amp;&amp; max_activation &gt; cutoff) || 
<a name="l05996"></a>05996            r &gt; s-&gt;rfs[*rfID].n_nn)
<a name="l05997"></a>05997         <span class="keywordflow">break</span>;
<a name="l05998"></a>05998       i = s-&gt;rfs[*rfID].nn[r];
<a name="l05999"></a>05999     } <span class="keywordflow">else</span> {
<a name="l06000"></a>06000       i = r;
<a name="l06001"></a>06001     }
<a name="l06002"></a>06002   
<a name="l06003"></a>06003     rfptr      = &amp;s-&gt;rfs[i];
<a name="l06004"></a>06004     n_proj_2nd = rfptr-&gt;n_proj_2nd;
<a name="l06005"></a>06005 
<a name="l06006"></a>06006     <span class="keywordflow">if</span> (!rfptr-&gt;trustworthy) <span class="keywordflow">continue</span>;
<a name="l06007"></a>06007     
<a name="l06008"></a>06008     <span class="comment">/* the mean subtracted input  */</span>
<a name="l06009"></a>06009     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l06010"></a>06010       s-&gt;x_mzp_2nd[j] = s-&gt;xp_2nd[j] - rfptr-&gt;mean_x_reg_2nd[j];
<a name="l06011"></a>06011     }
<a name="l06012"></a>06012     
<a name="l06013"></a>06013     <span class="comment">/* generate the weight for this RF */</span>
<a name="l06014"></a>06014     rfptr-&gt;ww = w = calculateWeightp(ID,i,s-&gt;xp_w);
<a name="l06015"></a>06015 
<a name="l06016"></a>06016     <span class="keywordflow">if</span> (w &gt; max_activation) {
<a name="l06017"></a>06017       max_activation = w;
<a name="l06018"></a>06018       index_max = i;
<a name="l06019"></a>06019     }
<a name="l06020"></a>06020 
<a name="l06021"></a>06021     <span class="keywordflow">if</span> (w &gt; cutoff &amp;&amp; blend) {
<a name="l06022"></a>06022 
<a name="l06023"></a>06023       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l06024"></a>06024 <span class="preprocessor">#if SPHERING</span>
<a name="l06025"></a>06025 <span class="preprocessor"></span>        xres_2nd[j] = s-&gt;x_mzp_2nd[j]/(sqrt(rfptr-&gt;var_x_reg_2nd[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l06026"></a>06026 <span class="preprocessor">#else</span>
<a name="l06027"></a>06027 <span class="preprocessor"></span>        xres_2nd[j] = s-&gt;x_mzp_2nd[j];
<a name="l06028"></a>06028 <span class="preprocessor">#endif</span>
<a name="l06029"></a>06029 <span class="preprocessor"></span>      }
<a name="l06030"></a>06030 
<a name="l06031"></a>06031       <span class="comment">/* add the constant part */</span>
<a name="l06032"></a>06032       <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l06033"></a>06033         aux = rfptr-&gt;mean_y_2nd[j];
<a name="l06034"></a>06034         s-&gt;y_predicted_2nd[j] = aux; 
<a name="l06035"></a>06035         y[j] += aux * w;
<a name="l06036"></a>06036       }
<a name="l06037"></a>06037 
<a name="l06038"></a>06038 
<a name="l06039"></a>06039       <span class="keywordflow">for</span> (k=1; k&lt;=n_proj_2nd; ++k) {
<a name="l06040"></a>06040 
<a name="l06041"></a>06041         <span class="comment">/* project the input onto the current projection */</span>
<a name="l06042"></a>06042         x_proj = vec_mult_inner_size(xres_2nd,rfptr-&gt;W_2nd[k],n_in_reg_2nd);
<a name="l06043"></a>06043         
<a name="l06044"></a>06044         <span class="comment">/* do single variate prediction */</span>
<a name="l06045"></a>06045         <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l06046"></a>06046           aux   = x_proj * rfptr-&gt;B_2nd[k][j];
<a name="l06047"></a>06047           y[j] += aux * w;
<a name="l06048"></a>06048           s-&gt;y_predicted_2nd[j] += aux;
<a name="l06049"></a>06049         }
<a name="l06050"></a>06050         
<a name="l06051"></a>06051         <span class="comment">/* adjust the input data */</span>
<a name="l06052"></a>06052         <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l06053"></a>06053           xres_2nd[j] -= x_proj * rfptr-&gt;U_2nd[k][j];
<a name="l06054"></a>06054         }
<a name="l06055"></a>06055 
<a name="l06056"></a>06056       }
<a name="l06057"></a>06057       
<a name="l06058"></a>06058       <span class="comment">/* prepare summary statistics and confidence intervals */</span>
<a name="l06059"></a>06059       sum_w += w;
<a name="l06060"></a>06060       <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l06061"></a>06061         s-&gt;y_predicted2_2nd[j] += sqr(s-&gt;y_predicted_2nd[j]) * w;
<a name="l06062"></a>06062         dofs_2nd = rfptr-&gt;sum_weights_2nd[1];
<a name="l06063"></a>06063         aux  = 1;
<a name="l06064"></a>06064         <span class="keywordflow">for</span> (k=1; k&lt;=n_proj_2nd; ++k) {
<a name="l06065"></a>06065           dofs_2nd -= rfptr-&gt;dof_2nd[k];
<a name="l06066"></a>06066           aux  += sqr(rfptr-&gt;s_2nd[k])/rfptr-&gt;ss2_2nd[k] * w;
<a name="l06067"></a>06067         }
<a name="l06068"></a>06068         <span class="keywordflow">if</span> (dofs_2nd &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>)
<a name="l06069"></a>06069           dofs_2nd = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l06070"></a>06070         s-&gt;y_conf_2nd[j] += w * rfptr-&gt;sum_error_2nd[n_proj_2nd]/dofs_2nd*aux;
<a name="l06071"></a>06071       }
<a name="l06072"></a>06072       ++count_rf;
<a name="l06073"></a>06073 
<a name="l06074"></a>06074     }
<a name="l06075"></a>06075 
<a name="l06076"></a>06076   }
<a name="l06077"></a>06077 
<a name="l06078"></a>06078 
<a name="l06079"></a>06079   <span class="comment">/* finish up */</span>
<a name="l06080"></a>06080 
<a name="l06081"></a>06081   <span class="keywordflow">if</span> (blend) {
<a name="l06082"></a>06082 
<a name="l06083"></a>06083     <span class="keywordflow">if</span> (sum_w &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) 
<a name="l06084"></a>06084       sum_w = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l06085"></a>06085 
<a name="l06086"></a>06086     <span class="keywordflow">for</span> (i=1; i&lt;=n_out_2nd; ++i) {
<a name="l06087"></a>06087       y[i] = y[i]/sum_w;
<a name="l06088"></a>06088       aux = fabs(s-&gt;y_predicted2_2nd[i]/sum_w - sqr(y[i]))/sum_w;
<a name="l06089"></a>06089       s-&gt;y_conf_2nd[i] = sqrt(s-&gt;y_conf_2nd[i]/sqr(sum_w)+aux);
<a name="l06090"></a>06090 
<a name="l06091"></a>06091       <span class="comment">/* add output normalization */</span>
<a name="l06092"></a>06092       y[i] *= s-&gt;norm_out_2nd[i];
<a name="l06093"></a>06093       s-&gt;y_conf_2nd[i] *= s-&gt;norm_out_2nd[i];
<a name="l06094"></a>06094     }
<a name="l06095"></a>06095     
<a name="l06096"></a>06096   } <span class="keywordflow">else</span> {
<a name="l06097"></a>06097     
<a name="l06098"></a>06098     <span class="comment">/* predict y from the max activated rf */</span>
<a name="l06099"></a>06099     rfptr = &amp;s-&gt;rfs[index_max];
<a name="l06100"></a>06100     n_proj_2nd = rfptr-&gt;n_proj_2nd;
<a name="l06101"></a>06101 
<a name="l06102"></a>06102     <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l06103"></a>06103       s-&gt;x_mzp_2nd[j] = s-&gt;xp_2nd[j] - rfptr-&gt;mean_x_reg_2nd[j];
<a name="l06104"></a>06104 <span class="preprocessor">#if SPHERING</span>
<a name="l06105"></a>06105 <span class="preprocessor"></span>      xres_2nd[j] = s-&gt;x_mzp_2nd[j]/(sqrt(rfptr-&gt;var_x_reg_2nd[j])+<a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>);
<a name="l06106"></a>06106 <span class="preprocessor">#else</span>
<a name="l06107"></a>06107 <span class="preprocessor"></span>      xres_2nd[j] = s-&gt;x_mzp_2nd[j];
<a name="l06108"></a>06108 <span class="preprocessor">#endif</span>
<a name="l06109"></a>06109 <span class="preprocessor"></span>    }
<a name="l06110"></a>06110 
<a name="l06111"></a>06111     <span class="keywordflow">for</span> (k=1; k&lt;=n_proj_2nd; ++k) {
<a name="l06112"></a>06112       
<a name="l06113"></a>06113       <span class="comment">/* project the input onto the current projection */</span>
<a name="l06114"></a>06114       x_proj = vec_mult_inner_size(xres_2nd,rfptr-&gt;W_2nd[k],n_in_reg_2nd);
<a name="l06115"></a>06115       
<a name="l06116"></a>06116       <span class="comment">/* do single variate prediction */</span>
<a name="l06117"></a>06117       <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l06118"></a>06118         y[j] += x_proj * rfptr-&gt;B_2nd[k][j];
<a name="l06119"></a>06119       }
<a name="l06120"></a>06120       
<a name="l06121"></a>06121       <span class="comment">/* adjust the input data */</span>
<a name="l06122"></a>06122       <span class="keywordflow">for</span> (j=1; j&lt;=n_in_reg_2nd; ++j) {
<a name="l06123"></a>06123         xres_2nd[j] -= x_proj * rfptr-&gt;U_2nd[k][j];
<a name="l06124"></a>06124       }
<a name="l06125"></a>06125     
<a name="l06126"></a>06126     }
<a name="l06127"></a>06127     
<a name="l06128"></a>06128     <span class="comment">/* add the constant part and compute confidence interval */</span>
<a name="l06129"></a>06129     <span class="keywordflow">for</span> (j=1; j&lt;=n_out_2nd; ++j) {
<a name="l06130"></a>06130       y[j] = (y[j] + rfptr-&gt;mean_y_2nd[j])*s-&gt;norm_out_2nd[j]; 
<a name="l06131"></a>06131 
<a name="l06132"></a>06132       dofs_2nd = rfptr-&gt;sum_weights_2nd[1];
<a name="l06133"></a>06133       aux  = 1;
<a name="l06134"></a>06134       for (k=1; k&lt;=n_proj_2nd; ++k) {
<a name="l06135"></a>06135         dofs_2nd -= rfptr-&gt;dof_2nd[k];
<a name="l06136"></a>06136         aux  += sqr(rfptr-&gt;s_2nd[k])/rfptr-&gt;ss2_2nd[k] * w;
<a name="l06137"></a>06137       }
<a name="l06138"></a>06138       <span class="keywordflow">if</span> (dofs_2nd &lt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) 
<a name="l06139"></a>06139         dofs_2nd = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l06140"></a>06140       s-&gt;y_conf_2nd[j] = rfptr-&gt;sum_error_2nd[n_proj_2nd]/dofs_2nd*aux/w;
<a name="l06141"></a>06141     }
<a name="l06142"></a>06142 
<a name="l06143"></a>06143     <span class="keywordflow">if</span> (!s-&gt;rfs[index_max].trustworthy_2nd) max_activation = 0;
<a name="l06144"></a>06144     
<a name="l06145"></a>06145   }
<a name="l06146"></a>06146 
<a name="l06147"></a>06147   *rfID = index_max;
<a name="l06148"></a>06148 
<a name="l06149"></a>06149   <span class="keywordflow">return</span> max_activation;
<a name="l06150"></a>06150 
<a name="l06151"></a>06151 }
<a name="l06152"></a>06152 
<a name="l06153"></a>06153 <span class="comment">/*!*****************************************************************************</span>
<a name="l06154"></a>06154 <span class="comment"> *******************************************************************************</span>
<a name="l06155"></a>06155 <span class="comment">\note  updateAdmVars2nd</span>
<a name="l06156"></a>06156 <span class="comment">\date  April 1999</span>
<a name="l06157"></a>06157 <span class="comment"></span>
<a name="l06158"></a>06158 <span class="comment">\remarks </span>
<a name="l06159"></a>06159 <span class="comment"></span>
<a name="l06160"></a>06160 <span class="comment">       updates several adminstrative variables for a receptive field for</span>
<a name="l06161"></a>06161 <span class="comment">       the 2nd model.</span>
<a name="l06162"></a>06162 <span class="comment">       This function should be called last since various other update</span>
<a name="l06163"></a>06163 <span class="comment">       function require the non-updated adminstrative variables.</span>
<a name="l06164"></a>06164 <span class="comment"></span>
<a name="l06165"></a>06165 <span class="comment"> *******************************************************************************</span>
<a name="l06166"></a>06166 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l06167"></a>06167 <span class="comment"></span>
<a name="l06168"></a>06168 <span class="comment"> \param[in]     ID        : lwpr ID</span>
<a name="l06169"></a>06169 <span class="comment"> \param[in]     rfID      : the rfID</span>
<a name="l06170"></a>06170 <span class="comment"></span>
<a name="l06171"></a>06171 <span class="comment"> ******************************************************************************/</span>
<a name="l06172"></a>06172 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06173"></a>06173 updateAdmVars2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l06174"></a>06174 
<a name="l06175"></a>06175 {
<a name="l06176"></a>06176 
<a name="l06177"></a>06177   <span class="keywordtype">int</span>    i;
<a name="l06178"></a>06178   RF    *rfptr;
<a name="l06179"></a>06179 
<a name="l06180"></a>06180   <span class="comment">/* handy variables */</span>
<a name="l06181"></a>06181   rfptr     = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l06182"></a>06182 
<a name="l06183"></a>06183   <span class="comment">/* several trace values */</span>
<a name="l06184"></a>06184   <span class="keywordflow">for</span> (i=1; i&lt;=rfptr-&gt;n_proj_2nd; ++i) {
<a name="l06185"></a>06185 
<a name="l06186"></a>06186     rfptr-&gt;sum_weights_2nd[i] = <a class="code" href="lwpr_8c.html#e5c15e0f3eb0de33ead07f5c8ae8009f" title="a macro for changing the forgetting factor as function of the weight">LAMBDA</a>(rfptr-&gt;lambda_2nd[i],rfptr-&gt;w)*
<a name="l06187"></a>06187       rfptr-&gt;sum_weights_2nd[i] + rfptr-&gt;w;
<a name="l06188"></a>06188     rfptr-&gt;n_data_2nd[i]      = rfptr-&gt;lambda_2nd[i] * rfptr-&gt;n_data_2nd[i] + 1;
<a name="l06189"></a>06189 
<a name="l06190"></a>06190     <span class="comment">/* and finally update the forgetting factor lambda itself */</span>
<a name="l06191"></a>06191     <span class="keywordflow">if</span> (<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].final_lambda - rfptr-&gt;lambda_2nd[i] &gt; <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>) {
<a name="l06192"></a>06192       rfptr-&gt;lambda_2nd[i] = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].tau_lambda * rfptr-&gt;lambda_2nd[i] + 
<a name="l06193"></a>06193         <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].final_lambda*(1.-<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].tau_lambda);
<a name="l06194"></a>06194       
<a name="l06195"></a>06195     }
<a name="l06196"></a>06196   }
<a name="l06197"></a>06197 
<a name="l06198"></a>06198 
<a name="l06199"></a>06199 }
<a name="l06200"></a>06200 
<a name="l06201"></a>06201 <span class="comment">/*!*****************************************************************************</span>
<a name="l06202"></a>06202 <span class="comment"> *******************************************************************************</span>
<a name="l06203"></a>06203 <span class="comment"> \note  checkAddDim2nd</span>
<a name="l06204"></a>06204 <span class="comment"> \date  May 1999</span>
<a name="l06205"></a>06205 <span class="comment"> </span>
<a name="l06206"></a>06206 <span class="comment"> \remarks </span>
<a name="l06207"></a>06207 <span class="comment"> </span>
<a name="l06208"></a>06208 <span class="comment"> checks whether to add dimensions to the regression of 2nd model</span>
<a name="l06209"></a>06209 <span class="comment"> </span>
<a name="l06210"></a>06210 <span class="comment"> *******************************************************************************</span>
<a name="l06211"></a>06211 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l06212"></a>06212 <span class="comment"> </span>
<a name="l06213"></a>06213 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l06214"></a>06214 <span class="comment"> \param[in]     rfID   : the ID of the receptive field</span>
<a name="l06215"></a>06215 <span class="comment"></span>
<a name="l06216"></a>06216 <span class="comment"> returns TRUE if dimension should be increased else returns FALSE</span>
<a name="l06217"></a>06217 <span class="comment"> </span>
<a name="l06218"></a>06218 <span class="comment"> ******************************************************************************/</span>
<a name="l06219"></a>06219 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06220"></a>06220 checkAddDim2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l06221"></a>06221 
<a name="l06222"></a>06222 {
<a name="l06223"></a>06223 
<a name="l06224"></a>06224   <span class="keywordtype">int</span>    i,j,m;
<a name="l06225"></a>06225   RF    *rfptr;
<a name="l06226"></a>06226   <span class="keywordtype">int</span>    n_in_w;
<a name="l06227"></a>06227   <span class="keywordtype">int</span>    n_in_reg_2nd;
<a name="l06228"></a>06228   <span class="keywordtype">int</span>    n_out_2nd;
<a name="l06229"></a>06229   <span class="keywordtype">int</span>    n_proj_2nd;
<a name="l06230"></a>06230   <span class="keywordtype">double</span> mse_n_proj;
<a name="l06231"></a>06231   <span class="keywordtype">double</span> mse_n_proj_1;
<a name="l06232"></a>06232 
<a name="l06233"></a>06233   n_in_w        = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l06234"></a>06234   n_in_reg_2nd  = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l06235"></a>06235   rfptr         = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l06236"></a>06236   n_proj_2nd    = rfptr-&gt;n_proj_2nd;
<a name="l06237"></a>06237 
<a name="l06238"></a>06238   <span class="keywordflow">if</span> (n_proj_2nd &gt;= n_in_reg_2nd)
<a name="l06239"></a>06239     <span class="keywordflow">return</span> FALSE;
<a name="l06240"></a>06240 
<a name="l06241"></a>06241   mse_n_proj   = rfptr-&gt;sum_error_cvi_2nd[n_proj_2nd]  /rfptr-&gt;sum_weights_2nd[n_proj_2nd];
<a name="l06242"></a>06242   mse_n_proj_1 = rfptr-&gt;sum_error_cvi_2nd[n_proj_2nd-1]/rfptr-&gt;sum_weights_2nd[n_proj_2nd-1];
<a name="l06243"></a>06243  
<a name="l06244"></a>06244   <span class="keywordflow">if</span> (mse_n_proj/mse_n_proj_1 &lt; <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].add_threshold &amp;&amp; 
<a name="l06245"></a>06245       rfptr-&gt;n_data_2nd[n_proj_2nd]/rfptr-&gt;n_data_2nd[1] &gt; 0.99 &amp;&amp; 
<a name="l06246"></a>06246       rfptr-&gt;n_data_2nd[n_proj_2nd]*(1.-rfptr-&gt;lambda_2nd[n_proj_2nd]) &gt; 0.5) {
<a name="l06247"></a>06247 
<a name="l06248"></a>06248     <span class="keywordflow">return</span> TRUE;
<a name="l06249"></a>06249   }
<a name="l06250"></a>06250 
<a name="l06251"></a>06251   <span class="keywordflow">return</span> FALSE;
<a name="l06252"></a>06252      
<a name="l06253"></a>06253 }
<a name="l06254"></a>06254 
<a name="l06255"></a>06255 <span class="comment">/*!*****************************************************************************</span>
<a name="l06256"></a>06256 <span class="comment"> *******************************************************************************</span>
<a name="l06257"></a>06257 <span class="comment"> \note  addDimension2nd</span>
<a name="l06258"></a>06258 <span class="comment"> \date  January, 1994</span>
<a name="l06259"></a>06259 <span class="comment"> </span>
<a name="l06260"></a>06260 <span class="comment"> \remarks </span>
<a name="l06261"></a>06261 <span class="comment"> </span>
<a name="l06262"></a>06262 <span class="comment"> add a regression dimensions to the 2nd model of the current receptive field </span>
<a name="l06263"></a>06263 <span class="comment"> </span>
<a name="l06264"></a>06264 <span class="comment"> *******************************************************************************</span>
<a name="l06265"></a>06265 <span class="comment"> Function Parameters: [in]=input,[out]=output</span>
<a name="l06266"></a>06266 <span class="comment"> </span>
<a name="l06267"></a>06267 <span class="comment"> \param[in]     ID     : the ID of the LWPR</span>
<a name="l06268"></a>06268 <span class="comment"> \param[in]     rfID   : the ID of the receptive field</span>
<a name="l06269"></a>06269 <span class="comment"> </span>
<a name="l06270"></a>06270 <span class="comment"> ******************************************************************************/</span>
<a name="l06271"></a>06271 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06272"></a>06272 addDimension2nd(<span class="keywordtype">int</span> ID, <span class="keywordtype">int</span> rfID)
<a name="l06273"></a>06273 
<a name="l06274"></a>06274 {
<a name="l06275"></a>06275   <span class="keywordtype">int</span>    i,j,m;
<a name="l06276"></a>06276   RF    *rfptr;
<a name="l06277"></a>06277   <span class="keywordtype">int</span>    n_in_w;
<a name="l06278"></a>06278   <span class="keywordtype">int</span>    n_in_reg_2nd;
<a name="l06279"></a>06279   <span class="keywordtype">int</span>    n_proj_2nd;
<a name="l06280"></a>06280   <span class="keywordtype">int</span>    n_out_2nd;
<a name="l06281"></a>06281 
<a name="l06282"></a>06282   
<a name="l06283"></a>06283   n_out_2nd      = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_out_2nd;
<a name="l06284"></a>06284   n_in_w         = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_w;
<a name="l06285"></a>06285   n_in_reg_2nd   = <a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].n_in_reg_2nd;
<a name="l06286"></a>06286   rfptr          = &amp;<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].rfs[rfID];
<a name="l06287"></a>06287   n_proj_2nd     = rfptr-&gt;n_proj_2nd;
<a name="l06288"></a>06288 
<a name="l06289"></a>06289   <span class="keywordflow">if</span> (n_proj_2nd == n_in_reg_2nd) {
<a name="l06290"></a>06290     <span class="keywordflow">if</span> (DEBUG_FLAG) printf(<span class="stringliteral">"Max.dimensions reached\n"</span>);
<a name="l06291"></a>06291     <span class="keywordflow">return</span> FALSE;
<a name="l06292"></a>06292   }
<a name="l06293"></a>06293 
<a name="l06294"></a>06294   mat_add_shape(&amp;(rfptr-&gt;B_2nd),1,0);
<a name="l06295"></a>06295   vec_add_shape(&amp;(rfptr-&gt;ss2_2nd),1);
<a name="l06296"></a>06296   rfptr-&gt;ss2_2nd[n_proj_2nd+1]=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_S2;
<a name="l06297"></a>06297   vec_add_shape(&amp;(rfptr-&gt;dof_2nd),1);
<a name="l06298"></a>06298   mat_add_shape(&amp;(rfptr-&gt;SSYres_2nd),1,0);
<a name="l06299"></a>06299   mat_add_shape(&amp;(rfptr-&gt;SSXres_2nd),1,0);
<a name="l06300"></a>06300   mat_add_shape(&amp;(rfptr-&gt;SXresYres_2nd),1,0);
<a name="l06301"></a>06301 
<a name="l06302"></a>06302   mat_add_shape(&amp;(rfptr-&gt;W_2nd),1,0);
<a name="l06303"></a>06303   rfptr-&gt;W_2nd[n_proj_2nd+1][n_proj_2nd+1]=1.0;
<a name="l06304"></a>06304   vec_add_shape(&amp;(rfptr-&gt;Wnorm_2nd),1);
<a name="l06305"></a>06305 
<a name="l06306"></a>06306   mat_add_shape(&amp;(rfptr-&gt;U_2nd),1,0);
<a name="l06307"></a>06307 
<a name="l06308"></a>06308   vec_add_shape(&amp;(rfptr-&gt;sum_weights_2nd),1);
<a name="l06309"></a>06309   rfptr-&gt;sum_weights_2nd[n_proj_2nd+1] = <a class="code" href="lwpr_8h.html#967b832e97d98b3490ab5afa2e4f532c">TINY_NUMBER</a>;
<a name="l06310"></a>06310   vec_add_shape(&amp;(rfptr-&gt;sum_error_2nd),1);
<a name="l06311"></a>06311   vec_add_shape(&amp;(rfptr-&gt;sum_error_cvi_2nd),1);
<a name="l06312"></a>06312   vec_add_shape(&amp;(rfptr-&gt;n_data_2nd),1);
<a name="l06313"></a>06313   vec_add_shape(&amp;(rfptr-&gt;lambda_2nd),1);
<a name="l06314"></a>06314   rfptr-&gt;lambda_2nd[n_proj_2nd+1]=<a class="code" href="lwpr_8c.html#0184f497f582f75bda77d822a1272f3f" title="define LAMBDA(l,w) (l)">lwprs</a>[ID].init_lambda;
<a name="l06315"></a>06315   vec_add_shape(&amp;(rfptr-&gt;s_2nd),1);
<a name="l06316"></a>06316   
<a name="l06317"></a>06317   ++rfptr-&gt;n_proj_2nd;
<a name="l06318"></a>06318 
<a name="l06319"></a>06319   <span class="keywordflow">return</span> TRUE;
<a name="l06320"></a>06320 
<a name="l06321"></a>06321 }
<a name="l06322"></a>06322 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri May 7 22:42:09 2010 for LocallyWeightedProjectionRegressionLibrary by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
